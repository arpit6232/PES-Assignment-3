   1              		.cpu cortex-m0plus
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 6
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"fsl_lpsci.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.NVIC_EnableIRQ,"ax",%progbits
  16              		.align	1
  17              		.arch armv6s-m
  18              		.syntax unified
  19              		.code	16
  20              		.thumb_func
  21              		.fpu softvfp
  23              	NVIC_EnableIRQ:
  24              	.LFB25:
  25              		.file 1 "/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h"
   1:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**************************************************************************//**
   2:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  * @file     core_cm0plus.h
   3:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  * @brief    CMSIS Cortex-M0+ Core Peripheral Access Layer Header File
   4:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  * @version  V4.30
   5:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  * @date     20. October 2015
   6:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  ******************************************************************************/
   7:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* Copyright (c) 2009 - 2015 ARM LIMITED
   8:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
   9:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    All rights reserved.
  10:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    Redistribution and use in source and binary forms, with or without
  11:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    modification, are permitted provided that the following conditions are met:
  12:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    - Redistributions of source code must retain the above copyright
  13:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****      notice, this list of conditions and the following disclaimer.
  14:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    - Redistributions in binary form must reproduce the above copyright
  15:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****      notice, this list of conditions and the following disclaimer in the
  16:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****      documentation and/or other materials provided with the distribution.
  17:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    - Neither the name of ARM nor the names of its contributors may be used
  18:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****      to endorse or promote products derived from this software without
  19:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****      specific prior written permission.
  20:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    *
  21:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  25:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    POSSIBILITY OF SUCH DAMAGE.
  32:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    ---------------------------------------------------------------------------*/
  33:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  34:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  35:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #if   defined ( __ICCARM__ )
  36:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  #pragma system_include         /* treat file as system include file for MISRA check */
  37:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  38:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #pragma clang system_header   /* treat file as system include file */
  39:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #endif
  40:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  41:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #ifndef __CORE_CM0PLUS_H_GENERIC
  42:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define __CORE_CM0PLUS_H_GENERIC
  43:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  44:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #include <stdint.h>
  45:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  46:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #ifdef __cplusplus
  47:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  extern "C" {
  48:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #endif
  49:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  50:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
  51:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  52:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   CMSIS violates the following MISRA-C:2004 rules:
  53:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  54:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  55:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****      Function definitions in header files are used to allow 'inlining'.
  56:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  57:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  58:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****      Unions are used for effective representation of core registers.
  59:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  60:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  61:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****      Function-like macros are used to allow more efficient code.
  62:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
  63:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  64:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  65:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /*******************************************************************************
  66:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  *                 CMSIS definitions
  67:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  ******************************************************************************/
  68:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
  69:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \ingroup Cortex-M0+
  70:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   @{
  71:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
  72:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  73:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /*  CMSIS CM0+ definitions */
  74:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION_MAIN (0x04U)                                   /*!< [31:16] CMSIS H
  75:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION_SUB  (0x1EU)                                   /*!< [15:0]  CMSIS H
  76:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) | \
  77:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****                                        __CM0PLUS_CMSIS_VERSION_SUB           ) /*!< CMSIS HAL versi
  78:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  79:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define __CORTEX_M                (0x00U)                                      /*!< Cortex-M Core *
  80:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  81:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  82:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #if   defined ( __CC_ARM )
  83:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __ASM            __asm                                      /*!< asm keyword for ARM Comp
  84:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __INLINE         __inline                                   /*!< inline keyword for ARM C
  85:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __STATIC_INLINE  static __inline
  86:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  87:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  88:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __ASM            __asm                                      /*!< asm keyword for ARM Comp
  89:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __INLINE         __inline                                   /*!< inline keyword for ARM C
  90:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __STATIC_INLINE  static __inline
  91:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  92:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #elif defined ( __GNUC__ )
  93:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __ASM            __asm                                      /*!< asm keyword for GNU Comp
  94:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __INLINE         inline                                     /*!< inline keyword for GNU C
  95:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __STATIC_INLINE  static inline
  96:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  97:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #elif defined ( __ICCARM__ )
  98:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __ASM            __asm                                      /*!< asm keyword for IAR Comp
  99:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __INLINE         inline                                     /*!< inline keyword for IAR C
 100:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __STATIC_INLINE  static inline
 101:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 102:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #elif defined ( __TMS470__ )
 103:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __ASM            __asm                                      /*!< asm keyword for TI CCS C
 104:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __STATIC_INLINE  static inline
 105:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 106:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #elif defined ( __TASKING__ )
 107:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __ASM            __asm                                      /*!< asm keyword for TASKING 
 108:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __INLINE         inline                                     /*!< inline keyword for TASKI
 109:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __STATIC_INLINE  static inline
 110:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 111:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #elif defined ( __CSMC__ )
 112:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __packed
 113:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __ASM            _asm                                      /*!< asm keyword for COSMIC Co
 114:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __INLINE         inline                                    /*!< inline keyword for COSMIC
 115:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __STATIC_INLINE  static inline
 116:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 117:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #else
 118:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #error Unknown compiler
 119:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #endif
 120:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 121:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /** __FPU_USED indicates whether an FPU is used or not.
 122:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     This core does not support an FPU at all
 123:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** */
 124:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define __FPU_USED       0U
 125:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 126:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #if defined ( __CC_ARM )
 127:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #if defined __TARGET_FPU_VFP
 128:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 129:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #endif
 130:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 131:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
 132:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #if defined __ARM_PCS_VFP
 133:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 134:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #endif
 135:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 136:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #elif defined ( __GNUC__ )
 137:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
 138:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 139:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #endif
 140:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 141:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #elif defined ( __ICCARM__ )
 142:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #if defined __ARMVFP__
 143:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 144:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #endif
 145:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 146:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #elif defined ( __TMS470__ )
 147:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #if defined __TI_VFP_SUPPORT__
 148:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 149:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #endif
 150:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 151:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #elif defined ( __TASKING__ )
 152:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #if defined __FPU_VFP__
 153:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 154:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #endif
 155:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 156:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #elif defined ( __CSMC__ )
 157:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #if ( __CSMC__ & 0x400U)
 158:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 159:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #endif
 160:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 161:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #endif
 162:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 163:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #include "core_cmInstr.h"                /* Core Instruction Access */
 164:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #include "core_cmFunc.h"                 /* Core Function Access */
 165:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 166:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 167:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** }
 168:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #endif
 169:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 170:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #endif /* __CORE_CM0PLUS_H_GENERIC */
 171:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 172:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #ifndef __CMSIS_GENERIC
 173:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 174:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #ifndef __CORE_CM0PLUS_H_DEPENDANT
 175:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define __CORE_CM0PLUS_H_DEPENDANT
 176:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 177:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 178:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  extern "C" {
 179:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #endif
 180:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 181:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* check device defines and use defaults */
 182:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #if defined __CHECK_DEVICE_DEFINES
 183:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #ifndef __CM0PLUS_REV
 184:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #define __CM0PLUS_REV             0x0000U
 185:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #warning "__CM0PLUS_REV not defined in device header file; using default!"
 186:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #endif
 187:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 188:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #ifndef __MPU_PRESENT
 189:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #define __MPU_PRESENT             0U
 190:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #warning "__MPU_PRESENT not defined in device header file; using default!"
 191:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #endif
 192:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 193:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #ifndef __VTOR_PRESENT
 194:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #define __VTOR_PRESENT            0U
 195:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #warning "__VTOR_PRESENT not defined in device header file; using default!"
 196:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #endif
 197:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 198:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #ifndef __NVIC_PRIO_BITS
 199:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #define __NVIC_PRIO_BITS          2U
 200:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 201:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #endif
 202:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 203:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #ifndef __Vendor_SysTickConfig
 204:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #define __Vendor_SysTickConfig    0U
 205:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 206:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #endif
 207:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #endif
 208:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 209:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* IO definitions (access restrictions to peripheral registers) */
 210:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 211:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 212:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 213:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     <strong>IO Type Qualifiers</strong> are used
 214:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     \li to specify the access to peripheral variables.
 215:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     \li for automatic generation of peripheral register debug information.
 216:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** */
 217:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 218:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 219:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #else
 220:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
 221:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #endif
 222:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 223:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 224:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 225:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* following defines should be used for structure members */
 226:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 227:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 228:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 229:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 230:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /*@} end of group Cortex-M0+ */
 231:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 232:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 233:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 234:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /*******************************************************************************
 235:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  *                 Register Abstraction
 236:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   Core Register contain:
 237:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   - Core Register
 238:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   - Core NVIC Register
 239:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   - Core SCB Register
 240:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   - Core SysTick Register
 241:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   - Core MPU Register
 242:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  ******************************************************************************/
 243:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 244:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \defgroup CMSIS_core_register Defines and Type Definitions
 245:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief Type definitions and defines for Cortex-M processor based devices.
 246:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** */
 247:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 248:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 249:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 250:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_CORE  Status and Control Registers
 251:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief      Core Register type definitions.
 252:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   @{
 253:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 254:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 255:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 256:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief  Union type to access the Application Program Status Register (APSR).
 257:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 258:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** typedef union
 259:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** {
 260:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   struct
 261:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   {
 262:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
 263:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 264:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 265:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 266:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 267:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 268:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 269:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** } APSR_Type;
 270:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 271:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* APSR Register Definitions */
 272:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 273:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 274:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 275:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 276:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 277:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 278:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
 279:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 280:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 281:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 282:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 283:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 284:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 285:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 286:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief  Union type to access the Interrupt Program Status Register (IPSR).
 287:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 288:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** typedef union
 289:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** {
 290:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   struct
 291:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   {
 292:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 293:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 294:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 295:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 296:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** } IPSR_Type;
 297:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 298:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* IPSR Register Definitions */
 299:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 300:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 301:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 302:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 303:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 304:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 305:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 306:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** typedef union
 307:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** {
 308:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   struct
 309:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   {
 310:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 311:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
 312:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
 313:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
 314:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 315:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 316:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 317:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 318:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 319:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 320:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** } xPSR_Type;
 321:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 322:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* xPSR Register Definitions */
 323:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 324:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 325:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 326:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
 327:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 328:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 329:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 330:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 331:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 332:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 333:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 334:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 335:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
 336:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 337:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 338:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 339:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 340:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 341:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 342:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 343:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief  Union type to access the Control Registers (CONTROL).
 344:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 345:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** typedef union
 346:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** {
 347:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   struct
 348:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   {
 349:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
 350:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 351:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
 352:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 353:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 354:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** } CONTROL_Type;
 355:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 356:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* CONTROL Register Definitions */
 357:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 358:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 359:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 360:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define CONTROL_nPRIV_Pos                   0U                                            /*!< CONT
 361:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONT
 362:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 363:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_CORE */
 364:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 365:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 366:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 367:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 368:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 369:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief      Type definitions for the NVIC Registers
 370:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   @{
 371:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 372:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 373:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 374:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 375:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 376:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** typedef struct
 377:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** {
 378:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
 379:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****         uint32_t RESERVED0[31U];
 380:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 381:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****         uint32_t RSERVED1[31U];
 382:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 383:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****         uint32_t RESERVED2[31U];
 384:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 385:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****         uint32_t RESERVED3[31U];
 386:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****         uint32_t RESERVED4[64U];
 387:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
 388:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** }  NVIC_Type;
 389:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 390:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_NVIC */
 391:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 392:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 393:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 394:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 395:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \defgroup CMSIS_SCB     System Control Block (SCB)
 396:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief    Type definitions for the System Control Block Registers
 397:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   @{
 398:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 399:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 400:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 401:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief  Structure type to access the System Control Block (SCB).
 402:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 403:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** typedef struct
 404:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** {
 405:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 406:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 407:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #if (__VTOR_PRESENT == 1U)
 408:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
 409:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #else
 410:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****         uint32_t RESERVED0;
 411:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #endif
 412:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 413:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
 414:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 415:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****         uint32_t RESERVED1;
 416:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registe
 417:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
 418:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** } SCB_Type;
 419:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 420:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* SCB CPUID Register Definitions */
 421:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 422:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 423:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 424:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 425:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 426:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 427:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 428:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 429:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 430:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 431:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 432:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 433:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 434:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 435:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 436:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* SCB Interrupt Control State Register Definitions */
 437:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
 438:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 439:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 440:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 441:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 442:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 443:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 444:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 445:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 446:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 447:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 448:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 449:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 450:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 451:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 452:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 453:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 454:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 455:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 456:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 457:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 458:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
 459:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 460:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 461:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 462:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 463:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 464:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #if (__VTOR_PRESENT == 1U)
 465:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* SCB Interrupt Control State Register Definitions */
 466:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_VTOR_TBLOFF_Pos                 8U                                            /*!< SCB 
 467:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_VTOR_TBLOFF_Msk                (0xFFFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB 
 468:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #endif
 469:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 470:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 471:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 472:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 473:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 474:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 475:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 476:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 477:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 478:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 479:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 480:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
 481:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 482:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 483:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 484:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 485:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 486:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* SCB System Control Register Definitions */
 487:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 488:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 489:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 490:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 491:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 492:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 493:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 494:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 495:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 496:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* SCB Configuration Control Register Definitions */
 497:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 498:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 499:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 500:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
 501:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 502:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 503:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* SCB System Handler Control and State Register Definitions */
 504:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
 505:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 506:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 507:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_SCB */
 508:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 509:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 510:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 511:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 512:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 513:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief    Type definitions for the System Timer Registers.
 514:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   @{
 515:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 516:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 517:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 518:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief  Structure type to access the System Timer (SysTick).
 519:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 520:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** typedef struct
 521:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** {
 522:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 523:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 524:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 525:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 526:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** } SysTick_Type;
 527:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 528:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* SysTick Control / Status Register Definitions */
 529:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 530:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 531:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 532:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 533:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 534:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 535:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
 536:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 537:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 538:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 539:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 540:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 541:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* SysTick Reload Register Definitions */
 542:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 543:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 544:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 545:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* SysTick Current Register Definitions */
 546:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 547:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 548:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 549:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* SysTick Calibration Register Definitions */
 550:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 551:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 552:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 553:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 554:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 555:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 556:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 557:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 558:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 559:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_SysTick */
 560:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 561:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #if (__MPU_PRESENT == 1U)
 562:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 563:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 564:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
 565:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief    Type definitions for the Memory Protection Unit (MPU)
 566:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   @{
 567:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 568:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 569:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 570:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief  Structure type to access the Memory Protection Unit (MPU).
 571:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 572:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** typedef struct
 573:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** {
 574:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
 575:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
 576:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
 577:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register
 578:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Re
 579:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** } MPU_Type;
 580:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 581:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* MPU Type Register Definitions */
 582:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU 
 583:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU 
 584:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 585:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU 
 586:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU 
 587:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 588:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU 
 589:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU 
 590:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 591:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* MPU Control Register Definitions */
 592:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU 
 593:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU 
 594:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 595:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU 
 596:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU 
 597:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 598:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU 
 599:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU 
 600:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 601:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* MPU Region Number Register Definitions */
 602:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU 
 603:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU 
 604:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 605:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* MPU Region Base Address Register Definitions */
 606:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RBAR_ADDR_Pos                   8U                                            /*!< MPU 
 607:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RBAR_ADDR_Msk                  (0xFFFFFFUL << MPU_RBAR_ADDR_Pos)              /*!< MPU 
 608:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 609:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU 
 610:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU 
 611:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 612:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU 
 613:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU 
 614:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 615:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* MPU Region Attribute and Size Register Definitions */
 616:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU 
 617:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU 
 618:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 619:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_XN_Pos                    28U                                            /*!< MPU 
 620:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU 
 621:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 622:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_AP_Pos                    24U                                            /*!< MPU 
 623:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU 
 624:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 625:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU 
 626:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU 
 627:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 628:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_S_Pos                     18U                                            /*!< MPU 
 629:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU 
 630:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 631:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_C_Pos                     17U                                            /*!< MPU 
 632:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU 
 633:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 634:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_B_Pos                     16U                                            /*!< MPU 
 635:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU 
 636:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 637:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU 
 638:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU 
 639:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 640:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU 
 641:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU 
 642:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 643:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU 
 644:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU 
 645:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 646:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_MPU */
 647:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #endif
 648:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 649:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 650:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 651:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 652:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
 653:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief    Cortex-M0+ Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible ov
 654:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****             Therefore they are not covered by the Cortex-M0+ header file.
 655:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   @{
 656:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 657:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_CoreDebug */
 658:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 659:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 660:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 661:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 662:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_core_bitfield     Core register bit field macros
 663:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
 664:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   @{
 665:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 666:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 667:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 668:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief   Mask and shift a bit field value for use in a register bit range.
 669:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \param[in] field  Name of the register bit field.
 670:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \param[in] value  Value of the bit field.
 671:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \return           Masked and shifted value.
 672:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** */
 673:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define _VAL2FLD(field, value)    ((value << field ## _Pos) & field ## _Msk)
 674:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 675:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 676:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief     Mask and shift a register value to extract a bit filed value.
 677:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \param[in] field  Name of the register bit field.
 678:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \param[in] value  Value of register.
 679:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \return           Masked and shifted bit field value.
 680:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** */
 681:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define _FLD2VAL(field, value)    ((value & field ## _Msk) >> field ## _Pos)
 682:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 683:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_core_bitfield */
 684:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 685:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 686:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 687:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 688:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_core_base     Core Definitions
 689:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief      Definitions for base addresses, unions, and structures.
 690:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   @{
 691:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 692:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 693:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* Memory mapping of Cortex-M0+ Hardware */
 694:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
 695:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
 696:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
 697:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
 698:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 699:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
 700:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
 701:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
 702:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 703:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #if (__MPU_PRESENT == 1U)
 704:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit *
 705:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit *
 706:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #endif
 707:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 708:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /*@} */
 709:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 710:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 711:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 712:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /*******************************************************************************
 713:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  *                Hardware Abstraction Layer
 714:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   Core Function Interface contains:
 715:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   - Core NVIC Functions
 716:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   - Core SysTick Functions
 717:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   - Core Register Access Functions
 718:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  ******************************************************************************/
 719:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 720:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
 721:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** */
 722:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 723:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 724:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 725:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* ##########################   NVIC functions  #################################### */
 726:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 727:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_Core_FunctionInterface
 728:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_NVICFunctions NVIC Functions
 729:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief    Functions that manage interrupts and exceptions via the NVIC.
 730:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   @{
 731:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 732:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 733:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* Interrupt Priorities are WORD accessible only under ARMv6M                   */
 734:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* The following MACROS handle generation of the register offset and byte masks */
 735:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
 736:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
 737:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
 738:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 739:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 740:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 741:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief   Enable External Interrupt
 742:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \details Enables a device-specific interrupt in the NVIC interrupt controller.
 743:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \param [in]      IRQn  External interrupt number. Value cannot be negative.
 744:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 745:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
 746:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** {
  26              		.loc 1 746 1
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 8
  29              		@ frame_needed = 1, uses_anonymous_args = 0
  30 0000 80B5     		push	{r7, lr}
  31              		.cfi_def_cfa_offset 8
  32              		.cfi_offset 7, -8
  33              		.cfi_offset 14, -4
  34 0002 82B0     		sub	sp, sp, #8
  35              		.cfi_def_cfa_offset 16
  36 0004 00AF     		add	r7, sp, #0
  37              		.cfi_def_cfa_register 7
  38 0006 0200     		movs	r2, r0
  39 0008 FB1D     		adds	r3, r7, #7
  40 000a 1A70     		strb	r2, [r3]
 747:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
  41              		.loc 1 747 65
  42 000c FB1D     		adds	r3, r7, #7
  43 000e 1B78     		ldrb	r3, [r3]
  44 0010 1A00     		movs	r2, r3
  45 0012 1F23     		movs	r3, #31
  46 0014 1A40     		ands	r2, r3
  47              		.loc 1 747 7
  48 0016 044B     		ldr	r3, .L2
  49              		.loc 1 747 35
  50 0018 0121     		movs	r1, #1
  51 001a 9140     		lsls	r1, r1, r2
  52 001c 0A00     		movs	r2, r1
  53              		.loc 1 747 18
  54 001e 1A60     		str	r2, [r3]
 748:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** }
  55              		.loc 1 748 1
  56 0020 C046     		nop
  57 0022 BD46     		mov	sp, r7
  58 0024 02B0     		add	sp, sp, #8
  59              		@ sp needed
  60 0026 80BD     		pop	{r7, pc}
  61              	.L3:
  62              		.align	2
  63              	.L2:
  64 0028 00E100E0 		.word	-536813312
  65              		.cfi_endproc
  66              	.LFE25:
  68              		.section	.text.CLOCK_EnableClock,"ax",%progbits
  69              		.align	1
  70              		.syntax unified
  71              		.code	16
  72              		.thumb_func
  73              		.fpu softvfp
  75              	CLOCK_EnableClock:
  76              	.LFB34:
  77              		.file 2 "../drivers/fsl_clock.h"
   1:../drivers/fsl_clock.h **** /*
   2:../drivers/fsl_clock.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   3:../drivers/fsl_clock.h ****  * Copyright (c) 2016 - 2017 , NXP
   4:../drivers/fsl_clock.h ****  * All rights reserved.
   5:../drivers/fsl_clock.h ****  *
   6:../drivers/fsl_clock.h ****  * Redistribution and use in source and binary forms, with or without modification,
   7:../drivers/fsl_clock.h ****  * are permitted provided that the following conditions are met:
   8:../drivers/fsl_clock.h ****  *
   9:../drivers/fsl_clock.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  10:../drivers/fsl_clock.h ****  *   of conditions and the following disclaimer.
  11:../drivers/fsl_clock.h ****  *
  12:../drivers/fsl_clock.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  13:../drivers/fsl_clock.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  14:../drivers/fsl_clock.h ****  *   other materials provided with the distribution.
  15:../drivers/fsl_clock.h ****  *
  16:../drivers/fsl_clock.h ****  * o Neither the name of copyright holder nor the names of its
  17:../drivers/fsl_clock.h ****  *   contributors may be used to endorse or promote products derived from this
  18:../drivers/fsl_clock.h ****  *   software without specific prior written permission.
  19:../drivers/fsl_clock.h ****  *
  20:../drivers/fsl_clock.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  21:../drivers/fsl_clock.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  22:../drivers/fsl_clock.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  23:../drivers/fsl_clock.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  24:../drivers/fsl_clock.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  25:../drivers/fsl_clock.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  26:../drivers/fsl_clock.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  27:../drivers/fsl_clock.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  28:../drivers/fsl_clock.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  29:../drivers/fsl_clock.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  30:../drivers/fsl_clock.h ****  */
  31:../drivers/fsl_clock.h **** 
  32:../drivers/fsl_clock.h **** #ifndef _FSL_CLOCK_H_
  33:../drivers/fsl_clock.h **** #define _FSL_CLOCK_H_
  34:../drivers/fsl_clock.h **** 
  35:../drivers/fsl_clock.h **** #include "fsl_common.h"
  36:../drivers/fsl_clock.h **** 
  37:../drivers/fsl_clock.h **** /*! @addtogroup clock */
  38:../drivers/fsl_clock.h **** /*! @{ */
  39:../drivers/fsl_clock.h **** 
  40:../drivers/fsl_clock.h **** /*! @file */
  41:../drivers/fsl_clock.h **** 
  42:../drivers/fsl_clock.h **** /*******************************************************************************
  43:../drivers/fsl_clock.h ****  * Configurations
  44:../drivers/fsl_clock.h ****  ******************************************************************************/
  45:../drivers/fsl_clock.h **** 
  46:../drivers/fsl_clock.h **** /*! @brief Configures whether to check a parameter in a function.
  47:../drivers/fsl_clock.h ****  *
  48:../drivers/fsl_clock.h ****  * Some MCG settings must be changed with conditions, for example:
  49:../drivers/fsl_clock.h ****  *  1. MCGIRCLK settings, such as the source, divider, and the trim value should not change when
  50:../drivers/fsl_clock.h ****  *     MCGIRCLK is used as a system clock source.
  51:../drivers/fsl_clock.h ****  *  2. MCG_C7[OSCSEL] should not be changed  when the external reference clock is used
  52:../drivers/fsl_clock.h ****  *     as a system clock source. For example, in FBE/BLPE/PBE modes.
  53:../drivers/fsl_clock.h ****  *  3. The users should only switch between the supported clock modes.
  54:../drivers/fsl_clock.h ****  *
  55:../drivers/fsl_clock.h ****  * MCG functions check the parameter and MCG status before setting, if not allowed
  56:../drivers/fsl_clock.h ****  * to change, the functions return error. The parameter checking increases code size,
  57:../drivers/fsl_clock.h ****  * if code size is a critical requirement, change #MCG_CONFIG_CHECK_PARAM to 0 to
  58:../drivers/fsl_clock.h ****  * disable parameter checking.
  59:../drivers/fsl_clock.h ****  */
  60:../drivers/fsl_clock.h **** #ifndef MCG_CONFIG_CHECK_PARAM
  61:../drivers/fsl_clock.h **** #define MCG_CONFIG_CHECK_PARAM 0U
  62:../drivers/fsl_clock.h **** #endif
  63:../drivers/fsl_clock.h **** 
  64:../drivers/fsl_clock.h **** /*! @brief Configure whether driver controls clock
  65:../drivers/fsl_clock.h ****  *
  66:../drivers/fsl_clock.h ****  * When set to 0, peripheral drivers will enable clock in initialize function
  67:../drivers/fsl_clock.h ****  * and disable clock in de-initialize function. When set to 1, peripheral
  68:../drivers/fsl_clock.h ****  * driver will not control the clock, application could contol the clock out of
  69:../drivers/fsl_clock.h ****  * the driver.
  70:../drivers/fsl_clock.h ****  *
  71:../drivers/fsl_clock.h ****  * @note All drivers share this feature switcher. If it is set to 1, application
  72:../drivers/fsl_clock.h ****  * should handle clock enable and disable for all drivers.
  73:../drivers/fsl_clock.h ****  */
  74:../drivers/fsl_clock.h **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))
  75:../drivers/fsl_clock.h **** #define FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL 0
  76:../drivers/fsl_clock.h **** #endif
  77:../drivers/fsl_clock.h **** 
  78:../drivers/fsl_clock.h **** /*******************************************************************************
  79:../drivers/fsl_clock.h ****  * Definitions
  80:../drivers/fsl_clock.h ****  ******************************************************************************/
  81:../drivers/fsl_clock.h **** 
  82:../drivers/fsl_clock.h **** /*! @name Driver version */
  83:../drivers/fsl_clock.h **** /*@{*/
  84:../drivers/fsl_clock.h **** /*! @brief CLOCK driver version 2.2.1. */
  85:../drivers/fsl_clock.h **** #define FSL_CLOCK_DRIVER_VERSION (MAKE_VERSION(2, 2, 1))
  86:../drivers/fsl_clock.h **** /*@}*/
  87:../drivers/fsl_clock.h **** 
  88:../drivers/fsl_clock.h **** /*! @brief External XTAL0 (OSC0) clock frequency.
  89:../drivers/fsl_clock.h ****  *
  90:../drivers/fsl_clock.h ****  * The XTAL0/EXTAL0 (OSC0) clock frequency in Hz. When the clock is set up, use the
  91:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal0Freq to set the value in the clock driver. For example,
  92:../drivers/fsl_clock.h ****  * if XTAL0 is 8 MHz:
  93:../drivers/fsl_clock.h ****  * @code
  94:../drivers/fsl_clock.h ****  * CLOCK_InitOsc0(...); // Set up the OSC0
  95:../drivers/fsl_clock.h ****  * CLOCK_SetXtal0Freq(80000000); // Set the XTAL0 value to the clock driver.
  96:../drivers/fsl_clock.h ****  * @endcode
  97:../drivers/fsl_clock.h ****  *
  98:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where only one core needs to set up the
  99:../drivers/fsl_clock.h ****  * OSC0 using the CLOCK_InitOsc0. All other cores need to call the CLOCK_SetXtal0Freq
 100:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
 101:../drivers/fsl_clock.h ****  */
 102:../drivers/fsl_clock.h **** extern uint32_t g_xtal0Freq;
 103:../drivers/fsl_clock.h **** 
 104:../drivers/fsl_clock.h **** /*! @brief External XTAL32/EXTAL32/RTC_CLKIN clock frequency.
 105:../drivers/fsl_clock.h ****  *
 106:../drivers/fsl_clock.h ****  * The XTAL32/EXTAL32/RTC_CLKIN clock frequency in Hz. When the clock is set up, use the
 107:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal32Freq to set the value in the clock driver.
 108:../drivers/fsl_clock.h ****  *
 109:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where only one core needs to set up
 110:../drivers/fsl_clock.h ****  * the clock. All other cores need to call the CLOCK_SetXtal32Freq
 111:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
 112:../drivers/fsl_clock.h ****  */
 113:../drivers/fsl_clock.h **** extern uint32_t g_xtal32Freq;
 114:../drivers/fsl_clock.h **** 
 115:../drivers/fsl_clock.h **** #if (defined(OSC) && !(defined(OSC0)))
 116:../drivers/fsl_clock.h **** #define OSC0 OSC
 117:../drivers/fsl_clock.h **** #endif
 118:../drivers/fsl_clock.h **** 
 119:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMAMUX. */
 120:../drivers/fsl_clock.h **** #define DMAMUX_CLOCKS  \
 121:../drivers/fsl_clock.h ****     {                  \
 122:../drivers/fsl_clock.h ****         kCLOCK_Dmamux0 \
 123:../drivers/fsl_clock.h ****     }
 124:../drivers/fsl_clock.h **** 
 125:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RTC. */
 126:../drivers/fsl_clock.h **** #define RTC_CLOCKS  \
 127:../drivers/fsl_clock.h ****     {               \
 128:../drivers/fsl_clock.h ****         kCLOCK_Rtc0 \
 129:../drivers/fsl_clock.h ****     }
 130:../drivers/fsl_clock.h **** 
 131:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SPI. */
 132:../drivers/fsl_clock.h **** #define SPI_CLOCKS               \
 133:../drivers/fsl_clock.h ****     {                            \
 134:../drivers/fsl_clock.h ****         kCLOCK_Spi0, kCLOCK_Spi1 \
 135:../drivers/fsl_clock.h ****     }
 136:../drivers/fsl_clock.h **** 
 137:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PIT. */
 138:../drivers/fsl_clock.h **** #define PIT_CLOCKS  \
 139:../drivers/fsl_clock.h ****     {               \
 140:../drivers/fsl_clock.h ****         kCLOCK_Pit0 \
 141:../drivers/fsl_clock.h ****     }
 142:../drivers/fsl_clock.h **** 
 143:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PORT. */
 144:../drivers/fsl_clock.h **** #define PORT_CLOCKS                                                          \
 145:../drivers/fsl_clock.h ****     {                                                                        \
 146:../drivers/fsl_clock.h ****         kCLOCK_PortA, kCLOCK_PortB, kCLOCK_PortC, kCLOCK_PortD, kCLOCK_PortE \
 147:../drivers/fsl_clock.h ****     }
 148:../drivers/fsl_clock.h **** 
 149:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for TSI. */
 150:../drivers/fsl_clock.h **** #define TSI_CLOCKS  \
 151:../drivers/fsl_clock.h ****     {               \
 152:../drivers/fsl_clock.h ****         kCLOCK_Tsi0 \
 153:../drivers/fsl_clock.h ****     }
 154:../drivers/fsl_clock.h **** 
 155:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DAC. */
 156:../drivers/fsl_clock.h **** #define DAC_CLOCKS  \
 157:../drivers/fsl_clock.h ****     {               \
 158:../drivers/fsl_clock.h ****         kCLOCK_Dac0 \
 159:../drivers/fsl_clock.h ****     }
 160:../drivers/fsl_clock.h **** 
 161:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPTMR. */
 162:../drivers/fsl_clock.h **** #define LPTMR_CLOCKS  \
 163:../drivers/fsl_clock.h ****     {                 \
 164:../drivers/fsl_clock.h ****         kCLOCK_Lptmr0 \
 165:../drivers/fsl_clock.h ****     }
 166:../drivers/fsl_clock.h **** 
 167:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ADC16. */
 168:../drivers/fsl_clock.h **** #define ADC16_CLOCKS \
 169:../drivers/fsl_clock.h ****     {                \
 170:../drivers/fsl_clock.h ****         kCLOCK_Adc0  \
 171:../drivers/fsl_clock.h ****     }
 172:../drivers/fsl_clock.h **** 
 173:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMA. */
 174:../drivers/fsl_clock.h **** #define DMA_CLOCKS  \
 175:../drivers/fsl_clock.h ****     {               \
 176:../drivers/fsl_clock.h ****         kCLOCK_Dma0 \
 177:../drivers/fsl_clock.h ****     }
 178:../drivers/fsl_clock.h **** 
 179:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPSCI/UART0. */
 180:../drivers/fsl_clock.h **** #define UART0_CLOCKS \
 181:../drivers/fsl_clock.h ****     {                \
 182:../drivers/fsl_clock.h ****         kCLOCK_Uart0 \
 183:../drivers/fsl_clock.h ****     }
 184:../drivers/fsl_clock.h **** 
 185:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for UART. */
 186:../drivers/fsl_clock.h **** #define UART_CLOCKS                                  \
 187:../drivers/fsl_clock.h ****     {                                                \
 188:../drivers/fsl_clock.h ****         kCLOCK_IpInvalid, kCLOCK_Uart1, kCLOCK_Uart2 \
 189:../drivers/fsl_clock.h ****     }
 190:../drivers/fsl_clock.h **** 
 191:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for TPM. */
 192:../drivers/fsl_clock.h **** #define TPM_CLOCKS                            \
 193:../drivers/fsl_clock.h ****     {                                         \
 194:../drivers/fsl_clock.h ****         kCLOCK_Tpm0, kCLOCK_Tpm1, kCLOCK_Tpm2 \
 195:../drivers/fsl_clock.h ****     }
 196:../drivers/fsl_clock.h **** 
 197:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for I2C. */
 198:../drivers/fsl_clock.h **** #define I2C_CLOCKS               \
 199:../drivers/fsl_clock.h ****     {                            \
 200:../drivers/fsl_clock.h ****         kCLOCK_I2c0, kCLOCK_I2c1 \
 201:../drivers/fsl_clock.h ****     }
 202:../drivers/fsl_clock.h **** 
 203:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTF. */
 204:../drivers/fsl_clock.h **** #define FTF_CLOCKS  \
 205:../drivers/fsl_clock.h ****     {               \
 206:../drivers/fsl_clock.h ****         kCLOCK_Ftf0 \
 207:../drivers/fsl_clock.h ****     }
 208:../drivers/fsl_clock.h **** 
 209:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMP. */
 210:../drivers/fsl_clock.h **** #define CMP_CLOCKS  \
 211:../drivers/fsl_clock.h ****     {               \
 212:../drivers/fsl_clock.h ****         kCLOCK_Cmp0 \
 213:../drivers/fsl_clock.h ****     }
 214:../drivers/fsl_clock.h **** 
 215:../drivers/fsl_clock.h **** /*!
 216:../drivers/fsl_clock.h ****  * @brief LPO clock frequency.
 217:../drivers/fsl_clock.h ****  */
 218:../drivers/fsl_clock.h **** #define LPO_CLK_FREQ 1000U
 219:../drivers/fsl_clock.h **** 
 220:../drivers/fsl_clock.h **** /*! @brief Peripherals clock source definition. */
 221:../drivers/fsl_clock.h **** #define SYS_CLK kCLOCK_CoreSysClk
 222:../drivers/fsl_clock.h **** #define BUS_CLK kCLOCK_BusClk
 223:../drivers/fsl_clock.h **** 
 224:../drivers/fsl_clock.h **** #define I2C0_CLK_SRC BUS_CLK
 225:../drivers/fsl_clock.h **** #define I2C1_CLK_SRC BUS_CLK
 226:../drivers/fsl_clock.h **** #define SPI0_CLK_SRC BUS_CLK
 227:../drivers/fsl_clock.h **** #define SPI1_CLK_SRC SYS_CLK
 228:../drivers/fsl_clock.h **** #define UART1_CLK_SRC BUS_CLK
 229:../drivers/fsl_clock.h **** #define UART2_CLK_SRC BUS_CLK
 230:../drivers/fsl_clock.h **** 
 231:../drivers/fsl_clock.h **** /*! @brief Clock name used to get clock frequency. */
 232:../drivers/fsl_clock.h **** typedef enum _clock_name
 233:../drivers/fsl_clock.h **** {
 234:../drivers/fsl_clock.h **** 
 235:../drivers/fsl_clock.h ****     /* ----------------------------- System layer clock -------------------------------*/
 236:../drivers/fsl_clock.h ****     kCLOCK_CoreSysClk,   /*!< Core/system clock                                         */
 237:../drivers/fsl_clock.h ****     kCLOCK_PlatClk,      /*!< Platform clock                                            */
 238:../drivers/fsl_clock.h ****     kCLOCK_BusClk,       /*!< Bus clock                                                 */
 239:../drivers/fsl_clock.h ****     kCLOCK_FlexBusClk,   /*!< FlexBus clock                                             */
 240:../drivers/fsl_clock.h ****     kCLOCK_FlashClk,     /*!< Flash clock                                               */
 241:../drivers/fsl_clock.h ****     kCLOCK_PllFllSelClk, /*!< The clock after SIM[PLLFLLSEL].                           */
 242:../drivers/fsl_clock.h **** 
 243:../drivers/fsl_clock.h ****     /* ---------------------------------- OSC clock -----------------------------------*/
 244:../drivers/fsl_clock.h ****     kCLOCK_Er32kClk,  /*!< External reference 32K clock (ERCLK32K)                   */
 245:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClk, /*!< OSC0 external reference clock (OSC0ERCLK)                 */
 246:../drivers/fsl_clock.h **** 
 247:../drivers/fsl_clock.h ****     /* ----------------------------- MCG and MCG-Lite clock ---------------------------*/
 248:../drivers/fsl_clock.h ****     kCLOCK_McgFixedFreqClk,   /*!< MCG fixed frequency clock (MCGFFCLK)                      */
 249:../drivers/fsl_clock.h ****     kCLOCK_McgInternalRefClk, /*!< MCG internal reference clock (MCGIRCLK)                   */
 250:../drivers/fsl_clock.h ****     kCLOCK_McgFllClk,         /*!< MCGFLLCLK                                                 */
 251:../drivers/fsl_clock.h ****     kCLOCK_McgPll0Clk,        /*!< MCGPLL0CLK                                                */
 252:../drivers/fsl_clock.h ****     kCLOCK_McgExtPllClk,      /*!< EXT_PLLCLK                                                */
 253:../drivers/fsl_clock.h **** 
 254:../drivers/fsl_clock.h ****     /* --------------------------------- Other clock ----------------------------------*/
 255:../drivers/fsl_clock.h ****     kCLOCK_LpoClk, /*!< LPO clock                                                 */
 256:../drivers/fsl_clock.h **** 
 257:../drivers/fsl_clock.h **** } clock_name_t;
 258:../drivers/fsl_clock.h **** 
 259:../drivers/fsl_clock.h **** /*! @brief USB clock source definition. */
 260:../drivers/fsl_clock.h **** typedef enum _clock_usb_src
 261:../drivers/fsl_clock.h **** {
 262:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcPll0 = SIM_SOPT2_USBSRC(1U) | SIM_SOPT2_PLLFLLSEL(1U), /*!< Use PLL0.      */
 263:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcExt = SIM_SOPT2_USBSRC(0U)                             /*!< Use USB_CLKIN. */
 264:../drivers/fsl_clock.h **** } clock_usb_src_t;
 265:../drivers/fsl_clock.h **** 
 266:../drivers/fsl_clock.h **** /*------------------------------------------------------------------------------
 267:../drivers/fsl_clock.h **** 
 268:../drivers/fsl_clock.h ****  clock_gate_t definition:
 269:../drivers/fsl_clock.h **** 
 270:../drivers/fsl_clock.h ****  31                              16                              0
 271:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 272:../drivers/fsl_clock.h ****  | SIM_SCGC register offset       |   control bit offset in SCGC |
 273:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 274:../drivers/fsl_clock.h **** 
 275:../drivers/fsl_clock.h ****  For example, the SDHC clock gate is controlled by SIM_SCGC3[17], the
 276:../drivers/fsl_clock.h ****  SIM_SCGC3 offset in SIM is 0x1030, then kCLOCK_GateSdhc0 is defined as
 277:../drivers/fsl_clock.h **** 
 278:../drivers/fsl_clock.h ****               kCLOCK_GateSdhc0 = (0x1030 << 16) | 17;
 279:../drivers/fsl_clock.h **** 
 280:../drivers/fsl_clock.h **** ------------------------------------------------------------------------------*/
 281:../drivers/fsl_clock.h **** 
 282:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_SHIFT 16U
 283:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_MASK 0xFFFF0000U
 284:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_SHIFT 0U
 285:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_MASK 0x0000FFFFU
 286:../drivers/fsl_clock.h **** 
 287:../drivers/fsl_clock.h **** #define CLK_GATE_DEFINE(reg_offset, bit_shift)                                  \
 288:../drivers/fsl_clock.h ****     ((((reg_offset) << CLK_GATE_REG_OFFSET_SHIFT) & CLK_GATE_REG_OFFSET_MASK) | \
 289:../drivers/fsl_clock.h ****      (((bit_shift) << CLK_GATE_BIT_SHIFT_SHIFT) & CLK_GATE_BIT_SHIFT_MASK))
 290:../drivers/fsl_clock.h **** 
 291:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_REG_OFFSET(x) (((x)&CLK_GATE_REG_OFFSET_MASK) >> CLK_GATE_REG_OFFSET_SHIF
 292:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_BITS_SHIFT(x) (((x)&CLK_GATE_BIT_SHIFT_MASK) >> CLK_GATE_BIT_SHIFT_SHIFT)
 293:../drivers/fsl_clock.h **** 
 294:../drivers/fsl_clock.h **** /*! @brief Clock gate name used for CLOCK_EnableClock/CLOCK_DisableClock. */
 295:../drivers/fsl_clock.h **** typedef enum _clock_ip_name
 296:../drivers/fsl_clock.h **** {
 297:../drivers/fsl_clock.h ****     kCLOCK_IpInvalid = 0U,
 298:../drivers/fsl_clock.h ****     kCLOCK_I2c0 = CLK_GATE_DEFINE(0x1034U, 6U),
 299:../drivers/fsl_clock.h ****     kCLOCK_I2c1 = CLK_GATE_DEFINE(0x1034U, 7U),
 300:../drivers/fsl_clock.h ****     kCLOCK_Uart0 = CLK_GATE_DEFINE(0x1034U, 10U),
 301:../drivers/fsl_clock.h ****     kCLOCK_Uart1 = CLK_GATE_DEFINE(0x1034U, 11U),
 302:../drivers/fsl_clock.h ****     kCLOCK_Uart2 = CLK_GATE_DEFINE(0x1034U, 12U),
 303:../drivers/fsl_clock.h ****     kCLOCK_Usbfs0 = CLK_GATE_DEFINE(0x1034U, 18U),
 304:../drivers/fsl_clock.h ****     kCLOCK_Cmp0 = CLK_GATE_DEFINE(0x1034U, 19U),
 305:../drivers/fsl_clock.h ****     kCLOCK_Spi0 = CLK_GATE_DEFINE(0x1034U, 22U),
 306:../drivers/fsl_clock.h ****     kCLOCK_Spi1 = CLK_GATE_DEFINE(0x1034U, 23U),
 307:../drivers/fsl_clock.h **** 
 308:../drivers/fsl_clock.h ****     kCLOCK_Lptmr0 = CLK_GATE_DEFINE(0x1038U, 0U),
 309:../drivers/fsl_clock.h ****     kCLOCK_Tsi0 = CLK_GATE_DEFINE(0x1038U, 5U),
 310:../drivers/fsl_clock.h ****     kCLOCK_PortA = CLK_GATE_DEFINE(0x1038U, 9U),
 311:../drivers/fsl_clock.h ****     kCLOCK_PortB = CLK_GATE_DEFINE(0x1038U, 10U),
 312:../drivers/fsl_clock.h ****     kCLOCK_PortC = CLK_GATE_DEFINE(0x1038U, 11U),
 313:../drivers/fsl_clock.h ****     kCLOCK_PortD = CLK_GATE_DEFINE(0x1038U, 12U),
 314:../drivers/fsl_clock.h ****     kCLOCK_PortE = CLK_GATE_DEFINE(0x1038U, 13U),
 315:../drivers/fsl_clock.h **** 
 316:../drivers/fsl_clock.h ****     kCLOCK_Ftf0 = CLK_GATE_DEFINE(0x103CU, 0U),
 317:../drivers/fsl_clock.h ****     kCLOCK_Dmamux0 = CLK_GATE_DEFINE(0x103CU, 1U),
 318:../drivers/fsl_clock.h ****     kCLOCK_Pit0 = CLK_GATE_DEFINE(0x103CU, 23U),
 319:../drivers/fsl_clock.h ****     kCLOCK_Tpm0 = CLK_GATE_DEFINE(0x103CU, 24U),
 320:../drivers/fsl_clock.h ****     kCLOCK_Tpm1 = CLK_GATE_DEFINE(0x103CU, 25U),
 321:../drivers/fsl_clock.h ****     kCLOCK_Tpm2 = CLK_GATE_DEFINE(0x103CU, 26U),
 322:../drivers/fsl_clock.h ****     kCLOCK_Adc0 = CLK_GATE_DEFINE(0x103CU, 27U),
 323:../drivers/fsl_clock.h ****     kCLOCK_Rtc0 = CLK_GATE_DEFINE(0x103CU, 29U),
 324:../drivers/fsl_clock.h ****     kCLOCK_Dac0 = CLK_GATE_DEFINE(0x103CU, 31U),
 325:../drivers/fsl_clock.h **** 
 326:../drivers/fsl_clock.h ****     kCLOCK_Dma0 = CLK_GATE_DEFINE(0x1040U, 8U),
 327:../drivers/fsl_clock.h **** } clock_ip_name_t;
 328:../drivers/fsl_clock.h **** 
 329:../drivers/fsl_clock.h **** /*!@brief SIM configuration structure for clock setting. */
 330:../drivers/fsl_clock.h **** typedef struct _sim_clock_config
 331:../drivers/fsl_clock.h **** {
 332:../drivers/fsl_clock.h ****     uint8_t pllFllSel;
 333:../drivers/fsl_clock.h ****     uint8_t er32kSrc; /*!< ERCLK32K source selection.   */
 334:../drivers/fsl_clock.h ****     uint32_t clkdiv1; /*!< SIM_CLKDIV1.                 */
 335:../drivers/fsl_clock.h **** } sim_clock_config_t;
 336:../drivers/fsl_clock.h **** 
 337:../drivers/fsl_clock.h **** /*! @brief OSC work mode. */
 338:../drivers/fsl_clock.h **** typedef enum _osc_mode
 339:../drivers/fsl_clock.h **** {
 340:../drivers/fsl_clock.h ****     kOSC_ModeExt = 0U, /*!< Use an external clock.   */
 341:../drivers/fsl_clock.h **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
 342:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS_MASK, /*!< Oscillator low power. */
 343:../drivers/fsl_clock.h **** #else
 344:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS0_MASK, /*!< Oscillator low power. */
 345:../drivers/fsl_clock.h **** #endif
 346:../drivers/fsl_clock.h ****     kOSC_ModeOscHighGain = 0U
 347:../drivers/fsl_clock.h **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
 348:../drivers/fsl_clock.h ****                            |
 349:../drivers/fsl_clock.h ****                            MCG_C2_EREFS_MASK
 350:../drivers/fsl_clock.h **** #else
 351:../drivers/fsl_clock.h ****                            |
 352:../drivers/fsl_clock.h ****                            MCG_C2_EREFS0_MASK
 353:../drivers/fsl_clock.h **** #endif
 354:../drivers/fsl_clock.h **** #if (defined(MCG_C2_HGO_MASK) && !(defined(MCG_C2_HGO0_MASK)))
 355:../drivers/fsl_clock.h ****                            |
 356:../drivers/fsl_clock.h ****                            MCG_C2_HGO_MASK, /*!< Oscillator high gain. */
 357:../drivers/fsl_clock.h **** #else
 358:../drivers/fsl_clock.h ****                            |
 359:../drivers/fsl_clock.h ****                            MCG_C2_HGO0_MASK, /*!< Oscillator high gain. */
 360:../drivers/fsl_clock.h **** #endif
 361:../drivers/fsl_clock.h **** } osc_mode_t;
 362:../drivers/fsl_clock.h **** 
 363:../drivers/fsl_clock.h **** /*! @brief Oscillator capacitor load setting.*/
 364:../drivers/fsl_clock.h **** enum _osc_cap_load
 365:../drivers/fsl_clock.h **** {
 366:../drivers/fsl_clock.h ****     kOSC_Cap2P = OSC_CR_SC2P_MASK,  /*!< 2  pF capacitor load */
 367:../drivers/fsl_clock.h ****     kOSC_Cap4P = OSC_CR_SC4P_MASK,  /*!< 4  pF capacitor load */
 368:../drivers/fsl_clock.h ****     kOSC_Cap8P = OSC_CR_SC8P_MASK,  /*!< 8  pF capacitor load */
 369:../drivers/fsl_clock.h ****     kOSC_Cap16P = OSC_CR_SC16P_MASK /*!< 16 pF capacitor load */
 370:../drivers/fsl_clock.h **** };
 371:../drivers/fsl_clock.h **** 
 372:../drivers/fsl_clock.h **** /*! @brief OSCERCLK enable mode. */
 373:../drivers/fsl_clock.h **** enum _oscer_enable_mode
 374:../drivers/fsl_clock.h **** {
 375:../drivers/fsl_clock.h ****     kOSC_ErClkEnable = OSC_CR_ERCLKEN_MASK,       /*!< Enable.              */
 376:../drivers/fsl_clock.h ****     kOSC_ErClkEnableInStop = OSC_CR_EREFSTEN_MASK /*!< Enable in stop mode. */
 377:../drivers/fsl_clock.h **** };
 378:../drivers/fsl_clock.h **** 
 379:../drivers/fsl_clock.h **** /*! @brief OSC configuration for OSCERCLK. */
 380:../drivers/fsl_clock.h **** typedef struct _oscer_config
 381:../drivers/fsl_clock.h **** {
 382:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< OSCERCLK enable mode. OR'ed value of @ref _oscer_enable_mode. */
 383:../drivers/fsl_clock.h **** 
 384:../drivers/fsl_clock.h **** } oscer_config_t;
 385:../drivers/fsl_clock.h **** 
 386:../drivers/fsl_clock.h **** /*!
 387:../drivers/fsl_clock.h ****  * @brief OSC Initialization Configuration Structure
 388:../drivers/fsl_clock.h ****  *
 389:../drivers/fsl_clock.h ****  * Defines the configuration data structure to initialize the OSC.
 390:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 391:../drivers/fsl_clock.h ****  * according to the board setting:
 392:../drivers/fsl_clock.h ****  * 1. freq: The external frequency.
 393:../drivers/fsl_clock.h ****  * 2. workMode: The OSC module mode.
 394:../drivers/fsl_clock.h ****  */
 395:../drivers/fsl_clock.h **** typedef struct _osc_config
 396:../drivers/fsl_clock.h **** {
 397:../drivers/fsl_clock.h ****     uint32_t freq;              /*!< External clock frequency.    */
 398:../drivers/fsl_clock.h ****     uint8_t capLoad;            /*!< Capacitor load setting.      */
 399:../drivers/fsl_clock.h ****     osc_mode_t workMode;        /*!< OSC work mode setting.       */
 400:../drivers/fsl_clock.h ****     oscer_config_t oscerConfig; /*!< Configuration for OSCERCLK.  */
 401:../drivers/fsl_clock.h **** } osc_config_t;
 402:../drivers/fsl_clock.h **** 
 403:../drivers/fsl_clock.h **** /*! @brief MCG FLL reference clock source select. */
 404:../drivers/fsl_clock.h **** typedef enum _mcg_fll_src
 405:../drivers/fsl_clock.h **** {
 406:../drivers/fsl_clock.h ****     kMCG_FllSrcExternal, /*!< External reference clock is selected          */
 407:../drivers/fsl_clock.h ****     kMCG_FllSrcInternal  /*!< The slow internal reference clock is selected */
 408:../drivers/fsl_clock.h **** } mcg_fll_src_t;
 409:../drivers/fsl_clock.h **** 
 410:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock select */
 411:../drivers/fsl_clock.h **** typedef enum _mcg_irc_mode
 412:../drivers/fsl_clock.h **** {
 413:../drivers/fsl_clock.h ****     kMCG_IrcSlow, /*!< Slow internal reference clock selected */
 414:../drivers/fsl_clock.h ****     kMCG_IrcFast  /*!< Fast internal reference clock selected */
 415:../drivers/fsl_clock.h **** } mcg_irc_mode_t;
 416:../drivers/fsl_clock.h **** 
 417:../drivers/fsl_clock.h **** /*! @brief MCG DCO Maximum Frequency with 32.768 kHz Reference */
 418:../drivers/fsl_clock.h **** typedef enum _mcg_dmx32
 419:../drivers/fsl_clock.h **** {
 420:../drivers/fsl_clock.h ****     kMCG_Dmx32Default, /*!< DCO has a default range of 25% */
 421:../drivers/fsl_clock.h ****     kMCG_Dmx32Fine     /*!< DCO is fine-tuned for maximum frequency with 32.768 kHz reference */
 422:../drivers/fsl_clock.h **** } mcg_dmx32_t;
 423:../drivers/fsl_clock.h **** 
 424:../drivers/fsl_clock.h **** /*! @brief MCG DCO range select */
 425:../drivers/fsl_clock.h **** typedef enum _mcg_drs
 426:../drivers/fsl_clock.h **** {
 427:../drivers/fsl_clock.h ****     kMCG_DrsLow,     /*!< Low frequency range       */
 428:../drivers/fsl_clock.h ****     kMCG_DrsMid,     /*!< Mid frequency range       */
 429:../drivers/fsl_clock.h ****     kMCG_DrsMidHigh, /*!< Mid-High frequency range  */
 430:../drivers/fsl_clock.h ****     kMCG_DrsHigh     /*!< High frequency range      */
 431:../drivers/fsl_clock.h **** } mcg_drs_t;
 432:../drivers/fsl_clock.h **** 
 433:../drivers/fsl_clock.h **** /*! @brief MCG PLL reference clock select */
 434:../drivers/fsl_clock.h **** typedef enum _mcg_pll_ref_src
 435:../drivers/fsl_clock.h **** {
 436:../drivers/fsl_clock.h ****     kMCG_PllRefOsc0, /*!< Selects OSC0 as PLL reference clock                 */
 437:../drivers/fsl_clock.h ****     kMCG_PllRefOsc1  /*!< Selects OSC1 as PLL reference clock                 */
 438:../drivers/fsl_clock.h **** } mcg_pll_ref_src_t;
 439:../drivers/fsl_clock.h **** 
 440:../drivers/fsl_clock.h **** /*! @brief MCGOUT clock source. */
 441:../drivers/fsl_clock.h **** typedef enum _mcg_clkout_src
 442:../drivers/fsl_clock.h **** {
 443:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcOut,      /*!< Output of the FLL is selected (reset default)  */
 444:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcInternal, /*!< Internal reference clock is selected           */
 445:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcExternal, /*!< External reference clock is selected           */
 446:../drivers/fsl_clock.h **** } mcg_clkout_src_t;
 447:../drivers/fsl_clock.h **** 
 448:../drivers/fsl_clock.h **** /*! @brief MCG Automatic Trim Machine Select */
 449:../drivers/fsl_clock.h **** typedef enum _mcg_atm_select
 450:../drivers/fsl_clock.h **** {
 451:../drivers/fsl_clock.h ****     kMCG_AtmSel32k, /*!< 32 kHz Internal Reference Clock selected  */
 452:../drivers/fsl_clock.h ****     kMCG_AtmSel4m   /*!< 4 MHz Internal Reference Clock selected   */
 453:../drivers/fsl_clock.h **** } mcg_atm_select_t;
 454:../drivers/fsl_clock.h **** 
 455:../drivers/fsl_clock.h **** /*! @brief MCG OSC Clock Select */
 456:../drivers/fsl_clock.h **** typedef enum _mcg_oscsel
 457:../drivers/fsl_clock.h **** {
 458:../drivers/fsl_clock.h ****     kMCG_OscselOsc, /*!< Selects System Oscillator (OSCCLK) */
 459:../drivers/fsl_clock.h ****     kMCG_OscselRtc, /*!< Selects 32 kHz RTC Oscillator      */
 460:../drivers/fsl_clock.h **** } mcg_oscsel_t;
 461:../drivers/fsl_clock.h **** 
 462:../drivers/fsl_clock.h **** /*! @brief MCG PLLCS select */
 463:../drivers/fsl_clock.h **** typedef enum _mcg_pll_clk_select
 464:../drivers/fsl_clock.h **** {
 465:../drivers/fsl_clock.h ****     kMCG_PllClkSelPll0, /*!< PLL0 output clock is selected  */
 466:../drivers/fsl_clock.h ****     kMCG_PllClkSelPll1  /* PLL1 output clock is selected    */
 467:../drivers/fsl_clock.h **** } mcg_pll_clk_select_t;
 468:../drivers/fsl_clock.h **** 
 469:../drivers/fsl_clock.h **** /*! @brief MCG clock monitor mode. */
 470:../drivers/fsl_clock.h **** typedef enum _mcg_monitor_mode
 471:../drivers/fsl_clock.h **** {
 472:../drivers/fsl_clock.h ****     kMCG_MonitorNone, /*!< Clock monitor is disabled.         */
 473:../drivers/fsl_clock.h ****     kMCG_MonitorInt,  /*!< Trigger interrupt when clock lost. */
 474:../drivers/fsl_clock.h ****     kMCG_MonitorReset /*!< System reset when clock lost.      */
 475:../drivers/fsl_clock.h **** } mcg_monitor_mode_t;
 476:../drivers/fsl_clock.h **** 
 477:../drivers/fsl_clock.h **** /*! @brief MCG status. */
 478:../drivers/fsl_clock.h **** enum _mcg_status
 479:../drivers/fsl_clock.h **** {
 480:../drivers/fsl_clock.h ****     kStatus_MCG_ModeUnreachable = MAKE_STATUS(kStatusGroup_MCG, 0),       /*!< Can't switch to targ
 481:../drivers/fsl_clock.h ****     kStatus_MCG_ModeInvalid = MAKE_STATUS(kStatusGroup_MCG, 1),           /*!< Current mode invalid
 482:../drivers/fsl_clock.h ****                                                                                function. */
 483:../drivers/fsl_clock.h ****     kStatus_MCG_AtmBusClockInvalid = MAKE_STATUS(kStatusGroup_MCG, 2),    /*!< Invalid bus clock fo
 484:../drivers/fsl_clock.h ****     kStatus_MCG_AtmDesiredFreqInvalid = MAKE_STATUS(kStatusGroup_MCG, 3), /*!< Invalid desired freq
 485:../drivers/fsl_clock.h ****     kStatus_MCG_AtmIrcUsed = MAKE_STATUS(kStatusGroup_MCG, 4),            /*!< IRC is used when usi
 486:../drivers/fsl_clock.h ****     kStatus_MCG_AtmHardwareFail = MAKE_STATUS(kStatusGroup_MCG, 5),       /*!< Hardware fail occurs
 487:../drivers/fsl_clock.h ****     kStatus_MCG_SourceUsed = MAKE_STATUS(kStatusGroup_MCG, 6)             /*!< Can't change the clo
 488:../drivers/fsl_clock.h ****                                                                                it is in use. */
 489:../drivers/fsl_clock.h **** };
 490:../drivers/fsl_clock.h **** 
 491:../drivers/fsl_clock.h **** /*! @brief MCG status flags. */
 492:../drivers/fsl_clock.h **** enum _mcg_status_flags_t
 493:../drivers/fsl_clock.h **** {
 494:../drivers/fsl_clock.h ****     kMCG_Osc0LostFlag = (1U << 0U), /*!< OSC0 lost.         */
 495:../drivers/fsl_clock.h ****     kMCG_Osc0InitFlag = (1U << 1U), /*!< OSC0 crystal initialized. */
 496:../drivers/fsl_clock.h ****     kMCG_Pll0LostFlag = (1U << 5U), /*!< PLL0 lost.         */
 497:../drivers/fsl_clock.h ****     kMCG_Pll0LockFlag = (1U << 6U), /*!< PLL0 locked.       */
 498:../drivers/fsl_clock.h **** };
 499:../drivers/fsl_clock.h **** 
 500:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock (MCGIRCLK) enable mode definition. */
 501:../drivers/fsl_clock.h **** enum _mcg_irclk_enable_mode
 502:../drivers/fsl_clock.h **** {
 503:../drivers/fsl_clock.h ****     kMCG_IrclkEnable = MCG_C1_IRCLKEN_MASK,       /*!< MCGIRCLK enable.              */
 504:../drivers/fsl_clock.h ****     kMCG_IrclkEnableInStop = MCG_C1_IREFSTEN_MASK /*!< MCGIRCLK enable in stop mode. */
 505:../drivers/fsl_clock.h **** };
 506:../drivers/fsl_clock.h **** 
 507:../drivers/fsl_clock.h **** /*! @brief MCG PLL clock enable mode definition. */
 508:../drivers/fsl_clock.h **** enum _mcg_pll_enable_mode
 509:../drivers/fsl_clock.h **** {
 510:../drivers/fsl_clock.h ****     kMCG_PllEnableIndependent = MCG_C5_PLLCLKEN0_MASK, /*!< MCGPLLCLK enable independent of the
 511:../drivers/fsl_clock.h ****                                                            MCG clock mode. Generally, the PLL
 512:../drivers/fsl_clock.h ****                                                            is disabled in FLL modes
 513:../drivers/fsl_clock.h ****                                                            (FEI/FBI/FEE/FBE). Setting the PLL clock
 514:../drivers/fsl_clock.h ****                                                            enable independent, enables the
 515:../drivers/fsl_clock.h ****                                                            PLL in the FLL modes.          */
 516:../drivers/fsl_clock.h ****     kMCG_PllEnableInStop = MCG_C5_PLLSTEN0_MASK        /*!< MCGPLLCLK enable in STOP mode. */
 517:../drivers/fsl_clock.h **** };
 518:../drivers/fsl_clock.h **** 
 519:../drivers/fsl_clock.h **** /*! @brief MCG mode definitions */
 520:../drivers/fsl_clock.h **** typedef enum _mcg_mode
 521:../drivers/fsl_clock.h **** {
 522:../drivers/fsl_clock.h ****     kMCG_ModeFEI = 0U, /*!< FEI   - FLL Engaged Internal         */
 523:../drivers/fsl_clock.h ****     kMCG_ModeFBI,      /*!< FBI   - FLL Bypassed Internal        */
 524:../drivers/fsl_clock.h ****     kMCG_ModeBLPI,     /*!< BLPI  - Bypassed Low Power Internal  */
 525:../drivers/fsl_clock.h ****     kMCG_ModeFEE,      /*!< FEE   - FLL Engaged External         */
 526:../drivers/fsl_clock.h ****     kMCG_ModeFBE,      /*!< FBE   - FLL Bypassed External        */
 527:../drivers/fsl_clock.h ****     kMCG_ModeBLPE,     /*!< BLPE  - Bypassed Low Power External  */
 528:../drivers/fsl_clock.h ****     kMCG_ModePBE,      /*!< PBE   - PLL Bypassed External        */
 529:../drivers/fsl_clock.h ****     kMCG_ModePEE,      /*!< PEE   - PLL Engaged External         */
 530:../drivers/fsl_clock.h ****     kMCG_ModeError     /*!< Unknown mode                         */
 531:../drivers/fsl_clock.h **** } mcg_mode_t;
 532:../drivers/fsl_clock.h **** 
 533:../drivers/fsl_clock.h **** /*! @brief MCG PLL configuration. */
 534:../drivers/fsl_clock.h **** typedef struct _mcg_pll_config
 535:../drivers/fsl_clock.h **** {
 536:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< Enable mode. OR'ed value of @ref _mcg_pll_enable_mode. */
 537:../drivers/fsl_clock.h ****     uint8_t prdiv;      /*!< Reference divider PRDIV.    */
 538:../drivers/fsl_clock.h ****     uint8_t vdiv;       /*!< VCO divider VDIV.           */
 539:../drivers/fsl_clock.h **** } mcg_pll_config_t;
 540:../drivers/fsl_clock.h **** 
 541:../drivers/fsl_clock.h **** /*! @brief MCG mode change configuration structure
 542:../drivers/fsl_clock.h ****  *
 543:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 544:../drivers/fsl_clock.h ****  * according to the board setting:
 545:../drivers/fsl_clock.h ****  * 1. frdiv: If the FLL uses the external reference clock, set this
 546:../drivers/fsl_clock.h ****  *    value to ensure that the external reference clock divided by frdiv is
 547:../drivers/fsl_clock.h ****  *    in the 31.25 kHz to 39.0625 kHz range.
 548:../drivers/fsl_clock.h ****  * 2. The PLL reference clock divider PRDIV: PLL reference clock frequency after
 549:../drivers/fsl_clock.h ****  *    PRDIV should be in the FSL_FEATURE_MCG_PLL_REF_MIN to
 550:../drivers/fsl_clock.h ****  *    FSL_FEATURE_MCG_PLL_REF_MAX range.
 551:../drivers/fsl_clock.h ****  */
 552:../drivers/fsl_clock.h **** typedef struct _mcg_config
 553:../drivers/fsl_clock.h **** {
 554:../drivers/fsl_clock.h ****     mcg_mode_t mcgMode; /*!< MCG mode.                   */
 555:../drivers/fsl_clock.h **** 
 556:../drivers/fsl_clock.h ****     /* ----------------------- MCGIRCCLK settings ------------------------ */
 557:../drivers/fsl_clock.h ****     uint8_t irclkEnableMode; /*!< MCGIRCLK enable mode.       */
 558:../drivers/fsl_clock.h ****     mcg_irc_mode_t ircs;     /*!< Source, MCG_C2[IRCS].       */
 559:../drivers/fsl_clock.h ****     uint8_t fcrdiv;          /*!< Divider, MCG_SC[FCRDIV].    */
 560:../drivers/fsl_clock.h **** 
 561:../drivers/fsl_clock.h ****     /* ------------------------ MCG FLL settings ------------------------- */
 562:../drivers/fsl_clock.h ****     uint8_t frdiv;     /*!< Divider MCG_C1[FRDIV].      */
 563:../drivers/fsl_clock.h ****     mcg_drs_t drs;     /*!< DCO range MCG_C4[DRST_DRS]. */
 564:../drivers/fsl_clock.h ****     mcg_dmx32_t dmx32; /*!< MCG_C4[DMX32].              */
 565:../drivers/fsl_clock.h **** 
 566:../drivers/fsl_clock.h ****     /* ------------------------ MCG PLL settings ------------------------- */
 567:../drivers/fsl_clock.h ****     mcg_pll_config_t pll0Config; /*!< MCGPLL0CLK configuration.   */
 568:../drivers/fsl_clock.h **** 
 569:../drivers/fsl_clock.h **** } mcg_config_t;
 570:../drivers/fsl_clock.h **** 
 571:../drivers/fsl_clock.h **** /*******************************************************************************
 572:../drivers/fsl_clock.h ****  * API
 573:../drivers/fsl_clock.h ****  ******************************************************************************/
 574:../drivers/fsl_clock.h **** 
 575:../drivers/fsl_clock.h **** #if defined(__cplusplus)
 576:../drivers/fsl_clock.h **** extern "C" {
 577:../drivers/fsl_clock.h **** #endif /* __cplusplus */
 578:../drivers/fsl_clock.h **** 
 579:../drivers/fsl_clock.h **** /*!
 580:../drivers/fsl_clock.h ****  * @brief Enable the clock for specific IP.
 581:../drivers/fsl_clock.h ****  *
 582:../drivers/fsl_clock.h ****  * @param name  Which clock to enable, see \ref clock_ip_name_t.
 583:../drivers/fsl_clock.h ****  */
 584:../drivers/fsl_clock.h **** static inline void CLOCK_EnableClock(clock_ip_name_t name)
 585:../drivers/fsl_clock.h **** {
  78              		.loc 2 585 1
  79              		.cfi_startproc
  80              		@ args = 0, pretend = 0, frame = 16
  81              		@ frame_needed = 1, uses_anonymous_args = 0
  82 0000 80B5     		push	{r7, lr}
  83              		.cfi_def_cfa_offset 8
  84              		.cfi_offset 7, -8
  85              		.cfi_offset 14, -4
  86 0002 84B0     		sub	sp, sp, #16
  87              		.cfi_def_cfa_offset 24
  88 0004 00AF     		add	r7, sp, #0
  89              		.cfi_def_cfa_register 7
  90 0006 7860     		str	r0, [r7, #4]
 586:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
  91              		.loc 2 586 35
  92 0008 7B68     		ldr	r3, [r7, #4]
  93 000a 1B0C     		lsrs	r3, r3, #16
  94              		.loc 2 586 14
  95 000c 084A     		ldr	r2, .L5
  96 000e 9446     		mov	ip, r2
  97 0010 6344     		add	r3, r3, ip
  98 0012 FB60     		str	r3, [r7, #12]
 587:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
  99              		.loc 2 587 37
 100 0014 FB68     		ldr	r3, [r7, #12]
 101 0016 1968     		ldr	r1, [r3]
 102              		.loc 2 587 47
 103 0018 7B68     		ldr	r3, [r7, #4]
 104 001a 1B04     		lsls	r3, r3, #16
 105 001c 1B0C     		lsrs	r3, r3, #16
 106              		.loc 2 587 44
 107 001e 0122     		movs	r2, #1
 108 0020 9A40     		lsls	r2, r2, r3
 109              		.loc 2 587 37
 110 0022 FB68     		ldr	r3, [r7, #12]
 111 0024 0A43     		orrs	r2, r1
 112 0026 1A60     		str	r2, [r3]
 588:../drivers/fsl_clock.h **** }
 113              		.loc 2 588 1
 114 0028 C046     		nop
 115 002a BD46     		mov	sp, r7
 116 002c 04B0     		add	sp, sp, #16
 117              		@ sp needed
 118 002e 80BD     		pop	{r7, pc}
 119              	.L6:
 120              		.align	2
 121              	.L5:
 122 0030 00700440 		.word	1074032640
 123              		.cfi_endproc
 124              	.LFE34:
 126              		.section	.text.CLOCK_DisableClock,"ax",%progbits
 127              		.align	1
 128              		.syntax unified
 129              		.code	16
 130              		.thumb_func
 131              		.fpu softvfp
 133              	CLOCK_DisableClock:
 134              	.LFB35:
 589:../drivers/fsl_clock.h **** 
 590:../drivers/fsl_clock.h **** /*!
 591:../drivers/fsl_clock.h ****  * @brief Disable the clock for specific IP.
 592:../drivers/fsl_clock.h ****  *
 593:../drivers/fsl_clock.h ****  * @param name  Which clock to disable, see \ref clock_ip_name_t.
 594:../drivers/fsl_clock.h ****  */
 595:../drivers/fsl_clock.h **** static inline void CLOCK_DisableClock(clock_ip_name_t name)
 596:../drivers/fsl_clock.h **** {
 135              		.loc 2 596 1
 136              		.cfi_startproc
 137              		@ args = 0, pretend = 0, frame = 16
 138              		@ frame_needed = 1, uses_anonymous_args = 0
 139 0000 80B5     		push	{r7, lr}
 140              		.cfi_def_cfa_offset 8
 141              		.cfi_offset 7, -8
 142              		.cfi_offset 14, -4
 143 0002 84B0     		sub	sp, sp, #16
 144              		.cfi_def_cfa_offset 24
 145 0004 00AF     		add	r7, sp, #0
 146              		.cfi_def_cfa_register 7
 147 0006 7860     		str	r0, [r7, #4]
 597:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 148              		.loc 2 597 35
 149 0008 7B68     		ldr	r3, [r7, #4]
 150 000a 1B0C     		lsrs	r3, r3, #16
 151              		.loc 2 597 14
 152 000c 094A     		ldr	r2, .L8
 153 000e 9446     		mov	ip, r2
 154 0010 6344     		add	r3, r3, ip
 155 0012 FB60     		str	r3, [r7, #12]
 598:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) &= ~(1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 156              		.loc 2 598 37
 157 0014 FB68     		ldr	r3, [r7, #12]
 158 0016 1A68     		ldr	r2, [r3]
 159              		.loc 2 598 48
 160 0018 7B68     		ldr	r3, [r7, #4]
 161 001a 1B04     		lsls	r3, r3, #16
 162 001c 1B0C     		lsrs	r3, r3, #16
 163              		.loc 2 598 45
 164 001e 0121     		movs	r1, #1
 165 0020 9940     		lsls	r1, r1, r3
 166 0022 0B00     		movs	r3, r1
 167              		.loc 2 598 40
 168 0024 D943     		mvns	r1, r3
 169              		.loc 2 598 37
 170 0026 FB68     		ldr	r3, [r7, #12]
 171 0028 0A40     		ands	r2, r1
 172 002a 1A60     		str	r2, [r3]
 599:../drivers/fsl_clock.h **** }
 173              		.loc 2 599 1
 174 002c C046     		nop
 175 002e BD46     		mov	sp, r7
 176 0030 04B0     		add	sp, sp, #16
 177              		@ sp needed
 178 0032 80BD     		pop	{r7, pc}
 179              	.L9:
 180              		.align	2
 181              	.L8:
 182 0034 00700440 		.word	1074032640
 183              		.cfi_endproc
 184              	.LFE35:
 186              		.section	.text.EnableIRQ,"ax",%progbits
 187              		.align	1
 188              		.syntax unified
 189              		.code	16
 190              		.thumb_func
 191              		.fpu softvfp
 193              	EnableIRQ:
 194              	.LFB52:
 195              		.file 3 "../drivers/fsl_common.h"
   1:../drivers/fsl_common.h **** /*
   2:../drivers/fsl_common.h ****  * Copyright (c) 2015-2016, Freescale Semiconductor, Inc.
   3:../drivers/fsl_common.h ****  * Copyright 2016-2017 NXP
   4:../drivers/fsl_common.h ****  *
   5:../drivers/fsl_common.h ****  * Redistribution and use in source and binary forms, with or without modification,
   6:../drivers/fsl_common.h ****  * are permitted provided that the following conditions are met:
   7:../drivers/fsl_common.h ****  *
   8:../drivers/fsl_common.h ****  * o Redistributions of source code must retain the above copyright notice, this list
   9:../drivers/fsl_common.h ****  *   of conditions and the following disclaimer.
  10:../drivers/fsl_common.h ****  *
  11:../drivers/fsl_common.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  12:../drivers/fsl_common.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  13:../drivers/fsl_common.h ****  *   other materials provided with the distribution.
  14:../drivers/fsl_common.h ****  *
  15:../drivers/fsl_common.h ****  * o Neither the name of the copyright holder nor the names of its
  16:../drivers/fsl_common.h ****  *   contributors may be used to endorse or promote products derived from this
  17:../drivers/fsl_common.h ****  *   software without specific prior written permission.
  18:../drivers/fsl_common.h ****  *
  19:../drivers/fsl_common.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  20:../drivers/fsl_common.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  21:../drivers/fsl_common.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  22:../drivers/fsl_common.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  23:../drivers/fsl_common.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  24:../drivers/fsl_common.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  25:../drivers/fsl_common.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  26:../drivers/fsl_common.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27:../drivers/fsl_common.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  28:../drivers/fsl_common.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29:../drivers/fsl_common.h ****  */
  30:../drivers/fsl_common.h **** 
  31:../drivers/fsl_common.h **** #ifndef _FSL_COMMON_H_
  32:../drivers/fsl_common.h **** #define _FSL_COMMON_H_
  33:../drivers/fsl_common.h **** 
  34:../drivers/fsl_common.h **** #include <assert.h>
  35:../drivers/fsl_common.h **** #include <stdbool.h>
  36:../drivers/fsl_common.h **** #include <stdint.h>
  37:../drivers/fsl_common.h **** #include <string.h>
  38:../drivers/fsl_common.h **** 
  39:../drivers/fsl_common.h **** #if defined(__ICCARM__)
  40:../drivers/fsl_common.h **** #include <stddef.h>
  41:../drivers/fsl_common.h **** #endif
  42:../drivers/fsl_common.h **** 
  43:../drivers/fsl_common.h **** #include "fsl_device_registers.h"
  44:../drivers/fsl_common.h **** 
  45:../drivers/fsl_common.h **** /*!
  46:../drivers/fsl_common.h ****  * @addtogroup ksdk_common
  47:../drivers/fsl_common.h ****  * @{
  48:../drivers/fsl_common.h ****  */
  49:../drivers/fsl_common.h **** 
  50:../drivers/fsl_common.h **** /*******************************************************************************
  51:../drivers/fsl_common.h ****  * Definitions
  52:../drivers/fsl_common.h ****  ******************************************************************************/
  53:../drivers/fsl_common.h **** 
  54:../drivers/fsl_common.h **** /*! @brief Construct a status code value from a group and code number. */
  55:../drivers/fsl_common.h **** #define MAKE_STATUS(group, code) ((((group)*100) + (code)))
  56:../drivers/fsl_common.h **** 
  57:../drivers/fsl_common.h **** /*! @brief Construct the version number for drivers. */
  58:../drivers/fsl_common.h **** #define MAKE_VERSION(major, minor, bugfix) (((major) << 16) | ((minor) << 8) | (bugfix))
  59:../drivers/fsl_common.h **** 
  60:../drivers/fsl_common.h **** /* Debug console type definition. */
  61:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_NONE 0U     /*!< No debug console.             */
  62:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_UART 1U     /*!< Debug console base on UART.   */
  63:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_LPUART 2U   /*!< Debug console base on LPUART. */
  64:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_LPSCI 3U    /*!< Debug console base on LPSCI.  */
  65:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_USBCDC 4U   /*!< Debug console base on USBCDC. */
  66:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_FLEXCOMM 5U /*!< Debug console base on USBCDC. */
  67:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_IUART 6U    /*!< Debug console base on i.MX UART. */
  68:../drivers/fsl_common.h **** 
  69:../drivers/fsl_common.h **** /*! @brief Status group numbers. */
  70:../drivers/fsl_common.h **** enum _status_groups
  71:../drivers/fsl_common.h **** {
  72:../drivers/fsl_common.h ****     kStatusGroup_Generic = 0,                 /*!< Group number for generic status codes. */
  73:../drivers/fsl_common.h ****     kStatusGroup_FLASH = 1,                   /*!< Group number for FLASH status codes. */
  74:../drivers/fsl_common.h ****     kStatusGroup_LPSPI = 4,                   /*!< Group number for LPSPI status codes. */
  75:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_SPI = 5,              /*!< Group number for FLEXIO SPI status codes. */
  76:../drivers/fsl_common.h ****     kStatusGroup_DSPI = 6,                    /*!< Group number for DSPI status codes. */
  77:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_UART = 7,             /*!< Group number for FLEXIO UART status codes. */
  78:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_I2C = 8,              /*!< Group number for FLEXIO I2C status codes. */
  79:../drivers/fsl_common.h ****     kStatusGroup_LPI2C = 9,                   /*!< Group number for LPI2C status codes. */
  80:../drivers/fsl_common.h ****     kStatusGroup_UART = 10,                   /*!< Group number for UART status codes. */
  81:../drivers/fsl_common.h ****     kStatusGroup_I2C = 11,                    /*!< Group number for UART status codes. */
  82:../drivers/fsl_common.h ****     kStatusGroup_LPSCI = 12,                  /*!< Group number for LPSCI status codes. */
  83:../drivers/fsl_common.h ****     kStatusGroup_LPUART = 13,                 /*!< Group number for LPUART status codes. */
  84:../drivers/fsl_common.h ****     kStatusGroup_SPI = 14,                    /*!< Group number for SPI status code.*/
  85:../drivers/fsl_common.h ****     kStatusGroup_XRDC = 15,                   /*!< Group number for XRDC status code.*/
  86:../drivers/fsl_common.h ****     kStatusGroup_SEMA42 = 16,                 /*!< Group number for SEMA42 status code.*/
  87:../drivers/fsl_common.h ****     kStatusGroup_SDHC = 17,                   /*!< Group number for SDHC status code */
  88:../drivers/fsl_common.h ****     kStatusGroup_SDMMC = 18,                  /*!< Group number for SDMMC status code */
  89:../drivers/fsl_common.h ****     kStatusGroup_SAI = 19,                    /*!< Group number for SAI status code */
  90:../drivers/fsl_common.h ****     kStatusGroup_MCG = 20,                    /*!< Group number for MCG status codes. */
  91:../drivers/fsl_common.h ****     kStatusGroup_SCG = 21,                    /*!< Group number for SCG status codes. */
  92:../drivers/fsl_common.h ****     kStatusGroup_SDSPI = 22,                  /*!< Group number for SDSPI status codes. */
  93:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_I2S = 23,             /*!< Group number for FLEXIO I2S status codes */
  94:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_MCULCD = 24,          /*!< Group number for FLEXIO LCD status codes */
  95:../drivers/fsl_common.h ****     kStatusGroup_FLASHIAP = 25,               /*!< Group number for FLASHIAP status codes */
  96:../drivers/fsl_common.h ****     kStatusGroup_FLEXCOMM_I2C = 26,           /*!< Group number for FLEXCOMM I2C status codes */
  97:../drivers/fsl_common.h ****     kStatusGroup_I2S = 27,                    /*!< Group number for I2S status codes */
  98:../drivers/fsl_common.h ****     kStatusGroup_IUART = 28,                  /*!< Group number for IUART status codes */
  99:../drivers/fsl_common.h ****     kStatusGroup_SDRAMC = 35,                 /*!< Group number for SDRAMC status codes. */
 100:../drivers/fsl_common.h ****     kStatusGroup_POWER = 39,                  /*!< Group number for POWER status codes. */
 101:../drivers/fsl_common.h ****     kStatusGroup_ENET = 40,                   /*!< Group number for ENET status codes. */
 102:../drivers/fsl_common.h ****     kStatusGroup_PHY = 41,                    /*!< Group number for PHY status codes. */
 103:../drivers/fsl_common.h ****     kStatusGroup_TRGMUX = 42,                 /*!< Group number for TRGMUX status codes. */
 104:../drivers/fsl_common.h ****     kStatusGroup_SMARTCARD = 43,              /*!< Group number for SMARTCARD status codes. */
 105:../drivers/fsl_common.h ****     kStatusGroup_LMEM = 44,                   /*!< Group number for LMEM status codes. */
 106:../drivers/fsl_common.h ****     kStatusGroup_QSPI = 45,                   /*!< Group number for QSPI status codes. */
 107:../drivers/fsl_common.h ****     kStatusGroup_DMA = 50,                    /*!< Group number for DMA status codes. */
 108:../drivers/fsl_common.h ****     kStatusGroup_EDMA = 51,                   /*!< Group number for EDMA status codes. */
 109:../drivers/fsl_common.h ****     kStatusGroup_DMAMGR = 52,                 /*!< Group number for DMAMGR status codes. */
 110:../drivers/fsl_common.h ****     kStatusGroup_FLEXCAN = 53,                /*!< Group number for FlexCAN status codes. */
 111:../drivers/fsl_common.h ****     kStatusGroup_LTC = 54,                    /*!< Group number for LTC status codes. */
 112:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_CAMERA = 55,          /*!< Group number for FLEXIO CAMERA status codes. */
 113:../drivers/fsl_common.h ****     kStatusGroup_LPC_SPI = 56,                /*!< Group number for LPC_SPI status codes. */
 114:../drivers/fsl_common.h ****     kStatusGroup_LPC_USART = 57,              /*!< Group number for LPC_USART status codes. */
 115:../drivers/fsl_common.h ****     kStatusGroup_DMIC = 58,                   /*!< Group number for DMIC status codes. */
 116:../drivers/fsl_common.h ****     kStatusGroup_SDIF = 59,                   /*!< Group number for SDIF status codes.*/
 117:../drivers/fsl_common.h ****     kStatusGroup_SPIFI = 60,                  /*!< Group number for SPIFI status codes. */
 118:../drivers/fsl_common.h ****     kStatusGroup_OTP = 61,                    /*!< Group number for OTP status codes. */
 119:../drivers/fsl_common.h ****     kStatusGroup_MCAN = 62,                   /*!< Group number for MCAN status codes. */
 120:../drivers/fsl_common.h ****     kStatusGroup_CAAM = 63,                   /*!< Group number for CAAM status codes. */
 121:../drivers/fsl_common.h ****     kStatusGroup_ECSPI = 64,                  /*!< Group number for ECSPI status codes. */
 122:../drivers/fsl_common.h ****     kStatusGroup_USDHC = 65,                  /*!< Group number for USDHC status codes.*/
 123:../drivers/fsl_common.h ****     kStatusGroup_ESAI = 69,                   /*!< Group number for ESAI status codes. */
 124:../drivers/fsl_common.h ****     kStatusGroup_FLEXSPI = 70,                /*!< Group number for FLEXSPI status codes. */
 125:../drivers/fsl_common.h ****     kStatusGroup_NOTIFIER = 98,               /*!< Group number for NOTIFIER status codes. */
 126:../drivers/fsl_common.h ****     kStatusGroup_DebugConsole = 99,           /*!< Group number for debug console status codes. */
 127:../drivers/fsl_common.h ****     kStatusGroup_ApplicationRangeStart = 100, /*!< Starting number for application groups. */
 128:../drivers/fsl_common.h **** };
 129:../drivers/fsl_common.h **** 
 130:../drivers/fsl_common.h **** /*! @brief Generic status return codes. */
 131:../drivers/fsl_common.h **** enum _generic_status
 132:../drivers/fsl_common.h **** {
 133:../drivers/fsl_common.h ****     kStatus_Success = MAKE_STATUS(kStatusGroup_Generic, 0),
 134:../drivers/fsl_common.h ****     kStatus_Fail = MAKE_STATUS(kStatusGroup_Generic, 1),
 135:../drivers/fsl_common.h ****     kStatus_ReadOnly = MAKE_STATUS(kStatusGroup_Generic, 2),
 136:../drivers/fsl_common.h ****     kStatus_OutOfRange = MAKE_STATUS(kStatusGroup_Generic, 3),
 137:../drivers/fsl_common.h ****     kStatus_InvalidArgument = MAKE_STATUS(kStatusGroup_Generic, 4),
 138:../drivers/fsl_common.h ****     kStatus_Timeout = MAKE_STATUS(kStatusGroup_Generic, 5),
 139:../drivers/fsl_common.h ****     kStatus_NoTransferInProgress = MAKE_STATUS(kStatusGroup_Generic, 6),
 140:../drivers/fsl_common.h **** };
 141:../drivers/fsl_common.h **** 
 142:../drivers/fsl_common.h **** /*! @brief Type used for all status and error return values. */
 143:../drivers/fsl_common.h **** typedef int32_t status_t;
 144:../drivers/fsl_common.h **** 
 145:../drivers/fsl_common.h **** /*
 146:../drivers/fsl_common.h ****  * The fsl_clock.h is included here because it needs MAKE_VERSION/MAKE_STATUS/status_t
 147:../drivers/fsl_common.h ****  * defined in previous of this file.
 148:../drivers/fsl_common.h ****  */
 149:../drivers/fsl_common.h **** #include "fsl_clock.h"
 150:../drivers/fsl_common.h **** 
 151:../drivers/fsl_common.h **** /*
 152:../drivers/fsl_common.h ****  * Chip level peripheral reset API, for MCUs that implement peripheral reset control external to a 
 153:../drivers/fsl_common.h ****  */
 154:../drivers/fsl_common.h **** #if ((defined(FSL_FEATURE_SOC_SYSCON_COUNT) && (FSL_FEATURE_SOC_SYSCON_COUNT > 0)) || \
 155:../drivers/fsl_common.h ****      (defined(FSL_FEATURE_SOC_ASYNC_SYSCON_COUNT) && (FSL_FEATURE_SOC_ASYNC_SYSCON_COUNT > 0)))
 156:../drivers/fsl_common.h **** #include "fsl_reset.h"
 157:../drivers/fsl_common.h **** #endif
 158:../drivers/fsl_common.h **** 
 159:../drivers/fsl_common.h **** /*! @name Min/max macros */
 160:../drivers/fsl_common.h **** /* @{ */
 161:../drivers/fsl_common.h **** #if !defined(MIN)
 162:../drivers/fsl_common.h **** #define MIN(a, b) ((a) < (b) ? (a) : (b))
 163:../drivers/fsl_common.h **** #endif
 164:../drivers/fsl_common.h **** 
 165:../drivers/fsl_common.h **** #if !defined(MAX)
 166:../drivers/fsl_common.h **** #define MAX(a, b) ((a) > (b) ? (a) : (b))
 167:../drivers/fsl_common.h **** #endif
 168:../drivers/fsl_common.h **** /* @} */
 169:../drivers/fsl_common.h **** 
 170:../drivers/fsl_common.h **** /*! @brief Computes the number of elements in an array. */
 171:../drivers/fsl_common.h **** #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
 172:../drivers/fsl_common.h **** 
 173:../drivers/fsl_common.h **** /*! @name UINT16_MAX/UINT32_MAX value */
 174:../drivers/fsl_common.h **** /* @{ */
 175:../drivers/fsl_common.h **** #if !defined(UINT16_MAX)
 176:../drivers/fsl_common.h **** #define UINT16_MAX ((uint16_t)-1)
 177:../drivers/fsl_common.h **** #endif
 178:../drivers/fsl_common.h **** 
 179:../drivers/fsl_common.h **** #if !defined(UINT32_MAX)
 180:../drivers/fsl_common.h **** #define UINT32_MAX ((uint32_t)-1)
 181:../drivers/fsl_common.h **** #endif
 182:../drivers/fsl_common.h **** /* @} */
 183:../drivers/fsl_common.h **** 
 184:../drivers/fsl_common.h **** /*! @name Timer utilities */
 185:../drivers/fsl_common.h **** /* @{ */
 186:../drivers/fsl_common.h **** /*! Macro to convert a microsecond period to raw count value */
 187:../drivers/fsl_common.h **** #define USEC_TO_COUNT(us, clockFreqInHz) (uint64_t)((uint64_t)us * clockFreqInHz / 1000000U)
 188:../drivers/fsl_common.h **** /*! Macro to convert a raw count value to microsecond */
 189:../drivers/fsl_common.h **** #define COUNT_TO_USEC(count, clockFreqInHz) (uint64_t)((uint64_t)count * 1000000U / clockFreqInHz)
 190:../drivers/fsl_common.h **** 
 191:../drivers/fsl_common.h **** /*! Macro to convert a millisecond period to raw count value */
 192:../drivers/fsl_common.h **** #define MSEC_TO_COUNT(ms, clockFreqInHz) (uint64_t)((uint64_t)ms * clockFreqInHz / 1000U)
 193:../drivers/fsl_common.h **** /*! Macro to convert a raw count value to millisecond */
 194:../drivers/fsl_common.h **** #define COUNT_TO_MSEC(count, clockFreqInHz) (uint64_t)((uint64_t)count * 1000U / clockFreqInHz)
 195:../drivers/fsl_common.h **** /* @} */
 196:../drivers/fsl_common.h **** 
 197:../drivers/fsl_common.h **** /*******************************************************************************
 198:../drivers/fsl_common.h ****  * API
 199:../drivers/fsl_common.h ****  ******************************************************************************/
 200:../drivers/fsl_common.h **** 
 201:../drivers/fsl_common.h **** #if defined(__cplusplus)
 202:../drivers/fsl_common.h **** extern "C" {
 203:../drivers/fsl_common.h **** #endif
 204:../drivers/fsl_common.h **** 
 205:../drivers/fsl_common.h **** /*!
 206:../drivers/fsl_common.h ****  * @brief Enable specific interrupt.
 207:../drivers/fsl_common.h ****  *
 208:../drivers/fsl_common.h ****  * Enable the interrupt not routed from intmux.
 209:../drivers/fsl_common.h ****  *
 210:../drivers/fsl_common.h ****  * @param interrupt The IRQ number.
 211:../drivers/fsl_common.h ****  */
 212:../drivers/fsl_common.h **** static inline void EnableIRQ(IRQn_Type interrupt)
 213:../drivers/fsl_common.h **** {
 196              		.loc 3 213 1
 197              		.cfi_startproc
 198              		@ args = 0, pretend = 0, frame = 8
 199              		@ frame_needed = 1, uses_anonymous_args = 0
 200 0000 80B5     		push	{r7, lr}
 201              		.cfi_def_cfa_offset 8
 202              		.cfi_offset 7, -8
 203              		.cfi_offset 14, -4
 204 0002 82B0     		sub	sp, sp, #8
 205              		.cfi_def_cfa_offset 16
 206 0004 00AF     		add	r7, sp, #0
 207              		.cfi_def_cfa_register 7
 208 0006 0200     		movs	r2, r0
 209 0008 FB1D     		adds	r3, r7, #7
 210 000a 1A70     		strb	r2, [r3]
 214:../drivers/fsl_common.h ****     if (NotAvail_IRQn == interrupt)
 211              		.loc 3 214 8
 212 000c FB1D     		adds	r3, r7, #7
 213 000e 1B78     		ldrb	r3, [r3]
 214 0010 5BB2     		sxtb	r3, r3
 215 0012 8033     		adds	r3, r3, #128
 216 0014 06D0     		beq	.L13
 215:../drivers/fsl_common.h ****     {
 216:../drivers/fsl_common.h ****         return;
 217:../drivers/fsl_common.h ****     }
 218:../drivers/fsl_common.h **** 
 219:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_SOC_INTMUX_COUNT) && (FSL_FEATURE_SOC_INTMUX_COUNT > 0)
 220:../drivers/fsl_common.h ****     if (interrupt < FSL_FEATURE_INTMUX_IRQ_START_INDEX)
 221:../drivers/fsl_common.h **** #endif
 222:../drivers/fsl_common.h ****     {
 223:../drivers/fsl_common.h **** #if defined(__GIC_PRIO_BITS)
 224:../drivers/fsl_common.h ****         GIC_EnableIRQ(interrupt);
 225:../drivers/fsl_common.h **** #else
 226:../drivers/fsl_common.h ****         NVIC_EnableIRQ(interrupt);
 217              		.loc 3 226 9
 218 0016 FB1D     		adds	r3, r7, #7
 219 0018 1B78     		ldrb	r3, [r3]
 220 001a 5BB2     		sxtb	r3, r3
 221 001c 1800     		movs	r0, r3
 222 001e FFF7FEFF 		bl	NVIC_EnableIRQ
 223 0022 00E0     		b	.L10
 224              	.L13:
 216:../drivers/fsl_common.h ****     }
 225              		.loc 3 216 9
 226 0024 C046     		nop
 227              	.L10:
 227:../drivers/fsl_common.h **** #endif
 228:../drivers/fsl_common.h ****     }
 229:../drivers/fsl_common.h **** }
 228              		.loc 3 229 1
 229 0026 BD46     		mov	sp, r7
 230 0028 02B0     		add	sp, sp, #8
 231              		@ sp needed
 232 002a 80BD     		pop	{r7, pc}
 233              		.cfi_endproc
 234              	.LFE52:
 236              		.section	.bss.s_lpsciHandle,"aw",%nobits
 237              		.align	2
 240              	s_lpsciHandle:
 241 0000 00000000 		.space	4
 242              		.section	.rodata.s_lpsciBases,"a"
 243              		.align	2
 246              	s_lpsciBases:
 247 0000 00A00640 		.word	1074176000
 248              		.section	.rodata.s_lpsciIRQ,"a"
 249              		.align	2
 252              	s_lpsciIRQ:
 253 0000 0C       		.byte	12
 254              		.section	.rodata.s_lpsciClock,"a"
 255              		.align	2
 258              	s_lpsciClock:
 259 0000 0A003410 		.word	271843338
 260              		.section	.bss.s_lpsciIsr,"aw",%nobits
 261              		.align	2
 264              	s_lpsciIsr:
 265 0000 00000000 		.space	4
 266              		.section	.rodata.LPSCI_GetInstance.str1.4,"aMS",%progbits,1
 267              		.align	2
 268              	.LC0:
 269 0000 2E66736C 		.ascii	".fsl_lpsci.c:144 : instance < ARRAY_SIZE(s_lpsciBas"
 269      5F6C7073 
 269      63692E63 
 269      3A313434 
 269      203A2069 
 270 0033 65732900 		.ascii	"es)\000"
 271              		.section	.text.LPSCI_GetInstance,"ax",%progbits
 272              		.align	1
 273              		.global	LPSCI_GetInstance
 274              		.syntax unified
 275              		.code	16
 276              		.thumb_func
 277              		.fpu softvfp
 279              	LPSCI_GetInstance:
 280              	.LFB63:
 281              		.file 4 "../drivers/fsl_lpsci.c"
   1:../drivers/fsl_lpsci.c **** /*
   2:../drivers/fsl_lpsci.c ****  * Copyright (c) 2015-2016, Freescale Semiconductor, Inc.
   3:../drivers/fsl_lpsci.c ****  * Copyright 2016-2017 NXP
   4:../drivers/fsl_lpsci.c ****  *
   5:../drivers/fsl_lpsci.c ****  * Redistribution and use in source and binary forms, with or without modification,
   6:../drivers/fsl_lpsci.c ****  * are permitted provided that the following conditions are met:
   7:../drivers/fsl_lpsci.c ****  *
   8:../drivers/fsl_lpsci.c ****  * o Redistributions of source code must retain the above copyright notice, this list
   9:../drivers/fsl_lpsci.c ****  *   of conditions and the following disclaimer.
  10:../drivers/fsl_lpsci.c ****  *
  11:../drivers/fsl_lpsci.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  12:../drivers/fsl_lpsci.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  13:../drivers/fsl_lpsci.c ****  *   other materials provided with the distribution.
  14:../drivers/fsl_lpsci.c ****  *
  15:../drivers/fsl_lpsci.c ****  * o Neither the name of the copyright holder nor the names of its
  16:../drivers/fsl_lpsci.c ****  *   contributors may be used to endorse or promote products derived from this
  17:../drivers/fsl_lpsci.c ****  *   software without specific prior written permission.
  18:../drivers/fsl_lpsci.c ****  *
  19:../drivers/fsl_lpsci.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  20:../drivers/fsl_lpsci.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  21:../drivers/fsl_lpsci.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  22:../drivers/fsl_lpsci.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  23:../drivers/fsl_lpsci.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  24:../drivers/fsl_lpsci.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  25:../drivers/fsl_lpsci.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  26:../drivers/fsl_lpsci.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27:../drivers/fsl_lpsci.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  28:../drivers/fsl_lpsci.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29:../drivers/fsl_lpsci.c ****  */
  30:../drivers/fsl_lpsci.c **** 
  31:../drivers/fsl_lpsci.c **** #include "fsl_lpsci.h"
  32:../drivers/fsl_lpsci.c **** 
  33:../drivers/fsl_lpsci.c **** /*******************************************************************************
  34:../drivers/fsl_lpsci.c ****  * Definitions
  35:../drivers/fsl_lpsci.c ****  ******************************************************************************/
  36:../drivers/fsl_lpsci.c **** 
  37:../drivers/fsl_lpsci.c **** /* LPSCI transfer state. */
  38:../drivers/fsl_lpsci.c **** enum _lpsci_tansfer_state
  39:../drivers/fsl_lpsci.c **** {
  40:../drivers/fsl_lpsci.c ****     kLPSCI_TxIdle,         /*!< TX idle. */
  41:../drivers/fsl_lpsci.c ****     kLPSCI_TxBusy,         /*!< TX busy. */
  42:../drivers/fsl_lpsci.c ****     kLPSCI_RxIdle,         /*!< RX idle. */
  43:../drivers/fsl_lpsci.c ****     kLPSCI_RxBusy,         /*!< RX busy. */
  44:../drivers/fsl_lpsci.c ****     kLPSCI_RxFramingError, /* Rx framing error */
  45:../drivers/fsl_lpsci.c ****     kLPSCI_RxParityError   /* Rx parity error */
  46:../drivers/fsl_lpsci.c **** };
  47:../drivers/fsl_lpsci.c **** 
  48:../drivers/fsl_lpsci.c **** /* Typedef for interrupt handler. */
  49:../drivers/fsl_lpsci.c **** typedef void (*lpsci_isr_t)(UART0_Type *base, lpsci_handle_t *handle);
  50:../drivers/fsl_lpsci.c **** 
  51:../drivers/fsl_lpsci.c **** /*******************************************************************************
  52:../drivers/fsl_lpsci.c ****  * Prototypes
  53:../drivers/fsl_lpsci.c ****  ******************************************************************************/
  54:../drivers/fsl_lpsci.c **** 
  55:../drivers/fsl_lpsci.c **** /*!
  56:../drivers/fsl_lpsci.c ****  * @brief Get the LPSCI instance from peripheral base address.
  57:../drivers/fsl_lpsci.c ****  *
  58:../drivers/fsl_lpsci.c ****  * @param base LPSCI peripheral base address.
  59:../drivers/fsl_lpsci.c ****  * @return LPSCI instance.
  60:../drivers/fsl_lpsci.c ****  */
  61:../drivers/fsl_lpsci.c **** uint32_t LPSCI_GetInstance(UART0_Type *base);
  62:../drivers/fsl_lpsci.c **** 
  63:../drivers/fsl_lpsci.c **** /*!
  64:../drivers/fsl_lpsci.c ****  * @brief Get the length of received data in RX ring buffer.
  65:../drivers/fsl_lpsci.c ****  *
  66:../drivers/fsl_lpsci.c ****  * @userData handle LPSCI handle pointer.
  67:../drivers/fsl_lpsci.c ****  * @return Length of received data in RX ring buffer.
  68:../drivers/fsl_lpsci.c ****  */
  69:../drivers/fsl_lpsci.c **** static size_t LPSCI_TransferGetRxRingBufferLength(lpsci_handle_t *handle);
  70:../drivers/fsl_lpsci.c **** 
  71:../drivers/fsl_lpsci.c **** /*!
  72:../drivers/fsl_lpsci.c ****  * @brief Check whether the RX ring buffer is full.
  73:../drivers/fsl_lpsci.c ****  *
  74:../drivers/fsl_lpsci.c ****  * @parram handle LPSCI handle pointer.
  75:../drivers/fsl_lpsci.c ****  * @retval true  RX ring buffer is full.
  76:../drivers/fsl_lpsci.c ****  * @retval false RX ring buffer is not full.
  77:../drivers/fsl_lpsci.c ****  */
  78:../drivers/fsl_lpsci.c **** static bool LPSCI_TransferIsRxRingBufferFull(lpsci_handle_t *handle);
  79:../drivers/fsl_lpsci.c **** 
  80:../drivers/fsl_lpsci.c **** /*!
  81:../drivers/fsl_lpsci.c ****  * @brief Write to TX register using non-blocking method.
  82:../drivers/fsl_lpsci.c ****  *
  83:../drivers/fsl_lpsci.c ****  * This function writes data to the TX register directly, upper layer must make
  84:../drivers/fsl_lpsci.c ****  * sure the TX register is empty before calling this function.
  85:../drivers/fsl_lpsci.c ****  *
  86:../drivers/fsl_lpsci.c ****  * @note This function does not check whether all the data has been sent out to bus,
  87:../drivers/fsl_lpsci.c ****  * so before disable TX, check kLPSCI_TransmissionCompleteFlag to ensure the TX is
  88:../drivers/fsl_lpsci.c ****  * finished.
  89:../drivers/fsl_lpsci.c ****  *
  90:../drivers/fsl_lpsci.c ****  * @param base LPSCI peripheral base address.
  91:../drivers/fsl_lpsci.c ****  * @param data Start addresss of the data to write.
  92:../drivers/fsl_lpsci.c ****  * @param length Size of the buffer to be sent.
  93:../drivers/fsl_lpsci.c ****  */
  94:../drivers/fsl_lpsci.c **** static void LPSCI_WriteNonBlocking(UART0_Type *base, const uint8_t *data, size_t length);
  95:../drivers/fsl_lpsci.c **** 
  96:../drivers/fsl_lpsci.c **** /*!
  97:../drivers/fsl_lpsci.c ****  * @brief Read RX data register using blocking method.
  98:../drivers/fsl_lpsci.c ****  *
  99:../drivers/fsl_lpsci.c ****  * This function polls the RX register, waits for the RX register full
 100:../drivers/fsl_lpsci.c ****  * then read data from TX register.
 101:../drivers/fsl_lpsci.c ****  *
 102:../drivers/fsl_lpsci.c ****  * @param base LPSCI peripheral base address.
 103:../drivers/fsl_lpsci.c ****  * @param data Start addresss of the buffer to store the received data.
 104:../drivers/fsl_lpsci.c ****  * @param length Size of the buffer.
 105:../drivers/fsl_lpsci.c ****  */
 106:../drivers/fsl_lpsci.c **** static void LPSCI_ReadNonBlocking(UART0_Type *base, uint8_t *data, size_t length);
 107:../drivers/fsl_lpsci.c **** 
 108:../drivers/fsl_lpsci.c **** /*******************************************************************************
 109:../drivers/fsl_lpsci.c ****  * Variables
 110:../drivers/fsl_lpsci.c ****  ******************************************************************************/
 111:../drivers/fsl_lpsci.c **** /* Array of LPSCI handle. */
 112:../drivers/fsl_lpsci.c **** static lpsci_handle_t *s_lpsciHandle[FSL_FEATURE_SOC_LPSCI_COUNT];
 113:../drivers/fsl_lpsci.c **** 
 114:../drivers/fsl_lpsci.c **** /* Array of LPSCI peripheral base address. */
 115:../drivers/fsl_lpsci.c **** static UART0_Type *const s_lpsciBases[] = UART0_BASE_PTRS;
 116:../drivers/fsl_lpsci.c **** 
 117:../drivers/fsl_lpsci.c **** /* Array of LPSCI IRQ number. */
 118:../drivers/fsl_lpsci.c **** static const IRQn_Type s_lpsciIRQ[] = UART0_RX_TX_IRQS;
 119:../drivers/fsl_lpsci.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 120:../drivers/fsl_lpsci.c **** /* Array of LPSCI clock name. */
 121:../drivers/fsl_lpsci.c **** static const clock_ip_name_t s_lpsciClock[] = UART0_CLOCKS;
 122:../drivers/fsl_lpsci.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 123:../drivers/fsl_lpsci.c **** 
 124:../drivers/fsl_lpsci.c **** /* LPSCI ISR for transactional APIs. */
 125:../drivers/fsl_lpsci.c **** static lpsci_isr_t s_lpsciIsr;
 126:../drivers/fsl_lpsci.c **** 
 127:../drivers/fsl_lpsci.c **** /*******************************************************************************
 128:../drivers/fsl_lpsci.c ****  * Code
 129:../drivers/fsl_lpsci.c ****  ******************************************************************************/
 130:../drivers/fsl_lpsci.c **** 
 131:../drivers/fsl_lpsci.c **** uint32_t LPSCI_GetInstance(UART0_Type *base)
 132:../drivers/fsl_lpsci.c **** {
 282              		.loc 4 132 1
 283              		.cfi_startproc
 284              		@ args = 0, pretend = 0, frame = 16
 285              		@ frame_needed = 1, uses_anonymous_args = 0
 286 0000 80B5     		push	{r7, lr}
 287              		.cfi_def_cfa_offset 8
 288              		.cfi_offset 7, -8
 289              		.cfi_offset 14, -4
 290 0002 84B0     		sub	sp, sp, #16
 291              		.cfi_def_cfa_offset 24
 292 0004 00AF     		add	r7, sp, #0
 293              		.cfi_def_cfa_register 7
 294 0006 7860     		str	r0, [r7, #4]
 133:../drivers/fsl_lpsci.c ****     uint32_t instance;
 134:../drivers/fsl_lpsci.c **** 
 135:../drivers/fsl_lpsci.c ****     /* Find the instance index from base address mappings. */
 136:../drivers/fsl_lpsci.c ****     for (instance = 0; instance < ARRAY_SIZE(s_lpsciBases); instance++)
 295              		.loc 4 136 19
 296 0008 0023     		movs	r3, #0
 297 000a FB60     		str	r3, [r7, #12]
 298              		.loc 4 136 5
 299 000c 06E0     		b	.L15
 300              	.L18:
 137:../drivers/fsl_lpsci.c ****     {
 138:../drivers/fsl_lpsci.c ****         if (s_lpsciBases[instance] == base)
 301              		.loc 4 138 25
 302 000e 0C4A     		ldr	r2, .L22
 303              		.loc 4 138 12
 304 0010 7B68     		ldr	r3, [r7, #4]
 305 0012 9342     		cmp	r3, r2
 306 0014 06D0     		beq	.L21
 136:../drivers/fsl_lpsci.c ****     {
 307              		.loc 4 136 69 discriminator 2
 308 0016 FB68     		ldr	r3, [r7, #12]
 309 0018 0133     		adds	r3, r3, #1
 310 001a FB60     		str	r3, [r7, #12]
 311              	.L15:
 136:../drivers/fsl_lpsci.c ****     {
 312              		.loc 4 136 5 discriminator 1
 313 001c FB68     		ldr	r3, [r7, #12]
 314 001e 002B     		cmp	r3, #0
 315 0020 F5D0     		beq	.L18
 316 0022 00E0     		b	.L17
 317              	.L21:
 139:../drivers/fsl_lpsci.c ****         {
 140:../drivers/fsl_lpsci.c ****             break;
 318              		.loc 4 140 13
 319 0024 C046     		nop
 320              	.L17:
 141:../drivers/fsl_lpsci.c ****         }
 142:../drivers/fsl_lpsci.c ****     }
 143:../drivers/fsl_lpsci.c **** 
 144:../drivers/fsl_lpsci.c ****     assert(instance < ARRAY_SIZE(s_lpsciBases));
 321              		.loc 4 144 5
 322 0026 FB68     		ldr	r3, [r7, #12]
 323 0028 002B     		cmp	r3, #0
 324 002a 03D0     		beq	.L19
 325              		.loc 4 144 5 is_stmt 0 discriminator 1
 326 002c 054B     		ldr	r3, .L22+4
 327 002e 1800     		movs	r0, r3
 328 0030 FFF7FEFF 		bl	__assertion_failed
 329              	.L19:
 145:../drivers/fsl_lpsci.c **** 
 146:../drivers/fsl_lpsci.c ****     return instance;
 330              		.loc 4 146 12 is_stmt 1
 331 0034 FB68     		ldr	r3, [r7, #12]
 147:../drivers/fsl_lpsci.c **** }
 332              		.loc 4 147 1
 333 0036 1800     		movs	r0, r3
 334 0038 BD46     		mov	sp, r7
 335 003a 04B0     		add	sp, sp, #16
 336              		@ sp needed
 337 003c 80BD     		pop	{r7, pc}
 338              	.L23:
 339 003e C046     		.align	2
 340              	.L22:
 341 0040 00A00640 		.word	1074176000
 342 0044 00000000 		.word	.LC0
 343              		.cfi_endproc
 344              	.LFE63:
 346              		.section	.rodata.LPSCI_TransferGetRxRingBufferLength.str1.4,"aMS",%progbits,1
 347              		.align	2
 348              	.LC2:
 349 0000 2E66736C 		.ascii	".fsl_lpsci.c:151 : handle\000"
 349      5F6C7073 
 349      63692E63 
 349      3A313531 
 349      203A2068 
 350              		.section	.text.LPSCI_TransferGetRxRingBufferLength,"ax",%progbits
 351              		.align	1
 352              		.syntax unified
 353              		.code	16
 354              		.thumb_func
 355              		.fpu softvfp
 357              	LPSCI_TransferGetRxRingBufferLength:
 358              	.LFB64:
 148:../drivers/fsl_lpsci.c **** 
 149:../drivers/fsl_lpsci.c **** static size_t LPSCI_TransferGetRxRingBufferLength(lpsci_handle_t *handle)
 150:../drivers/fsl_lpsci.c **** {
 359              		.loc 4 150 1
 360              		.cfi_startproc
 361              		@ args = 0, pretend = 0, frame = 16
 362              		@ frame_needed = 1, uses_anonymous_args = 0
 363 0000 80B5     		push	{r7, lr}
 364              		.cfi_def_cfa_offset 8
 365              		.cfi_offset 7, -8
 366              		.cfi_offset 14, -4
 367 0002 84B0     		sub	sp, sp, #16
 368              		.cfi_def_cfa_offset 24
 369 0004 00AF     		add	r7, sp, #0
 370              		.cfi_def_cfa_register 7
 371 0006 7860     		str	r0, [r7, #4]
 151:../drivers/fsl_lpsci.c ****     assert(handle);
 372              		.loc 4 151 5
 373 0008 7B68     		ldr	r3, [r7, #4]
 374 000a 002B     		cmp	r3, #0
 375 000c 03D1     		bne	.L25
 376              		.loc 4 151 5 is_stmt 0 discriminator 1
 377 000e 134B     		ldr	r3, .L29
 378 0010 1800     		movs	r0, r3
 379 0012 FFF7FEFF 		bl	__assertion_failed
 380              	.L25:
 152:../drivers/fsl_lpsci.c **** 
 153:../drivers/fsl_lpsci.c ****     size_t size;
 154:../drivers/fsl_lpsci.c **** 
 155:../drivers/fsl_lpsci.c ****     if (handle->rxRingBufferTail > handle->rxRingBufferHead)
 381              		.loc 4 155 15 is_stmt 1
 382 0016 7B68     		ldr	r3, [r7, #4]
 383 0018 5B8C     		ldrh	r3, [r3, #34]
 384 001a 9AB2     		uxth	r2, r3
 385              		.loc 4 155 42
 386 001c 7B68     		ldr	r3, [r7, #4]
 387 001e 1B8C     		ldrh	r3, [r3, #32]
 388 0020 9BB2     		uxth	r3, r3
 389              		.loc 4 155 8
 390 0022 9A42     		cmp	r2, r3
 391 0024 0CD9     		bls	.L26
 156:../drivers/fsl_lpsci.c ****     {
 157:../drivers/fsl_lpsci.c ****         size = (size_t)(handle->rxRingBufferHead + handle->rxRingBufferSize - handle->rxRingBufferT
 392              		.loc 4 157 31
 393 0026 7B68     		ldr	r3, [r7, #4]
 394 0028 1B8C     		ldrh	r3, [r3, #32]
 395 002a 9BB2     		uxth	r3, r3
 396 002c 1A00     		movs	r2, r3
 397              		.loc 4 157 58
 398 002e 7B68     		ldr	r3, [r7, #4]
 399 0030 DB69     		ldr	r3, [r3, #28]
 400              		.loc 4 157 50
 401 0032 D318     		adds	r3, r2, r3
 402              		.loc 4 157 85
 403 0034 7A68     		ldr	r2, [r7, #4]
 404 0036 528C     		ldrh	r2, [r2, #34]
 405 0038 92B2     		uxth	r2, r2
 406              		.loc 4 157 14
 407 003a 9B1A     		subs	r3, r3, r2
 408 003c FB60     		str	r3, [r7, #12]
 409 003e 08E0     		b	.L27
 410              	.L26:
 158:../drivers/fsl_lpsci.c ****     }
 159:../drivers/fsl_lpsci.c ****     else
 160:../drivers/fsl_lpsci.c ****     {
 161:../drivers/fsl_lpsci.c ****         size = (size_t)(handle->rxRingBufferHead - handle->rxRingBufferTail);
 411              		.loc 4 161 31
 412 0040 7B68     		ldr	r3, [r7, #4]
 413 0042 1B8C     		ldrh	r3, [r3, #32]
 414 0044 9BB2     		uxth	r3, r3
 415 0046 1A00     		movs	r2, r3
 416              		.loc 4 161 58
 417 0048 7B68     		ldr	r3, [r7, #4]
 418 004a 5B8C     		ldrh	r3, [r3, #34]
 419 004c 9BB2     		uxth	r3, r3
 420              		.loc 4 161 50
 421 004e D31A     		subs	r3, r2, r3
 422              		.loc 4 161 14
 423 0050 FB60     		str	r3, [r7, #12]
 424              	.L27:
 162:../drivers/fsl_lpsci.c ****     }
 163:../drivers/fsl_lpsci.c **** 
 164:../drivers/fsl_lpsci.c ****     return size;
 425              		.loc 4 164 12
 426 0052 FB68     		ldr	r3, [r7, #12]
 165:../drivers/fsl_lpsci.c **** }
 427              		.loc 4 165 1
 428 0054 1800     		movs	r0, r3
 429 0056 BD46     		mov	sp, r7
 430 0058 04B0     		add	sp, sp, #16
 431              		@ sp needed
 432 005a 80BD     		pop	{r7, pc}
 433              	.L30:
 434              		.align	2
 435              	.L29:
 436 005c 00000000 		.word	.LC2
 437              		.cfi_endproc
 438              	.LFE64:
 440              		.section	.rodata.LPSCI_TransferIsRxRingBufferFull.str1.4,"aMS",%progbits,1
 441              		.align	2
 442              	.LC4:
 443 0000 2E66736C 		.ascii	".fsl_lpsci.c:169 : handle\000"
 443      5F6C7073 
 443      63692E63 
 443      3A313639 
 443      203A2068 
 444              		.section	.text.LPSCI_TransferIsRxRingBufferFull,"ax",%progbits
 445              		.align	1
 446              		.syntax unified
 447              		.code	16
 448              		.thumb_func
 449              		.fpu softvfp
 451              	LPSCI_TransferIsRxRingBufferFull:
 452              	.LFB65:
 166:../drivers/fsl_lpsci.c **** 
 167:../drivers/fsl_lpsci.c **** static bool LPSCI_TransferIsRxRingBufferFull(lpsci_handle_t *handle)
 168:../drivers/fsl_lpsci.c **** {
 453              		.loc 4 168 1
 454              		.cfi_startproc
 455              		@ args = 0, pretend = 0, frame = 16
 456              		@ frame_needed = 1, uses_anonymous_args = 0
 457 0000 80B5     		push	{r7, lr}
 458              		.cfi_def_cfa_offset 8
 459              		.cfi_offset 7, -8
 460              		.cfi_offset 14, -4
 461 0002 84B0     		sub	sp, sp, #16
 462              		.cfi_def_cfa_offset 24
 463 0004 00AF     		add	r7, sp, #0
 464              		.cfi_def_cfa_register 7
 465 0006 7860     		str	r0, [r7, #4]
 169:../drivers/fsl_lpsci.c ****     assert(handle);
 466              		.loc 4 169 5
 467 0008 7B68     		ldr	r3, [r7, #4]
 468 000a 002B     		cmp	r3, #0
 469 000c 03D1     		bne	.L32
 470              		.loc 4 169 5 is_stmt 0 discriminator 1
 471 000e 0F4B     		ldr	r3, .L36
 472 0010 1800     		movs	r0, r3
 473 0012 FFF7FEFF 		bl	__assertion_failed
 474              	.L32:
 170:../drivers/fsl_lpsci.c **** 
 171:../drivers/fsl_lpsci.c ****     bool full;
 172:../drivers/fsl_lpsci.c **** 
 173:../drivers/fsl_lpsci.c ****     if (LPSCI_TransferGetRxRingBufferLength(handle) == (handle->rxRingBufferSize - 1U))
 475              		.loc 4 173 9 is_stmt 1
 476 0016 7B68     		ldr	r3, [r7, #4]
 477 0018 1800     		movs	r0, r3
 478 001a FFF7FEFF 		bl	LPSCI_TransferGetRxRingBufferLength
 479 001e 0200     		movs	r2, r0
 480              		.loc 4 173 63
 481 0020 7B68     		ldr	r3, [r7, #4]
 482 0022 DB69     		ldr	r3, [r3, #28]
 483              		.loc 4 173 82
 484 0024 013B     		subs	r3, r3, #1
 485              		.loc 4 173 8
 486 0026 9A42     		cmp	r2, r3
 487 0028 04D1     		bne	.L33
 174:../drivers/fsl_lpsci.c ****     {
 175:../drivers/fsl_lpsci.c ****         full = true;
 488              		.loc 4 175 14
 489 002a 0F23     		movs	r3, #15
 490 002c FB18     		adds	r3, r7, r3
 491 002e 0122     		movs	r2, #1
 492 0030 1A70     		strb	r2, [r3]
 493 0032 03E0     		b	.L34
 494              	.L33:
 176:../drivers/fsl_lpsci.c ****     }
 177:../drivers/fsl_lpsci.c ****     else
 178:../drivers/fsl_lpsci.c ****     {
 179:../drivers/fsl_lpsci.c ****         full = false;
 495              		.loc 4 179 14
 496 0034 0F23     		movs	r3, #15
 497 0036 FB18     		adds	r3, r7, r3
 498 0038 0022     		movs	r2, #0
 499 003a 1A70     		strb	r2, [r3]
 500              	.L34:
 180:../drivers/fsl_lpsci.c ****     }
 181:../drivers/fsl_lpsci.c **** 
 182:../drivers/fsl_lpsci.c ****     return full;
 501              		.loc 4 182 12
 502 003c 0F23     		movs	r3, #15
 503 003e FB18     		adds	r3, r7, r3
 504 0040 1B78     		ldrb	r3, [r3]
 183:../drivers/fsl_lpsci.c **** }
 505              		.loc 4 183 1
 506 0042 1800     		movs	r0, r3
 507 0044 BD46     		mov	sp, r7
 508 0046 04B0     		add	sp, sp, #16
 509              		@ sp needed
 510 0048 80BD     		pop	{r7, pc}
 511              	.L37:
 512 004a C046     		.align	2
 513              	.L36:
 514 004c 00000000 		.word	.LC4
 515              		.cfi_endproc
 516              	.LFE65:
 518              		.section	.rodata.LPSCI_ReadNonBlocking.str1.4,"aMS",%progbits,1
 519              		.align	2
 520              	.LC6:
 521 0000 2E66736C 		.ascii	".fsl_lpsci.c:187 : data\000"
 521      5F6C7073 
 521      63692E63 
 521      3A313837 
 521      203A2064 
 522              		.section	.text.LPSCI_ReadNonBlocking,"ax",%progbits
 523              		.align	1
 524              		.syntax unified
 525              		.code	16
 526              		.thumb_func
 527              		.fpu softvfp
 529              	LPSCI_ReadNonBlocking:
 530              	.LFB66:
 184:../drivers/fsl_lpsci.c **** 
 185:../drivers/fsl_lpsci.c **** static void LPSCI_ReadNonBlocking(UART0_Type *base, uint8_t *data, size_t length)
 186:../drivers/fsl_lpsci.c **** {
 531              		.loc 4 186 1
 532              		.cfi_startproc
 533              		@ args = 0, pretend = 0, frame = 24
 534              		@ frame_needed = 1, uses_anonymous_args = 0
 535 0000 80B5     		push	{r7, lr}
 536              		.cfi_def_cfa_offset 8
 537              		.cfi_offset 7, -8
 538              		.cfi_offset 14, -4
 539 0002 86B0     		sub	sp, sp, #24
 540              		.cfi_def_cfa_offset 32
 541 0004 00AF     		add	r7, sp, #0
 542              		.cfi_def_cfa_register 7
 543 0006 F860     		str	r0, [r7, #12]
 544 0008 B960     		str	r1, [r7, #8]
 545 000a 7A60     		str	r2, [r7, #4]
 187:../drivers/fsl_lpsci.c ****     assert(data);
 546              		.loc 4 187 5
 547 000c BB68     		ldr	r3, [r7, #8]
 548 000e 002B     		cmp	r3, #0
 549 0010 03D1     		bne	.L39
 550              		.loc 4 187 5 is_stmt 0 discriminator 1
 551 0012 0D4B     		ldr	r3, .L42
 552 0014 1800     		movs	r0, r3
 553 0016 FFF7FEFF 		bl	__assertion_failed
 554              	.L39:
 188:../drivers/fsl_lpsci.c **** 
 189:../drivers/fsl_lpsci.c ****     /* The Non Blocking read data API assume user have ensured there is enough space in
 190:../drivers/fsl_lpsci.c ****     peripheral to write. */
 191:../drivers/fsl_lpsci.c ****     size_t i;
 192:../drivers/fsl_lpsci.c **** 
 193:../drivers/fsl_lpsci.c ****     for (i = 0; i < length; i++)
 555              		.loc 4 193 12 is_stmt 1
 556 001a 0023     		movs	r3, #0
 557 001c 7B61     		str	r3, [r7, #20]
 558              		.loc 4 193 5
 559 001e 09E0     		b	.L40
 560              	.L41:
 194:../drivers/fsl_lpsci.c ****     {
 195:../drivers/fsl_lpsci.c ****         data[i] = base->D;
 561              		.loc 4 195 13 discriminator 3
 562 0020 BA68     		ldr	r2, [r7, #8]
 563 0022 7B69     		ldr	r3, [r7, #20]
 564 0024 D318     		adds	r3, r2, r3
 565              		.loc 4 195 23 discriminator 3
 566 0026 FA68     		ldr	r2, [r7, #12]
 567 0028 D279     		ldrb	r2, [r2, #7]
 568 002a D2B2     		uxtb	r2, r2
 569              		.loc 4 195 17 discriminator 3
 570 002c 1A70     		strb	r2, [r3]
 193:../drivers/fsl_lpsci.c ****     {
 571              		.loc 4 193 30 discriminator 3
 572 002e 7B69     		ldr	r3, [r7, #20]
 573 0030 0133     		adds	r3, r3, #1
 574 0032 7B61     		str	r3, [r7, #20]
 575              	.L40:
 193:../drivers/fsl_lpsci.c ****     {
 576              		.loc 4 193 5 discriminator 1
 577 0034 7A69     		ldr	r2, [r7, #20]
 578 0036 7B68     		ldr	r3, [r7, #4]
 579 0038 9A42     		cmp	r2, r3
 580 003a F1D3     		bcc	.L41
 196:../drivers/fsl_lpsci.c ****     }
 197:../drivers/fsl_lpsci.c **** }
 581              		.loc 4 197 1
 582 003c C046     		nop
 583 003e C046     		nop
 584 0040 BD46     		mov	sp, r7
 585 0042 06B0     		add	sp, sp, #24
 586              		@ sp needed
 587 0044 80BD     		pop	{r7, pc}
 588              	.L43:
 589 0046 C046     		.align	2
 590              	.L42:
 591 0048 00000000 		.word	.LC6
 592              		.cfi_endproc
 593              	.LFE66:
 595              		.section	.rodata.LPSCI_WriteNonBlocking.str1.4,"aMS",%progbits,1
 596              		.align	2
 597              	.LC8:
 598 0000 2E66736C 		.ascii	".fsl_lpsci.c:201 : data\000"
 598      5F6C7073 
 598      63692E63 
 598      3A323031 
 598      203A2064 
 599              		.section	.text.LPSCI_WriteNonBlocking,"ax",%progbits
 600              		.align	1
 601              		.syntax unified
 602              		.code	16
 603              		.thumb_func
 604              		.fpu softvfp
 606              	LPSCI_WriteNonBlocking:
 607              	.LFB67:
 198:../drivers/fsl_lpsci.c **** 
 199:../drivers/fsl_lpsci.c **** static void LPSCI_WriteNonBlocking(UART0_Type *base, const uint8_t *data, size_t length)
 200:../drivers/fsl_lpsci.c **** {
 608              		.loc 4 200 1
 609              		.cfi_startproc
 610              		@ args = 0, pretend = 0, frame = 24
 611              		@ frame_needed = 1, uses_anonymous_args = 0
 612 0000 80B5     		push	{r7, lr}
 613              		.cfi_def_cfa_offset 8
 614              		.cfi_offset 7, -8
 615              		.cfi_offset 14, -4
 616 0002 86B0     		sub	sp, sp, #24
 617              		.cfi_def_cfa_offset 32
 618 0004 00AF     		add	r7, sp, #0
 619              		.cfi_def_cfa_register 7
 620 0006 F860     		str	r0, [r7, #12]
 621 0008 B960     		str	r1, [r7, #8]
 622 000a 7A60     		str	r2, [r7, #4]
 201:../drivers/fsl_lpsci.c ****     assert(data);
 623              		.loc 4 201 5
 624 000c BB68     		ldr	r3, [r7, #8]
 625 000e 002B     		cmp	r3, #0
 626 0010 03D1     		bne	.L45
 627              		.loc 4 201 5 is_stmt 0 discriminator 1
 628 0012 0C4B     		ldr	r3, .L48
 629 0014 1800     		movs	r0, r3
 630 0016 FFF7FEFF 		bl	__assertion_failed
 631              	.L45:
 202:../drivers/fsl_lpsci.c **** 
 203:../drivers/fsl_lpsci.c ****     /* The Non Blocking write data API assume user have ensured there is enough space in
 204:../drivers/fsl_lpsci.c ****     peripheral to write. */
 205:../drivers/fsl_lpsci.c ****     size_t i;
 206:../drivers/fsl_lpsci.c **** 
 207:../drivers/fsl_lpsci.c ****     for (i = 0; i < length; i++)
 632              		.loc 4 207 12 is_stmt 1
 633 001a 0023     		movs	r3, #0
 634 001c 7B61     		str	r3, [r7, #20]
 635              		.loc 4 207 5
 636 001e 08E0     		b	.L46
 637              	.L47:
 208:../drivers/fsl_lpsci.c ****     {
 209:../drivers/fsl_lpsci.c ****         base->D = data[i];
 638              		.loc 4 209 23 discriminator 3
 639 0020 BA68     		ldr	r2, [r7, #8]
 640 0022 7B69     		ldr	r3, [r7, #20]
 641 0024 D318     		adds	r3, r2, r3
 642 0026 1A78     		ldrb	r2, [r3]
 643              		.loc 4 209 17 discriminator 3
 644 0028 FB68     		ldr	r3, [r7, #12]
 645 002a DA71     		strb	r2, [r3, #7]
 207:../drivers/fsl_lpsci.c ****     {
 646              		.loc 4 207 30 discriminator 3
 647 002c 7B69     		ldr	r3, [r7, #20]
 648 002e 0133     		adds	r3, r3, #1
 649 0030 7B61     		str	r3, [r7, #20]
 650              	.L46:
 207:../drivers/fsl_lpsci.c ****     {
 651              		.loc 4 207 5 discriminator 1
 652 0032 7A69     		ldr	r2, [r7, #20]
 653 0034 7B68     		ldr	r3, [r7, #4]
 654 0036 9A42     		cmp	r2, r3
 655 0038 F2D3     		bcc	.L47
 210:../drivers/fsl_lpsci.c ****     }
 211:../drivers/fsl_lpsci.c **** }
 656              		.loc 4 211 1
 657 003a C046     		nop
 658 003c C046     		nop
 659 003e BD46     		mov	sp, r7
 660 0040 06B0     		add	sp, sp, #24
 661              		@ sp needed
 662 0042 80BD     		pop	{r7, pc}
 663              	.L49:
 664              		.align	2
 665              	.L48:
 666 0044 00000000 		.word	.LC8
 667              		.cfi_endproc
 668              	.LFE67:
 670              		.section	.rodata.LPSCI_Init.str1.4,"aMS",%progbits,1
 671              		.align	2
 672              	.LC10:
 673 0000 2E66736C 		.ascii	".fsl_lpsci.c:215 : config\000"
 673      5F6C7073 
 673      63692E63 
 673      3A323135 
 673      203A2063 
 674 001a 0000     		.align	2
 675              	.LC12:
 676 001c 2E66736C 		.ascii	".fsl_lpsci.c:216 : config->baudRate_Bps\000"
 676      5F6C7073 
 676      63692E63 
 676      3A323136 
 676      203A2063 
 677              		.global	__aeabi_uidiv
 678              		.section	.text.LPSCI_Init,"ax",%progbits
 679              		.align	1
 680              		.global	LPSCI_Init
 681              		.syntax unified
 682              		.code	16
 683              		.thumb_func
 684              		.fpu softvfp
 686              	LPSCI_Init:
 687              	.LFB68:
 212:../drivers/fsl_lpsci.c **** 
 213:../drivers/fsl_lpsci.c **** status_t LPSCI_Init(UART0_Type *base, const lpsci_config_t *config, uint32_t srcClock_Hz)
 214:../drivers/fsl_lpsci.c **** {
 688              		.loc 4 214 1
 689              		.cfi_startproc
 690              		@ args = 0, pretend = 0, frame = 48
 691              		@ frame_needed = 1, uses_anonymous_args = 0
 692 0000 B0B5     		push	{r4, r5, r7, lr}
 693              		.cfi_def_cfa_offset 16
 694              		.cfi_offset 4, -16
 695              		.cfi_offset 5, -12
 696              		.cfi_offset 7, -8
 697              		.cfi_offset 14, -4
 698 0002 8CB0     		sub	sp, sp, #48
 699              		.cfi_def_cfa_offset 64
 700 0004 00AF     		add	r7, sp, #0
 701              		.cfi_def_cfa_register 7
 702 0006 F860     		str	r0, [r7, #12]
 703 0008 B960     		str	r1, [r7, #8]
 704 000a 7A60     		str	r2, [r7, #4]
 215:../drivers/fsl_lpsci.c ****     assert(config);
 705              		.loc 4 215 5
 706 000c BB68     		ldr	r3, [r7, #8]
 707 000e 002B     		cmp	r3, #0
 708 0010 03D1     		bne	.L51
 709              		.loc 4 215 5 is_stmt 0 discriminator 1
 710 0012 8D4B     		ldr	r3, .L64
 711 0014 1800     		movs	r0, r3
 712 0016 FFF7FEFF 		bl	__assertion_failed
 713              	.L51:
 216:../drivers/fsl_lpsci.c ****     assert(config->baudRate_Bps);
 714              		.loc 4 216 5 is_stmt 1
 715 001a BB68     		ldr	r3, [r7, #8]
 716 001c 1B68     		ldr	r3, [r3]
 717 001e 002B     		cmp	r3, #0
 718 0020 03D1     		bne	.L52
 719              		.loc 4 216 5 is_stmt 0 discriminator 1
 720 0022 8A4B     		ldr	r3, .L64+4
 721 0024 1800     		movs	r0, r3
 722 0026 FFF7FEFF 		bl	__assertion_failed
 723              	.L52:
 217:../drivers/fsl_lpsci.c **** 
 218:../drivers/fsl_lpsci.c ****     uint8_t temp;
 219:../drivers/fsl_lpsci.c ****     uint16_t sbr = 0;
 724              		.loc 4 219 14 is_stmt 1
 725 002a 2C23     		movs	r3, #44
 726 002c FB18     		adds	r3, r7, r3
 727 002e 0022     		movs	r2, #0
 728 0030 1A80     		strh	r2, [r3]
 220:../drivers/fsl_lpsci.c ****     uint16_t sbrTemp;
 221:../drivers/fsl_lpsci.c ****     uint32_t osr = 0;
 729              		.loc 4 221 14
 730 0032 0023     		movs	r3, #0
 731 0034 7B62     		str	r3, [r7, #36]
 222:../drivers/fsl_lpsci.c ****     uint32_t osrTemp;
 223:../drivers/fsl_lpsci.c ****     uint32_t tempDiff, calculatedBaud, baudDiff;
 224:../drivers/fsl_lpsci.c **** 
 225:../drivers/fsl_lpsci.c ****     /* This LPSCI instantiation uses a slightly different baud rate calculation
 226:../drivers/fsl_lpsci.c ****      * The idea is to use the best OSR (over-sampling rate) possible
 227:../drivers/fsl_lpsci.c ****      * Note, OSR is typically hard-set to 16 in other LPSCI instantiations
 228:../drivers/fsl_lpsci.c ****      * loop to find the best OSR value possible, one that generates minimum baudDiff
 229:../drivers/fsl_lpsci.c ****      * iterate through the rest of the supported values of OSR */
 230:../drivers/fsl_lpsci.c **** 
 231:../drivers/fsl_lpsci.c ****     baudDiff = config->baudRate_Bps;
 732              		.loc 4 231 14
 733 0036 BB68     		ldr	r3, [r7, #8]
 734 0038 1B68     		ldr	r3, [r3]
 735 003a BB61     		str	r3, [r7, #24]
 232:../drivers/fsl_lpsci.c ****     for (osrTemp = 4; osrTemp <= 32; osrTemp++)
 736              		.loc 4 232 18
 737 003c 0423     		movs	r3, #4
 738 003e 3B62     		str	r3, [r7, #32]
 739              		.loc 4 232 5
 740 0040 5AE0     		b	.L53
 741              	.L57:
 233:../drivers/fsl_lpsci.c ****     {
 234:../drivers/fsl_lpsci.c ****         /* calculate the temporary sbr value   */
 235:../drivers/fsl_lpsci.c ****         sbrTemp = (srcClock_Hz / (config->baudRate_Bps * osrTemp));
 742              		.loc 4 235 41
 743 0042 BB68     		ldr	r3, [r7, #8]
 744 0044 1B68     		ldr	r3, [r3]
 745              		.loc 4 235 56
 746 0046 3A6A     		ldr	r2, [r7, #32]
 747 0048 5343     		muls	r3, r2
 748              		.loc 4 235 32
 749 004a 1900     		movs	r1, r3
 750 004c 7868     		ldr	r0, [r7, #4]
 751 004e FFF7FEFF 		bl	__aeabi_uidiv
 752              	.LVL0:
 753 0052 0300     		movs	r3, r0
 754 0054 1A00     		movs	r2, r3
 755              		.loc 4 235 17
 756 0056 2A21     		movs	r1, #42
 757 0058 7B18     		adds	r3, r7, r1
 758 005a 1A80     		strh	r2, [r3]
 236:../drivers/fsl_lpsci.c ****         /* set sbrTemp to 1 if the sourceClockInHz can not satisfy the desired baud rate */
 237:../drivers/fsl_lpsci.c ****         if (sbrTemp == 0)
 759              		.loc 4 237 12
 760 005c 0A00     		movs	r2, r1
 761 005e BB18     		adds	r3, r7, r2
 762 0060 1B88     		ldrh	r3, [r3]
 763 0062 002B     		cmp	r3, #0
 764 0064 02D1     		bne	.L54
 238:../drivers/fsl_lpsci.c ****         {
 239:../drivers/fsl_lpsci.c ****             sbrTemp = 1;
 765              		.loc 4 239 21
 766 0066 BB18     		adds	r3, r7, r2
 767 0068 0122     		movs	r2, #1
 768 006a 1A80     		strh	r2, [r3]
 769              	.L54:
 240:../drivers/fsl_lpsci.c ****         }
 241:../drivers/fsl_lpsci.c ****         /* Calculate the baud rate based on the temporary OSR and SBR values */
 242:../drivers/fsl_lpsci.c ****         calculatedBaud = (srcClock_Hz / (osrTemp * sbrTemp));
 770              		.loc 4 242 50
 771 006c 2A25     		movs	r5, #42
 772 006e 7B19     		adds	r3, r7, r5
 773 0070 1B88     		ldrh	r3, [r3]
 774 0072 3A6A     		ldr	r2, [r7, #32]
 775 0074 5343     		muls	r3, r2
 776              		.loc 4 242 24
 777 0076 1900     		movs	r1, r3
 778 0078 7868     		ldr	r0, [r7, #4]
 779 007a FFF7FEFF 		bl	__aeabi_uidiv
 780              	.LVL1:
 781 007e 0300     		movs	r3, r0
 782 0080 7B61     		str	r3, [r7, #20]
 243:../drivers/fsl_lpsci.c **** 
 244:../drivers/fsl_lpsci.c ****         tempDiff = calculatedBaud - config->baudRate_Bps;
 783              		.loc 4 244 43
 784 0082 BB68     		ldr	r3, [r7, #8]
 785 0084 1B68     		ldr	r3, [r3]
 786              		.loc 4 244 18
 787 0086 7A69     		ldr	r2, [r7, #20]
 788 0088 D31A     		subs	r3, r2, r3
 789 008a FB61     		str	r3, [r7, #28]
 245:../drivers/fsl_lpsci.c **** 
 246:../drivers/fsl_lpsci.c ****         /* Select the better value between srb and (sbr + 1) */
 247:../drivers/fsl_lpsci.c ****         if (tempDiff > (config->baudRate_Bps - (srcClock_Hz / (osrTemp * (sbrTemp + 1)))))
 790              		.loc 4 247 31
 791 008c BB68     		ldr	r3, [r7, #8]
 792 008e 1C68     		ldr	r4, [r3]
 793              		.loc 4 247 83
 794 0090 7B19     		adds	r3, r7, r5
 795 0092 1B88     		ldrh	r3, [r3]
 796 0094 0133     		adds	r3, r3, #1
 797 0096 1A00     		movs	r2, r3
 798              		.loc 4 247 72
 799 0098 3B6A     		ldr	r3, [r7, #32]
 800 009a 5343     		muls	r3, r2
 801              		.loc 4 247 61
 802 009c 1900     		movs	r1, r3
 803 009e 7868     		ldr	r0, [r7, #4]
 804 00a0 FFF7FEFF 		bl	__aeabi_uidiv
 805              	.LVL2:
 806 00a4 0300     		movs	r3, r0
 807              		.loc 4 247 46
 808 00a6 E31A     		subs	r3, r4, r3
 809              		.loc 4 247 12
 810 00a8 FA69     		ldr	r2, [r7, #28]
 811 00aa 9A42     		cmp	r2, r3
 812 00ac 13D9     		bls	.L55
 248:../drivers/fsl_lpsci.c ****         {
 249:../drivers/fsl_lpsci.c ****             tempDiff = config->baudRate_Bps - (srcClock_Hz / (osrTemp * (sbrTemp + 1)));
 813              		.loc 4 249 30
 814 00ae BB68     		ldr	r3, [r7, #8]
 815 00b0 1C68     		ldr	r4, [r3]
 816              		.loc 4 249 82
 817 00b2 7B19     		adds	r3, r7, r5
 818 00b4 1B88     		ldrh	r3, [r3]
 819 00b6 0133     		adds	r3, r3, #1
 820 00b8 1A00     		movs	r2, r3
 821              		.loc 4 249 71
 822 00ba 3B6A     		ldr	r3, [r7, #32]
 823 00bc 5343     		muls	r3, r2
 824              		.loc 4 249 60
 825 00be 1900     		movs	r1, r3
 826 00c0 7868     		ldr	r0, [r7, #4]
 827 00c2 FFF7FEFF 		bl	__aeabi_uidiv
 828              	.LVL3:
 829 00c6 0300     		movs	r3, r0
 830              		.loc 4 249 22
 831 00c8 E31A     		subs	r3, r4, r3
 832 00ca FB61     		str	r3, [r7, #28]
 250:../drivers/fsl_lpsci.c ****             sbrTemp++;
 833              		.loc 4 250 20
 834 00cc 7B19     		adds	r3, r7, r5
 835 00ce 1A88     		ldrh	r2, [r3]
 836 00d0 7B19     		adds	r3, r7, r5
 837 00d2 0132     		adds	r2, r2, #1
 838 00d4 1A80     		strh	r2, [r3]
 839              	.L55:
 251:../drivers/fsl_lpsci.c ****         }
 252:../drivers/fsl_lpsci.c **** 
 253:../drivers/fsl_lpsci.c ****         if (tempDiff <= baudDiff)
 840              		.loc 4 253 12
 841 00d6 FA69     		ldr	r2, [r7, #28]
 842 00d8 BB69     		ldr	r3, [r7, #24]
 843 00da 9A42     		cmp	r2, r3
 844 00dc 09D8     		bhi	.L56
 254:../drivers/fsl_lpsci.c ****         {
 255:../drivers/fsl_lpsci.c ****             baudDiff = tempDiff;
 845              		.loc 4 255 22
 846 00de FB69     		ldr	r3, [r7, #28]
 847 00e0 BB61     		str	r3, [r7, #24]
 256:../drivers/fsl_lpsci.c ****             osr = osrTemp; /* update and store the best OSR value calculated*/
 848              		.loc 4 256 17
 849 00e2 3B6A     		ldr	r3, [r7, #32]
 850 00e4 7B62     		str	r3, [r7, #36]
 257:../drivers/fsl_lpsci.c ****             sbr = sbrTemp; /* update store the best SBR value calculated*/
 851              		.loc 4 257 17
 852 00e6 2C23     		movs	r3, #44
 853 00e8 FB18     		adds	r3, r7, r3
 854 00ea 2A22     		movs	r2, #42
 855 00ec BA18     		adds	r2, r7, r2
 856 00ee 1288     		ldrh	r2, [r2]
 857 00f0 1A80     		strh	r2, [r3]
 858              	.L56:
 232:../drivers/fsl_lpsci.c ****     {
 859              		.loc 4 232 45 discriminator 2
 860 00f2 3B6A     		ldr	r3, [r7, #32]
 861 00f4 0133     		adds	r3, r3, #1
 862 00f6 3B62     		str	r3, [r7, #32]
 863              	.L53:
 232:../drivers/fsl_lpsci.c ****     {
 864              		.loc 4 232 5 discriminator 1
 865 00f8 3B6A     		ldr	r3, [r7, #32]
 866 00fa 202B     		cmp	r3, #32
 867 00fc A1D9     		bls	.L57
 258:../drivers/fsl_lpsci.c ****         }
 259:../drivers/fsl_lpsci.c ****     }
 260:../drivers/fsl_lpsci.c **** 
 261:../drivers/fsl_lpsci.c ****     /* next, check to see if actual baud rate is within 3% of desired baud rate
 262:../drivers/fsl_lpsci.c ****      * based on the best calculate OSR value */
 263:../drivers/fsl_lpsci.c ****     if (baudDiff > ((config->baudRate_Bps / 100) * 3))
 868              		.loc 4 263 28
 869 00fe BB68     		ldr	r3, [r7, #8]
 870 0100 1B68     		ldr	r3, [r3]
 871              		.loc 4 263 43
 872 0102 6421     		movs	r1, #100
 873 0104 1800     		movs	r0, r3
 874 0106 FFF7FEFF 		bl	__aeabi_uidiv
 875              	.LVL4:
 876 010a 0300     		movs	r3, r0
 877 010c 1A00     		movs	r2, r3
 878              		.loc 4 263 50
 879 010e 1300     		movs	r3, r2
 880 0110 5B00     		lsls	r3, r3, #1
 881 0112 9B18     		adds	r3, r3, r2
 882              		.loc 4 263 8
 883 0114 BA69     		ldr	r2, [r7, #24]
 884 0116 9A42     		cmp	r2, r3
 885 0118 01D9     		bls	.L58
 264:../drivers/fsl_lpsci.c ****     {
 265:../drivers/fsl_lpsci.c ****         /* Unacceptable baud rate difference of more than 3%*/
 266:../drivers/fsl_lpsci.c ****         return kStatus_LPSCI_BaudrateNotSupport;
 886              		.loc 4 266 16
 887 011a 4D4B     		ldr	r3, .L64+8
 888 011c 90E0     		b	.L59
 889              	.L58:
 267:../drivers/fsl_lpsci.c ****     }
 268:../drivers/fsl_lpsci.c **** 
 269:../drivers/fsl_lpsci.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 270:../drivers/fsl_lpsci.c ****     /* Enable LPSCI clock */
 271:../drivers/fsl_lpsci.c ****     CLOCK_EnableClock(s_lpsciClock[LPSCI_GetInstance(base)]);
 890              		.loc 4 271 36
 891 011e FB68     		ldr	r3, [r7, #12]
 892 0120 1800     		movs	r0, r3
 893 0122 FFF7FEFF 		bl	LPSCI_GetInstance
 894              		.loc 4 271 5
 895 0126 4B4B     		ldr	r3, .L64+12
 896 0128 1800     		movs	r0, r3
 897 012a FFF7FEFF 		bl	CLOCK_EnableClock
 272:../drivers/fsl_lpsci.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 273:../drivers/fsl_lpsci.c **** 
 274:../drivers/fsl_lpsci.c ****     /* Disable TX RX before setting. */
 275:../drivers/fsl_lpsci.c ****     base->C2 &= ~(UART0_C2_TE_MASK | UART0_C2_RE_MASK);
 898              		.loc 4 275 14
 899 012e FB68     		ldr	r3, [r7, #12]
 900 0130 DB78     		ldrb	r3, [r3, #3]
 901 0132 DBB2     		uxtb	r3, r3
 902 0134 0C22     		movs	r2, #12
 903 0136 9343     		bics	r3, r2
 904 0138 DAB2     		uxtb	r2, r3
 905 013a FB68     		ldr	r3, [r7, #12]
 906 013c DA70     		strb	r2, [r3, #3]
 276:../drivers/fsl_lpsci.c **** 
 277:../drivers/fsl_lpsci.c ****     /* Acceptable baud rate */
 278:../drivers/fsl_lpsci.c ****     /* Check if OSR is between 4x and 7x oversampling*/
 279:../drivers/fsl_lpsci.c ****     /* If so, then "BOTHEDGE" sampling must be turned on*/
 280:../drivers/fsl_lpsci.c ****     if ((osr > 3) && (osr < 8))
 907              		.loc 4 280 8
 908 013e 7B6A     		ldr	r3, [r7, #36]
 909 0140 032B     		cmp	r3, #3
 910 0142 0AD9     		bls	.L60
 911              		.loc 4 280 19 discriminator 1
 912 0144 7B6A     		ldr	r3, [r7, #36]
 913 0146 072B     		cmp	r3, #7
 914 0148 07D8     		bhi	.L60
 281:../drivers/fsl_lpsci.c ****     {
 282:../drivers/fsl_lpsci.c ****         base->C5 |= UART0_C5_BOTHEDGE_MASK;
 915              		.loc 4 282 18
 916 014a FB68     		ldr	r3, [r7, #12]
 917 014c DB7A     		ldrb	r3, [r3, #11]
 918 014e DBB2     		uxtb	r3, r3
 919 0150 0222     		movs	r2, #2
 920 0152 1343     		orrs	r3, r2
 921 0154 DAB2     		uxtb	r2, r3
 922 0156 FB68     		ldr	r3, [r7, #12]
 923 0158 DA72     		strb	r2, [r3, #11]
 924              	.L60:
 283:../drivers/fsl_lpsci.c ****     }
 284:../drivers/fsl_lpsci.c **** 
 285:../drivers/fsl_lpsci.c ****     /* program the osr value (bit value is one less than actual value)*/
 286:../drivers/fsl_lpsci.c ****     base->C4 = ((base->C4 & ~UART0_C4_OSR_MASK) | (osr - 1));
 925              		.loc 4 286 22
 926 015a FB68     		ldr	r3, [r7, #12]
 927 015c 9B7A     		ldrb	r3, [r3, #10]
 928 015e DBB2     		uxtb	r3, r3
 929              		.loc 4 286 27
 930 0160 1F22     		movs	r2, #31
 931 0162 9343     		bics	r3, r2
 932 0164 DAB2     		uxtb	r2, r3
 933              		.loc 4 286 56
 934 0166 7B6A     		ldr	r3, [r7, #36]
 935 0168 DBB2     		uxtb	r3, r3
 936 016a 013B     		subs	r3, r3, #1
 937 016c DBB2     		uxtb	r3, r3
 938              		.loc 4 286 49
 939 016e 1343     		orrs	r3, r2
 940 0170 DAB2     		uxtb	r2, r3
 941              		.loc 4 286 14
 942 0172 FB68     		ldr	r3, [r7, #12]
 943 0174 9A72     		strb	r2, [r3, #10]
 287:../drivers/fsl_lpsci.c **** 
 288:../drivers/fsl_lpsci.c ****     /* program the sbr (divider) value obtained above*/
 289:../drivers/fsl_lpsci.c ****     base->BDH = ((base->C4 & ~UART0_BDH_SBR_MASK) | (uint8_t)(sbr >> 8));
 944              		.loc 4 289 23
 945 0176 FB68     		ldr	r3, [r7, #12]
 946 0178 9B7A     		ldrb	r3, [r3, #10]
 947 017a DBB2     		uxtb	r3, r3
 948              		.loc 4 289 28
 949 017c 1F22     		movs	r2, #31
 950 017e 9343     		bics	r3, r2
 951 0180 DAB2     		uxtb	r2, r3
 952              		.loc 4 289 53
 953 0182 2C21     		movs	r1, #44
 954 0184 7B18     		adds	r3, r7, r1
 955 0186 1B88     		ldrh	r3, [r3]
 956 0188 1B0A     		lsrs	r3, r3, #8
 957 018a 9BB2     		uxth	r3, r3
 958 018c DBB2     		uxtb	r3, r3
 959              		.loc 4 289 51
 960 018e 1343     		orrs	r3, r2
 961 0190 DAB2     		uxtb	r2, r3
 962              		.loc 4 289 15
 963 0192 FB68     		ldr	r3, [r7, #12]
 964 0194 1A70     		strb	r2, [r3]
 290:../drivers/fsl_lpsci.c ****     base->BDL = (uint8_t)sbr;
 965              		.loc 4 290 17
 966 0196 7B18     		adds	r3, r7, r1
 967 0198 1B88     		ldrh	r3, [r3]
 968 019a DAB2     		uxtb	r2, r3
 969              		.loc 4 290 15
 970 019c FB68     		ldr	r3, [r7, #12]
 971 019e 5A70     		strb	r2, [r3, #1]
 291:../drivers/fsl_lpsci.c **** 
 292:../drivers/fsl_lpsci.c ****     /* set parity mode */
 293:../drivers/fsl_lpsci.c ****     temp = base->C1 & ~(UART0_C1_PE_MASK | UART0_C1_PT_MASK | UART0_C1_M_MASK);
 972              		.loc 4 293 16
 973 01a0 FB68     		ldr	r3, [r7, #12]
 974 01a2 9B78     		ldrb	r3, [r3, #2]
 975 01a4 DAB2     		uxtb	r2, r3
 976              		.loc 4 293 10
 977 01a6 2F20     		movs	r0, #47
 978 01a8 3B18     		adds	r3, r7, r0
 979 01aa 1321     		movs	r1, #19
 980 01ac 8A43     		bics	r2, r1
 981 01ae 1A70     		strb	r2, [r3]
 294:../drivers/fsl_lpsci.c **** 
 295:../drivers/fsl_lpsci.c ****     if (kLPSCI_ParityDisabled != config->parityMode)
 982              		.loc 4 295 40
 983 01b0 BB68     		ldr	r3, [r7, #8]
 984 01b2 1B79     		ldrb	r3, [r3, #4]
 985              		.loc 4 295 8
 986 01b4 002B     		cmp	r3, #0
 987 01b6 09D0     		beq	.L61
 296:../drivers/fsl_lpsci.c ****     {
 297:../drivers/fsl_lpsci.c ****         temp |= (uint8_t)config->parityMode | UART0_C1_M_MASK;
 988              		.loc 4 297 32
 989 01b8 BB68     		ldr	r3, [r7, #8]
 990 01ba 1A79     		ldrb	r2, [r3, #4]
 991              		.loc 4 297 14
 992 01bc 3B18     		adds	r3, r7, r0
 993 01be 1B78     		ldrb	r3, [r3]
 994 01c0 1343     		orrs	r3, r2
 995 01c2 DAB2     		uxtb	r2, r3
 996 01c4 3B18     		adds	r3, r7, r0
 997 01c6 1021     		movs	r1, #16
 998 01c8 0A43     		orrs	r2, r1
 999 01ca 1A70     		strb	r2, [r3]
 1000              	.L61:
 298:../drivers/fsl_lpsci.c ****     }
 299:../drivers/fsl_lpsci.c **** 
 300:../drivers/fsl_lpsci.c ****     base->C1 = temp;
 1001              		.loc 4 300 14
 1002 01cc FB68     		ldr	r3, [r7, #12]
 1003 01ce 2F20     		movs	r0, #47
 1004 01d0 3A18     		adds	r2, r7, r0
 1005 01d2 1278     		ldrb	r2, [r2]
 1006 01d4 9A70     		strb	r2, [r3, #2]
 301:../drivers/fsl_lpsci.c **** 
 302:../drivers/fsl_lpsci.c **** #if defined(FSL_FEATURE_LPSCI_HAS_STOP_BIT_CONFIG_SUPPORT) && FSL_FEATURE_LPSCI_HAS_STOP_BIT_CONFIG
 303:../drivers/fsl_lpsci.c ****     /* set stop bit per char */
 304:../drivers/fsl_lpsci.c ****     base->BDH &= ~UART0_BDH_SBNS_MASK;
 1007              		.loc 4 304 15
 1008 01d6 FB68     		ldr	r3, [r7, #12]
 1009 01d8 1B78     		ldrb	r3, [r3]
 1010 01da DBB2     		uxtb	r3, r3
 1011 01dc 2022     		movs	r2, #32
 1012 01de 9343     		bics	r3, r2
 1013 01e0 DAB2     		uxtb	r2, r3
 1014 01e2 FB68     		ldr	r3, [r7, #12]
 1015 01e4 1A70     		strb	r2, [r3]
 305:../drivers/fsl_lpsci.c ****     base->BDH |= UART0_BDH_SBNS((uint8_t)config->stopBitCount);
 1016              		.loc 4 305 15
 1017 01e6 FB68     		ldr	r3, [r7, #12]
 1018 01e8 1B78     		ldrb	r3, [r3]
 1019 01ea DAB2     		uxtb	r2, r3
 1020              		.loc 4 305 18
 1021 01ec BB68     		ldr	r3, [r7, #8]
 1022 01ee 5B79     		ldrb	r3, [r3, #5]
 1023 01f0 5B01     		lsls	r3, r3, #5
 1024 01f2 DBB2     		uxtb	r3, r3
 1025 01f4 2021     		movs	r1, #32
 1026 01f6 0B40     		ands	r3, r1
 1027 01f8 DBB2     		uxtb	r3, r3
 1028              		.loc 4 305 15
 1029 01fa 1343     		orrs	r3, r2
 1030 01fc DAB2     		uxtb	r2, r3
 1031 01fe FB68     		ldr	r3, [r7, #12]
 1032 0200 1A70     		strb	r2, [r3]
 306:../drivers/fsl_lpsci.c **** #endif
 307:../drivers/fsl_lpsci.c **** 
 308:../drivers/fsl_lpsci.c ****     /* Enable TX/RX base on configure structure. */
 309:../drivers/fsl_lpsci.c ****     temp = base->C2;
 1033              		.loc 4 309 10
 1034 0202 3B18     		adds	r3, r7, r0
 1035 0204 FA68     		ldr	r2, [r7, #12]
 1036 0206 D278     		ldrb	r2, [r2, #3]
 1037 0208 1A70     		strb	r2, [r3]
 310:../drivers/fsl_lpsci.c **** 
 311:../drivers/fsl_lpsci.c ****     if (config->enableTx)
 1038              		.loc 4 311 15
 1039 020a BB68     		ldr	r3, [r7, #8]
 1040 020c 9B79     		ldrb	r3, [r3, #6]
 1041              		.loc 4 311 8
 1042 020e 002B     		cmp	r3, #0
 1043 0210 05D0     		beq	.L62
 312:../drivers/fsl_lpsci.c ****     {
 313:../drivers/fsl_lpsci.c ****         temp |= UART0_C2_TE_MASK;
 1044              		.loc 4 313 14
 1045 0212 3B18     		adds	r3, r7, r0
 1046 0214 3A18     		adds	r2, r7, r0
 1047 0216 1278     		ldrb	r2, [r2]
 1048 0218 0821     		movs	r1, #8
 1049 021a 0A43     		orrs	r2, r1
 1050 021c 1A70     		strb	r2, [r3]
 1051              	.L62:
 314:../drivers/fsl_lpsci.c ****     }
 315:../drivers/fsl_lpsci.c **** 
 316:../drivers/fsl_lpsci.c ****     if (config->enableRx)
 1052              		.loc 4 316 15
 1053 021e BB68     		ldr	r3, [r7, #8]
 1054 0220 DB79     		ldrb	r3, [r3, #7]
 1055              		.loc 4 316 8
 1056 0222 002B     		cmp	r3, #0
 1057 0224 06D0     		beq	.L63
 317:../drivers/fsl_lpsci.c ****     {
 318:../drivers/fsl_lpsci.c ****         temp |= UART0_C2_RE_MASK;
 1058              		.loc 4 318 14
 1059 0226 2F22     		movs	r2, #47
 1060 0228 BB18     		adds	r3, r7, r2
 1061 022a BA18     		adds	r2, r7, r2
 1062 022c 1278     		ldrb	r2, [r2]
 1063 022e 0421     		movs	r1, #4
 1064 0230 0A43     		orrs	r2, r1
 1065 0232 1A70     		strb	r2, [r3]
 1066              	.L63:
 319:../drivers/fsl_lpsci.c ****     }
 320:../drivers/fsl_lpsci.c **** 
 321:../drivers/fsl_lpsci.c ****     base->C2 = temp;
 1067              		.loc 4 321 14
 1068 0234 FB68     		ldr	r3, [r7, #12]
 1069 0236 2F22     		movs	r2, #47
 1070 0238 BA18     		adds	r2, r7, r2
 1071 023a 1278     		ldrb	r2, [r2]
 1072 023c DA70     		strb	r2, [r3, #3]
 322:../drivers/fsl_lpsci.c **** 
 323:../drivers/fsl_lpsci.c ****     return kStatus_Success;
 1073              		.loc 4 323 12
 1074 023e 0023     		movs	r3, #0
 1075              	.L59:
 324:../drivers/fsl_lpsci.c **** }
 1076              		.loc 4 324 1
 1077 0240 1800     		movs	r0, r3
 1078 0242 BD46     		mov	sp, r7
 1079 0244 0CB0     		add	sp, sp, #48
 1080              		@ sp needed
 1081 0246 B0BD     		pop	{r4, r5, r7, pc}
 1082              	.L65:
 1083              		.align	2
 1084              	.L64:
 1085 0248 00000000 		.word	.LC10
 1086 024c 1C000000 		.word	.LC12
 1087 0250 B5040000 		.word	1205
 1088 0254 0A003410 		.word	271843338
 1089              		.cfi_endproc
 1090              	.LFE68:
 1092              		.section	.text.LPSCI_Deinit,"ax",%progbits
 1093              		.align	1
 1094              		.global	LPSCI_Deinit
 1095              		.syntax unified
 1096              		.code	16
 1097              		.thumb_func
 1098              		.fpu softvfp
 1100              	LPSCI_Deinit:
 1101              	.LFB69:
 325:../drivers/fsl_lpsci.c **** 
 326:../drivers/fsl_lpsci.c **** void LPSCI_Deinit(UART0_Type *base)
 327:../drivers/fsl_lpsci.c **** {
 1102              		.loc 4 327 1
 1103              		.cfi_startproc
 1104              		@ args = 0, pretend = 0, frame = 8
 1105              		@ frame_needed = 1, uses_anonymous_args = 0
 1106 0000 80B5     		push	{r7, lr}
 1107              		.cfi_def_cfa_offset 8
 1108              		.cfi_offset 7, -8
 1109              		.cfi_offset 14, -4
 1110 0002 82B0     		sub	sp, sp, #8
 1111              		.cfi_def_cfa_offset 16
 1112 0004 00AF     		add	r7, sp, #0
 1113              		.cfi_def_cfa_register 7
 1114 0006 7860     		str	r0, [r7, #4]
 328:../drivers/fsl_lpsci.c ****     /* Wait last char out */
 329:../drivers/fsl_lpsci.c ****     while (0 == (base->S1 & UART0_S1_TC_MASK))
 1115              		.loc 4 329 11
 1116 0008 C046     		nop
 1117              	.L67:
 1118              		.loc 4 329 22 discriminator 1
 1119 000a 7B68     		ldr	r3, [r7, #4]
 1120 000c 1B79     		ldrb	r3, [r3, #4]
 1121 000e DBB2     		uxtb	r3, r3
 1122              		.loc 4 329 27 discriminator 1
 1123 0010 1A00     		movs	r2, r3
 1124 0012 4023     		movs	r3, #64
 1125 0014 1340     		ands	r3, r2
 1126              		.loc 4 329 11 discriminator 1
 1127 0016 F8D0     		beq	.L67
 330:../drivers/fsl_lpsci.c ****     {
 331:../drivers/fsl_lpsci.c ****     }
 332:../drivers/fsl_lpsci.c **** 
 333:../drivers/fsl_lpsci.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 334:../drivers/fsl_lpsci.c ****     /* Disable LPSCI clock */
 335:../drivers/fsl_lpsci.c ****     CLOCK_DisableClock(s_lpsciClock[LPSCI_GetInstance(base)]);
 1128              		.loc 4 335 37
 1129 0018 7B68     		ldr	r3, [r7, #4]
 1130 001a 1800     		movs	r0, r3
 1131 001c FFF7FEFF 		bl	LPSCI_GetInstance
 1132              		.loc 4 335 5
 1133 0020 034B     		ldr	r3, .L68
 1134 0022 1800     		movs	r0, r3
 1135 0024 FFF7FEFF 		bl	CLOCK_DisableClock
 336:../drivers/fsl_lpsci.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 337:../drivers/fsl_lpsci.c **** }
 1136              		.loc 4 337 1
 1137 0028 C046     		nop
 1138 002a BD46     		mov	sp, r7
 1139 002c 02B0     		add	sp, sp, #8
 1140              		@ sp needed
 1141 002e 80BD     		pop	{r7, pc}
 1142              	.L69:
 1143              		.align	2
 1144              	.L68:
 1145 0030 0A003410 		.word	271843338
 1146              		.cfi_endproc
 1147              	.LFE69:
 1149              		.section	.rodata.LPSCI_GetDefaultConfig.str1.4,"aMS",%progbits,1
 1150              		.align	2
 1151              	.LC14:
 1152 0000 2E66736C 		.ascii	".fsl_lpsci.c:341 : config\000"
 1152      5F6C7073 
 1152      63692E63 
 1152      3A333431 
 1152      203A2063 
 1153              		.section	.text.LPSCI_GetDefaultConfig,"ax",%progbits
 1154              		.align	1
 1155              		.global	LPSCI_GetDefaultConfig
 1156              		.syntax unified
 1157              		.code	16
 1158              		.thumb_func
 1159              		.fpu softvfp
 1161              	LPSCI_GetDefaultConfig:
 1162              	.LFB70:
 338:../drivers/fsl_lpsci.c **** 
 339:../drivers/fsl_lpsci.c **** void LPSCI_GetDefaultConfig(lpsci_config_t *config)
 340:../drivers/fsl_lpsci.c **** {
 1163              		.loc 4 340 1
 1164              		.cfi_startproc
 1165              		@ args = 0, pretend = 0, frame = 8
 1166              		@ frame_needed = 1, uses_anonymous_args = 0
 1167 0000 80B5     		push	{r7, lr}
 1168              		.cfi_def_cfa_offset 8
 1169              		.cfi_offset 7, -8
 1170              		.cfi_offset 14, -4
 1171 0002 82B0     		sub	sp, sp, #8
 1172              		.cfi_def_cfa_offset 16
 1173 0004 00AF     		add	r7, sp, #0
 1174              		.cfi_def_cfa_register 7
 1175 0006 7860     		str	r0, [r7, #4]
 341:../drivers/fsl_lpsci.c ****     assert(config);
 1176              		.loc 4 341 5
 1177 0008 7B68     		ldr	r3, [r7, #4]
 1178 000a 002B     		cmp	r3, #0
 1179 000c 03D1     		bne	.L71
 1180              		.loc 4 341 5 is_stmt 0 discriminator 1
 1181 000e 0C4B     		ldr	r3, .L72
 1182 0010 1800     		movs	r0, r3
 1183 0012 FFF7FEFF 		bl	__assertion_failed
 1184              	.L71:
 342:../drivers/fsl_lpsci.c **** 
 343:../drivers/fsl_lpsci.c ****     config->baudRate_Bps = 115200U;
 1185              		.loc 4 343 26 is_stmt 1
 1186 0016 7B68     		ldr	r3, [r7, #4]
 1187 0018 E122     		movs	r2, #225
 1188 001a 5202     		lsls	r2, r2, #9
 1189 001c 1A60     		str	r2, [r3]
 344:../drivers/fsl_lpsci.c ****     config->parityMode = kLPSCI_ParityDisabled;
 1190              		.loc 4 344 24
 1191 001e 7B68     		ldr	r3, [r7, #4]
 1192 0020 0022     		movs	r2, #0
 1193 0022 1A71     		strb	r2, [r3, #4]
 345:../drivers/fsl_lpsci.c ****     config->stopBitCount = kLPSCI_OneStopBit;
 1194              		.loc 4 345 26
 1195 0024 7B68     		ldr	r3, [r7, #4]
 1196 0026 0022     		movs	r2, #0
 1197 0028 5A71     		strb	r2, [r3, #5]
 346:../drivers/fsl_lpsci.c ****     config->enableTx = false;
 1198              		.loc 4 346 22
 1199 002a 7B68     		ldr	r3, [r7, #4]
 1200 002c 0022     		movs	r2, #0
 1201 002e 9A71     		strb	r2, [r3, #6]
 347:../drivers/fsl_lpsci.c ****     config->enableRx = false;
 1202              		.loc 4 347 22
 1203 0030 7B68     		ldr	r3, [r7, #4]
 1204 0032 0022     		movs	r2, #0
 1205 0034 DA71     		strb	r2, [r3, #7]
 348:../drivers/fsl_lpsci.c **** }
 1206              		.loc 4 348 1
 1207 0036 C046     		nop
 1208 0038 BD46     		mov	sp, r7
 1209 003a 02B0     		add	sp, sp, #8
 1210              		@ sp needed
 1211 003c 80BD     		pop	{r7, pc}
 1212              	.L73:
 1213 003e C046     		.align	2
 1214              	.L72:
 1215 0040 00000000 		.word	.LC14
 1216              		.cfi_endproc
 1217              	.LFE70:
 1219              		.section	.rodata.LPSCI_SetBaudRate.str1.4,"aMS",%progbits,1
 1220              		.align	2
 1221              	.LC16:
 1222 0000 2E66736C 		.ascii	".fsl_lpsci.c:352 : baudRate_Bps\000"
 1222      5F6C7073 
 1222      63692E63 
 1222      3A333532 
 1222      203A2062 
 1223              		.section	.text.LPSCI_SetBaudRate,"ax",%progbits
 1224              		.align	1
 1225              		.global	LPSCI_SetBaudRate
 1226              		.syntax unified
 1227              		.code	16
 1228              		.thumb_func
 1229              		.fpu softvfp
 1231              	LPSCI_SetBaudRate:
 1232              	.LFB71:
 349:../drivers/fsl_lpsci.c **** 
 350:../drivers/fsl_lpsci.c **** status_t LPSCI_SetBaudRate(UART0_Type *base, uint32_t baudRate_Bps, uint32_t srcClock_Hz)
 351:../drivers/fsl_lpsci.c **** {
 1233              		.loc 4 351 1
 1234              		.cfi_startproc
 1235              		@ args = 0, pretend = 0, frame = 48
 1236              		@ frame_needed = 1, uses_anonymous_args = 0
 1237 0000 B0B5     		push	{r4, r5, r7, lr}
 1238              		.cfi_def_cfa_offset 16
 1239              		.cfi_offset 4, -16
 1240              		.cfi_offset 5, -12
 1241              		.cfi_offset 7, -8
 1242              		.cfi_offset 14, -4
 1243 0002 8CB0     		sub	sp, sp, #48
 1244              		.cfi_def_cfa_offset 64
 1245 0004 00AF     		add	r7, sp, #0
 1246              		.cfi_def_cfa_register 7
 1247 0006 F860     		str	r0, [r7, #12]
 1248 0008 B960     		str	r1, [r7, #8]
 1249 000a 7A60     		str	r2, [r7, #4]
 352:../drivers/fsl_lpsci.c ****     assert(baudRate_Bps);
 1250              		.loc 4 352 5
 1251 000c BB68     		ldr	r3, [r7, #8]
 1252 000e 002B     		cmp	r3, #0
 1253 0010 03D1     		bne	.L75
 1254              		.loc 4 352 5 is_stmt 0 discriminator 1
 1255 0012 634B     		ldr	r3, .L84
 1256 0014 1800     		movs	r0, r3
 1257 0016 FFF7FEFF 		bl	__assertion_failed
 1258              	.L75:
 353:../drivers/fsl_lpsci.c **** 
 354:../drivers/fsl_lpsci.c ****     uint16_t sbrTemp;
 355:../drivers/fsl_lpsci.c ****     uint32_t osr = 0, sbr = 0;
 1259              		.loc 4 355 14 is_stmt 1
 1260 001a 0023     		movs	r3, #0
 1261 001c BB62     		str	r3, [r7, #40]
 1262              		.loc 4 355 23
 1263 001e 0023     		movs	r3, #0
 1264 0020 7B62     		str	r3, [r7, #36]
 356:../drivers/fsl_lpsci.c ****     uint8_t osrTemp;
 357:../drivers/fsl_lpsci.c ****     uint32_t tempDiff, calculatedBaud, baudDiff;
 358:../drivers/fsl_lpsci.c ****     uint8_t oldCtrl;
 359:../drivers/fsl_lpsci.c **** 
 360:../drivers/fsl_lpsci.c ****     /* This LPSCI instantiation uses a slightly different baud rate calculation
 361:../drivers/fsl_lpsci.c ****      * The idea is to use the best OSR (over-sampling rate) possible
 362:../drivers/fsl_lpsci.c ****      * Note, OSR is typically hard-set to 16 in other LPSCI instantiations
 363:../drivers/fsl_lpsci.c ****      * First calculate the baud rate using the minimum OSR possible (4). */
 364:../drivers/fsl_lpsci.c ****     baudDiff = baudRate_Bps;
 1265              		.loc 4 364 14
 1266 0022 BB68     		ldr	r3, [r7, #8]
 1267 0024 BB61     		str	r3, [r7, #24]
 365:../drivers/fsl_lpsci.c ****     for (osrTemp = 4; osrTemp <= 32; osrTemp++)
 1268              		.loc 4 365 18
 1269 0026 2323     		movs	r3, #35
 1270 0028 FB18     		adds	r3, r7, r3
 1271 002a 0422     		movs	r2, #4
 1272 002c 1A70     		strb	r2, [r3]
 1273              		.loc 4 365 5
 1274 002e 5FE0     		b	.L76
 1275              	.L80:
 366:../drivers/fsl_lpsci.c ****     {
 367:../drivers/fsl_lpsci.c ****         /* calculate the temporary sbr value   */
 368:../drivers/fsl_lpsci.c ****         sbrTemp = (srcClock_Hz / (baudRate_Bps * osrTemp));
 1276              		.loc 4 368 48
 1277 0030 2323     		movs	r3, #35
 1278 0032 FB18     		adds	r3, r7, r3
 1279 0034 1B78     		ldrb	r3, [r3]
 1280 0036 BA68     		ldr	r2, [r7, #8]
 1281 0038 5343     		muls	r3, r2
 1282              		.loc 4 368 32
 1283 003a 1900     		movs	r1, r3
 1284 003c 7868     		ldr	r0, [r7, #4]
 1285 003e FFF7FEFF 		bl	__aeabi_uidiv
 1286              	.LVL5:
 1287 0042 0300     		movs	r3, r0
 1288 0044 1A00     		movs	r2, r3
 1289              		.loc 4 368 17
 1290 0046 2E21     		movs	r1, #46
 1291 0048 7B18     		adds	r3, r7, r1
 1292 004a 1A80     		strh	r2, [r3]
 369:../drivers/fsl_lpsci.c ****         /* set sbrTemp to 1 if the sourceClockInHz can not satisfy the desired baud rate */
 370:../drivers/fsl_lpsci.c ****         if (sbrTemp == 0)
 1293              		.loc 4 370 12
 1294 004c 0A00     		movs	r2, r1
 1295 004e BB18     		adds	r3, r7, r2
 1296 0050 1B88     		ldrh	r3, [r3]
 1297 0052 002B     		cmp	r3, #0
 1298 0054 02D1     		bne	.L77
 371:../drivers/fsl_lpsci.c ****         {
 372:../drivers/fsl_lpsci.c ****             sbrTemp = 1;
 1299              		.loc 4 372 21
 1300 0056 BB18     		adds	r3, r7, r2
 1301 0058 0122     		movs	r2, #1
 1302 005a 1A80     		strh	r2, [r3]
 1303              	.L77:
 373:../drivers/fsl_lpsci.c ****         }
 374:../drivers/fsl_lpsci.c ****         /* Calculate the baud rate based on the temporary OSR and SBR values */
 375:../drivers/fsl_lpsci.c ****         calculatedBaud = (srcClock_Hz / (osrTemp * sbrTemp));
 1304              		.loc 4 375 50
 1305 005c 2325     		movs	r5, #35
 1306 005e 7B19     		adds	r3, r7, r5
 1307 0060 1B78     		ldrb	r3, [r3]
 1308 0062 2E24     		movs	r4, #46
 1309 0064 3A19     		adds	r2, r7, r4
 1310 0066 1288     		ldrh	r2, [r2]
 1311 0068 5343     		muls	r3, r2
 1312              		.loc 4 375 24
 1313 006a 1900     		movs	r1, r3
 1314 006c 7868     		ldr	r0, [r7, #4]
 1315 006e FFF7FEFF 		bl	__aeabi_uidiv
 1316              	.LVL6:
 1317 0072 0300     		movs	r3, r0
 1318 0074 3B61     		str	r3, [r7, #16]
 376:../drivers/fsl_lpsci.c **** 
 377:../drivers/fsl_lpsci.c ****         tempDiff = calculatedBaud - baudRate_Bps;
 1319              		.loc 4 377 18
 1320 0076 3A69     		ldr	r2, [r7, #16]
 1321 0078 BB68     		ldr	r3, [r7, #8]
 1322 007a D31A     		subs	r3, r2, r3
 1323 007c FB61     		str	r3, [r7, #28]
 378:../drivers/fsl_lpsci.c **** 
 379:../drivers/fsl_lpsci.c ****         /* Select the better value between srb and (sbr + 1) */
 380:../drivers/fsl_lpsci.c ****         if (tempDiff > (baudRate_Bps - (srcClock_Hz / (osrTemp * (sbrTemp + 1)))))
 1324              		.loc 4 380 64
 1325 007e 7B19     		adds	r3, r7, r5
 1326 0080 1B78     		ldrb	r3, [r3]
 1327              		.loc 4 380 75
 1328 0082 3A19     		adds	r2, r7, r4
 1329 0084 1288     		ldrh	r2, [r2]
 1330 0086 0132     		adds	r2, r2, #1
 1331              		.loc 4 380 64
 1332 0088 5343     		muls	r3, r2
 1333              		.loc 4 380 53
 1334 008a 1900     		movs	r1, r3
 1335 008c 7868     		ldr	r0, [r7, #4]
 1336 008e FFF7FEFF 		bl	__aeabi_uidiv
 1337              	.LVL7:
 1338 0092 0300     		movs	r3, r0
 1339 0094 1A00     		movs	r2, r3
 1340              		.loc 4 380 38
 1341 0096 BB68     		ldr	r3, [r7, #8]
 1342 0098 9B1A     		subs	r3, r3, r2
 1343              		.loc 4 380 12
 1344 009a FA69     		ldr	r2, [r7, #28]
 1345 009c 9A42     		cmp	r2, r3
 1346 009e 13D9     		bls	.L78
 381:../drivers/fsl_lpsci.c ****         {
 382:../drivers/fsl_lpsci.c ****             tempDiff = baudRate_Bps - (srcClock_Hz / (osrTemp * (sbrTemp + 1)));
 1347              		.loc 4 382 63
 1348 00a0 7B19     		adds	r3, r7, r5
 1349 00a2 1B78     		ldrb	r3, [r3]
 1350              		.loc 4 382 74
 1351 00a4 3A19     		adds	r2, r7, r4
 1352 00a6 1288     		ldrh	r2, [r2]
 1353 00a8 0132     		adds	r2, r2, #1
 1354              		.loc 4 382 63
 1355 00aa 5343     		muls	r3, r2
 1356              		.loc 4 382 52
 1357 00ac 1900     		movs	r1, r3
 1358 00ae 7868     		ldr	r0, [r7, #4]
 1359 00b0 FFF7FEFF 		bl	__aeabi_uidiv
 1360              	.LVL8:
 1361 00b4 0300     		movs	r3, r0
 1362 00b6 1A00     		movs	r2, r3
 1363              		.loc 4 382 22
 1364 00b8 BB68     		ldr	r3, [r7, #8]
 1365 00ba 9B1A     		subs	r3, r3, r2
 1366 00bc FB61     		str	r3, [r7, #28]
 383:../drivers/fsl_lpsci.c ****             sbrTemp++;
 1367              		.loc 4 383 20
 1368 00be 3B19     		adds	r3, r7, r4
 1369 00c0 1A88     		ldrh	r2, [r3]
 1370 00c2 3B19     		adds	r3, r7, r4
 1371 00c4 0132     		adds	r2, r2, #1
 1372 00c6 1A80     		strh	r2, [r3]
 1373              	.L78:
 384:../drivers/fsl_lpsci.c ****         }
 385:../drivers/fsl_lpsci.c **** 
 386:../drivers/fsl_lpsci.c ****         if (tempDiff <= baudDiff)
 1374              		.loc 4 386 12
 1375 00c8 FA69     		ldr	r2, [r7, #28]
 1376 00ca BB69     		ldr	r3, [r7, #24]
 1377 00cc 9A42     		cmp	r2, r3
 1378 00ce 09D8     		bhi	.L79
 387:../drivers/fsl_lpsci.c ****         {
 388:../drivers/fsl_lpsci.c ****             baudDiff = tempDiff;
 1379              		.loc 4 388 22
 1380 00d0 FB69     		ldr	r3, [r7, #28]
 1381 00d2 BB61     		str	r3, [r7, #24]
 389:../drivers/fsl_lpsci.c ****             osr = osrTemp; /* update and store the best OSR value calculated*/
 1382              		.loc 4 389 17
 1383 00d4 2323     		movs	r3, #35
 1384 00d6 FB18     		adds	r3, r7, r3
 1385 00d8 1B78     		ldrb	r3, [r3]
 1386 00da BB62     		str	r3, [r7, #40]
 390:../drivers/fsl_lpsci.c ****             sbr = sbrTemp; /* update store the best SBR value calculated*/
 1387              		.loc 4 390 17
 1388 00dc 2E23     		movs	r3, #46
 1389 00de FB18     		adds	r3, r7, r3
 1390 00e0 1B88     		ldrh	r3, [r3]
 1391 00e2 7B62     		str	r3, [r7, #36]
 1392              	.L79:
 365:../drivers/fsl_lpsci.c ****     {
 1393              		.loc 4 365 45 discriminator 2
 1394 00e4 2321     		movs	r1, #35
 1395 00e6 7B18     		adds	r3, r7, r1
 1396 00e8 1A78     		ldrb	r2, [r3]
 1397 00ea 7B18     		adds	r3, r7, r1
 1398 00ec 0132     		adds	r2, r2, #1
 1399 00ee 1A70     		strb	r2, [r3]
 1400              	.L76:
 365:../drivers/fsl_lpsci.c ****     {
 1401              		.loc 4 365 5 discriminator 1
 1402 00f0 2323     		movs	r3, #35
 1403 00f2 FB18     		adds	r3, r7, r3
 1404 00f4 1B78     		ldrb	r3, [r3]
 1405 00f6 202B     		cmp	r3, #32
 1406 00f8 9AD9     		bls	.L80
 391:../drivers/fsl_lpsci.c ****         }
 392:../drivers/fsl_lpsci.c ****     }
 393:../drivers/fsl_lpsci.c **** 
 394:../drivers/fsl_lpsci.c ****     /* next, check to see if actual baud rate is within 3% of desired baud rate
 395:../drivers/fsl_lpsci.c ****      * based on the best calculate OSR value */
 396:../drivers/fsl_lpsci.c ****     if (baudDiff < ((baudRate_Bps / 100) * 3))
 1407              		.loc 4 396 35
 1408 00fa BB68     		ldr	r3, [r7, #8]
 1409 00fc 6421     		movs	r1, #100
 1410 00fe 1800     		movs	r0, r3
 1411 0100 FFF7FEFF 		bl	__aeabi_uidiv
 1412              	.LVL9:
 1413 0104 0300     		movs	r3, r0
 1414 0106 1A00     		movs	r2, r3
 1415              		.loc 4 396 42
 1416 0108 1300     		movs	r3, r2
 1417 010a 5B00     		lsls	r3, r3, #1
 1418 010c 9B18     		adds	r3, r3, r2
 1419              		.loc 4 396 8
 1420 010e BA69     		ldr	r2, [r7, #24]
 1421 0110 9A42     		cmp	r2, r3
 1422 0112 40D2     		bcs	.L81
 397:../drivers/fsl_lpsci.c ****     {
 398:../drivers/fsl_lpsci.c ****         /* Store C2 before disable Tx and Rx */
 399:../drivers/fsl_lpsci.c ****         oldCtrl = base->C2;
 1423              		.loc 4 399 17
 1424 0114 1723     		movs	r3, #23
 1425 0116 FB18     		adds	r3, r7, r3
 1426 0118 FA68     		ldr	r2, [r7, #12]
 1427 011a D278     		ldrb	r2, [r2, #3]
 1428 011c 1A70     		strb	r2, [r3]
 400:../drivers/fsl_lpsci.c **** 
 401:../drivers/fsl_lpsci.c ****         /* Disable LPSCI TX RX before setting. */
 402:../drivers/fsl_lpsci.c ****         base->C2 &= ~(UART0_C2_TE_MASK | UART0_C2_RE_MASK);
 1429              		.loc 4 402 18
 1430 011e FB68     		ldr	r3, [r7, #12]
 1431 0120 DB78     		ldrb	r3, [r3, #3]
 1432 0122 DBB2     		uxtb	r3, r3
 1433 0124 0C22     		movs	r2, #12
 1434 0126 9343     		bics	r3, r2
 1435 0128 DAB2     		uxtb	r2, r3
 1436 012a FB68     		ldr	r3, [r7, #12]
 1437 012c DA70     		strb	r2, [r3, #3]
 403:../drivers/fsl_lpsci.c **** 
 404:../drivers/fsl_lpsci.c ****         /* Acceptable baud rate */
 405:../drivers/fsl_lpsci.c ****         /* Check if OSR is between 4x and 7x oversampling*/
 406:../drivers/fsl_lpsci.c ****         /* If so, then "BOTHEDGE" sampling must be turned on*/
 407:../drivers/fsl_lpsci.c ****         if ((osr > 3) && (osr < 8))
 1438              		.loc 4 407 12
 1439 012e BB6A     		ldr	r3, [r7, #40]
 1440 0130 032B     		cmp	r3, #3
 1441 0132 0AD9     		bls	.L82
 1442              		.loc 4 407 23 discriminator 1
 1443 0134 BB6A     		ldr	r3, [r7, #40]
 1444 0136 072B     		cmp	r3, #7
 1445 0138 07D8     		bhi	.L82
 408:../drivers/fsl_lpsci.c ****         {
 409:../drivers/fsl_lpsci.c ****             base->C5 |= UART0_C5_BOTHEDGE_MASK;
 1446              		.loc 4 409 22
 1447 013a FB68     		ldr	r3, [r7, #12]
 1448 013c DB7A     		ldrb	r3, [r3, #11]
 1449 013e DBB2     		uxtb	r3, r3
 1450 0140 0222     		movs	r2, #2
 1451 0142 1343     		orrs	r3, r2
 1452 0144 DAB2     		uxtb	r2, r3
 1453 0146 FB68     		ldr	r3, [r7, #12]
 1454 0148 DA72     		strb	r2, [r3, #11]
 1455              	.L82:
 410:../drivers/fsl_lpsci.c ****         }
 411:../drivers/fsl_lpsci.c **** 
 412:../drivers/fsl_lpsci.c ****         /* program the osr value (bit value is one less than actual value)*/
 413:../drivers/fsl_lpsci.c ****         base->C4 = ((base->C4 & ~UART0_C4_OSR_MASK) | (osr - 1));
 1456              		.loc 4 413 26
 1457 014a FB68     		ldr	r3, [r7, #12]
 1458 014c 9B7A     		ldrb	r3, [r3, #10]
 1459 014e DBB2     		uxtb	r3, r3
 1460              		.loc 4 413 31
 1461 0150 1F22     		movs	r2, #31
 1462 0152 9343     		bics	r3, r2
 1463 0154 DAB2     		uxtb	r2, r3
 1464              		.loc 4 413 60
 1465 0156 BB6A     		ldr	r3, [r7, #40]
 1466 0158 DBB2     		uxtb	r3, r3
 1467 015a 013B     		subs	r3, r3, #1
 1468 015c DBB2     		uxtb	r3, r3
 1469              		.loc 4 413 53
 1470 015e 1343     		orrs	r3, r2
 1471 0160 DAB2     		uxtb	r2, r3
 1472              		.loc 4 413 18
 1473 0162 FB68     		ldr	r3, [r7, #12]
 1474 0164 9A72     		strb	r2, [r3, #10]
 414:../drivers/fsl_lpsci.c **** 
 415:../drivers/fsl_lpsci.c ****         /* program the sbr (divider) value obtained above*/
 416:../drivers/fsl_lpsci.c ****         base->BDH = ((base->C4 & ~UART0_BDH_SBR_MASK) | (uint8_t)(sbr >> 8));
 1475              		.loc 4 416 27
 1476 0166 FB68     		ldr	r3, [r7, #12]
 1477 0168 9B7A     		ldrb	r3, [r3, #10]
 1478 016a DBB2     		uxtb	r3, r3
 1479              		.loc 4 416 32
 1480 016c 1F22     		movs	r2, #31
 1481 016e 9343     		bics	r3, r2
 1482 0170 DAB2     		uxtb	r2, r3
 1483              		.loc 4 416 71
 1484 0172 7B6A     		ldr	r3, [r7, #36]
 1485 0174 1B0A     		lsrs	r3, r3, #8
 1486              		.loc 4 416 57
 1487 0176 DBB2     		uxtb	r3, r3
 1488              		.loc 4 416 55
 1489 0178 1343     		orrs	r3, r2
 1490 017a DAB2     		uxtb	r2, r3
 1491              		.loc 4 416 19
 1492 017c FB68     		ldr	r3, [r7, #12]
 1493 017e 1A70     		strb	r2, [r3]
 417:../drivers/fsl_lpsci.c ****         base->BDL = (uint8_t)sbr;
 1494              		.loc 4 417 21
 1495 0180 7B6A     		ldr	r3, [r7, #36]
 1496 0182 DAB2     		uxtb	r2, r3
 1497              		.loc 4 417 19
 1498 0184 FB68     		ldr	r3, [r7, #12]
 1499 0186 5A70     		strb	r2, [r3, #1]
 418:../drivers/fsl_lpsci.c **** 
 419:../drivers/fsl_lpsci.c ****         /* Restore C2. */
 420:../drivers/fsl_lpsci.c ****         base->C2 = oldCtrl;
 1500              		.loc 4 420 18
 1501 0188 FB68     		ldr	r3, [r7, #12]
 1502 018a 1722     		movs	r2, #23
 1503 018c BA18     		adds	r2, r7, r2
 1504 018e 1278     		ldrb	r2, [r2]
 1505 0190 DA70     		strb	r2, [r3, #3]
 421:../drivers/fsl_lpsci.c **** 
 422:../drivers/fsl_lpsci.c ****         return kStatus_Success;
 1506              		.loc 4 422 16
 1507 0192 0023     		movs	r3, #0
 1508 0194 00E0     		b	.L83
 1509              	.L81:
 423:../drivers/fsl_lpsci.c ****     }
 424:../drivers/fsl_lpsci.c ****     else
 425:../drivers/fsl_lpsci.c ****     {
 426:../drivers/fsl_lpsci.c ****         /* Unacceptable baud rate difference of more than 3%*/
 427:../drivers/fsl_lpsci.c ****         return kStatus_LPSCI_BaudrateNotSupport;
 1510              		.loc 4 427 16
 1511 0196 034B     		ldr	r3, .L84+4
 1512              	.L83:
 428:../drivers/fsl_lpsci.c ****     }
 429:../drivers/fsl_lpsci.c **** }
 1513              		.loc 4 429 1
 1514 0198 1800     		movs	r0, r3
 1515 019a BD46     		mov	sp, r7
 1516 019c 0CB0     		add	sp, sp, #48
 1517              		@ sp needed
 1518 019e B0BD     		pop	{r4, r5, r7, pc}
 1519              	.L85:
 1520              		.align	2
 1521              	.L84:
 1522 01a0 00000000 		.word	.LC16
 1523 01a4 B5040000 		.word	1205
 1524              		.cfi_endproc
 1525              	.LFE71:
 1527              		.section	.text.LPSCI_EnableInterrupts,"ax",%progbits
 1528              		.align	1
 1529              		.global	LPSCI_EnableInterrupts
 1530              		.syntax unified
 1531              		.code	16
 1532              		.thumb_func
 1533              		.fpu softvfp
 1535              	LPSCI_EnableInterrupts:
 1536              	.LFB72:
 430:../drivers/fsl_lpsci.c **** 
 431:../drivers/fsl_lpsci.c **** void LPSCI_EnableInterrupts(UART0_Type *base, uint32_t mask)
 432:../drivers/fsl_lpsci.c **** {
 1537              		.loc 4 432 1
 1538              		.cfi_startproc
 1539              		@ args = 0, pretend = 0, frame = 8
 1540              		@ frame_needed = 1, uses_anonymous_args = 0
 1541 0000 80B5     		push	{r7, lr}
 1542              		.cfi_def_cfa_offset 8
 1543              		.cfi_offset 7, -8
 1544              		.cfi_offset 14, -4
 1545 0002 82B0     		sub	sp, sp, #8
 1546              		.cfi_def_cfa_offset 16
 1547 0004 00AF     		add	r7, sp, #0
 1548              		.cfi_def_cfa_register 7
 1549 0006 7860     		str	r0, [r7, #4]
 1550 0008 3960     		str	r1, [r7]
 433:../drivers/fsl_lpsci.c ****     mask &= kLPSCI_AllInterruptsEnable;
 1551              		.loc 4 433 10
 1552 000a 3B68     		ldr	r3, [r7]
 1553 000c 114A     		ldr	r2, .L87
 1554 000e 1340     		ands	r3, r2
 1555 0010 3B60     		str	r3, [r7]
 434:../drivers/fsl_lpsci.c **** 
 435:../drivers/fsl_lpsci.c ****     /* The interrupt mask is combined by control bits from several register: ((C3<<16) | (C2<<8) |(
 436:../drivers/fsl_lpsci.c ****      */
 437:../drivers/fsl_lpsci.c ****     base->BDH |= mask;
 1556              		.loc 4 437 15
 1557 0012 7B68     		ldr	r3, [r7, #4]
 1558 0014 1B78     		ldrb	r3, [r3]
 1559 0016 DAB2     		uxtb	r2, r3
 1560 0018 3B68     		ldr	r3, [r7]
 1561 001a DBB2     		uxtb	r3, r3
 1562 001c 1343     		orrs	r3, r2
 1563 001e DAB2     		uxtb	r2, r3
 1564 0020 7B68     		ldr	r3, [r7, #4]
 1565 0022 1A70     		strb	r2, [r3]
 438:../drivers/fsl_lpsci.c ****     base->C2 |= (mask >> 8);
 1566              		.loc 4 438 14
 1567 0024 7B68     		ldr	r3, [r7, #4]
 1568 0026 DB78     		ldrb	r3, [r3, #3]
 1569 0028 DAB2     		uxtb	r2, r3
 1570              		.loc 4 438 23
 1571 002a 3B68     		ldr	r3, [r7]
 1572 002c 1B0A     		lsrs	r3, r3, #8
 1573              		.loc 4 438 14
 1574 002e DBB2     		uxtb	r3, r3
 1575 0030 1343     		orrs	r3, r2
 1576 0032 DAB2     		uxtb	r2, r3
 1577 0034 7B68     		ldr	r3, [r7, #4]
 1578 0036 DA70     		strb	r2, [r3, #3]
 439:../drivers/fsl_lpsci.c ****     base->C3 |= (mask >> 16);
 1579              		.loc 4 439 14
 1580 0038 7B68     		ldr	r3, [r7, #4]
 1581 003a 9B79     		ldrb	r3, [r3, #6]
 1582 003c DAB2     		uxtb	r2, r3
 1583              		.loc 4 439 23
 1584 003e 3B68     		ldr	r3, [r7]
 1585 0040 1B0C     		lsrs	r3, r3, #16
 1586              		.loc 4 439 14
 1587 0042 DBB2     		uxtb	r3, r3
 1588 0044 1343     		orrs	r3, r2
 1589 0046 DAB2     		uxtb	r2, r3
 1590 0048 7B68     		ldr	r3, [r7, #4]
 1591 004a 9A71     		strb	r2, [r3, #6]
 440:../drivers/fsl_lpsci.c **** }
 1592              		.loc 4 440 1
 1593 004c C046     		nop
 1594 004e BD46     		mov	sp, r7
 1595 0050 02B0     		add	sp, sp, #8
 1596              		@ sp needed
 1597 0052 80BD     		pop	{r7, pc}
 1598              	.L88:
 1599              		.align	2
 1600              	.L87:
 1601 0054 C0F00F00 		.word	1044672
 1602              		.cfi_endproc
 1603              	.LFE72:
 1605              		.section	.text.LPSCI_DisableInterrupts,"ax",%progbits
 1606              		.align	1
 1607              		.global	LPSCI_DisableInterrupts
 1608              		.syntax unified
 1609              		.code	16
 1610              		.thumb_func
 1611              		.fpu softvfp
 1613              	LPSCI_DisableInterrupts:
 1614              	.LFB73:
 441:../drivers/fsl_lpsci.c **** 
 442:../drivers/fsl_lpsci.c **** void LPSCI_DisableInterrupts(UART0_Type *base, uint32_t mask)
 443:../drivers/fsl_lpsci.c **** {
 1615              		.loc 4 443 1
 1616              		.cfi_startproc
 1617              		@ args = 0, pretend = 0, frame = 8
 1618              		@ frame_needed = 1, uses_anonymous_args = 0
 1619 0000 80B5     		push	{r7, lr}
 1620              		.cfi_def_cfa_offset 8
 1621              		.cfi_offset 7, -8
 1622              		.cfi_offset 14, -4
 1623 0002 82B0     		sub	sp, sp, #8
 1624              		.cfi_def_cfa_offset 16
 1625 0004 00AF     		add	r7, sp, #0
 1626              		.cfi_def_cfa_register 7
 1627 0006 7860     		str	r0, [r7, #4]
 1628 0008 3960     		str	r1, [r7]
 444:../drivers/fsl_lpsci.c ****     mask &= kLPSCI_AllInterruptsEnable;
 1629              		.loc 4 444 10
 1630 000a 3B68     		ldr	r3, [r7]
 1631 000c 144A     		ldr	r2, .L90
 1632 000e 1340     		ands	r3, r2
 1633 0010 3B60     		str	r3, [r7]
 445:../drivers/fsl_lpsci.c **** 
 446:../drivers/fsl_lpsci.c ****     /* The interrupt mask is combined by control bits from several register: ((C3<<16) | (C2<<8) |(
 447:../drivers/fsl_lpsci.c ****      */
 448:../drivers/fsl_lpsci.c ****     base->BDH &= ~mask;
 1634              		.loc 4 448 15
 1635 0012 7B68     		ldr	r3, [r7, #4]
 1636 0014 1B78     		ldrb	r3, [r3]
 1637 0016 DBB2     		uxtb	r3, r3
 1638 0018 3A68     		ldr	r2, [r7]
 1639 001a D2B2     		uxtb	r2, r2
 1640 001c D243     		mvns	r2, r2
 1641 001e D2B2     		uxtb	r2, r2
 1642 0020 1340     		ands	r3, r2
 1643 0022 DAB2     		uxtb	r2, r3
 1644 0024 7B68     		ldr	r3, [r7, #4]
 1645 0026 1A70     		strb	r2, [r3]
 449:../drivers/fsl_lpsci.c ****     base->C2 &= ~(mask >> 8);
 1646              		.loc 4 449 14
 1647 0028 7B68     		ldr	r3, [r7, #4]
 1648 002a DB78     		ldrb	r3, [r3, #3]
 1649 002c DBB2     		uxtb	r3, r3
 1650              		.loc 4 449 24
 1651 002e 3A68     		ldr	r2, [r7]
 1652 0030 120A     		lsrs	r2, r2, #8
 1653              		.loc 4 449 14
 1654 0032 D2B2     		uxtb	r2, r2
 1655 0034 D243     		mvns	r2, r2
 1656 0036 D2B2     		uxtb	r2, r2
 1657 0038 1340     		ands	r3, r2
 1658 003a DAB2     		uxtb	r2, r3
 1659 003c 7B68     		ldr	r3, [r7, #4]
 1660 003e DA70     		strb	r2, [r3, #3]
 450:../drivers/fsl_lpsci.c ****     base->C3 &= ~(mask >> 16);
 1661              		.loc 4 450 14
 1662 0040 7B68     		ldr	r3, [r7, #4]
 1663 0042 9B79     		ldrb	r3, [r3, #6]
 1664 0044 DBB2     		uxtb	r3, r3
 1665              		.loc 4 450 24
 1666 0046 3A68     		ldr	r2, [r7]
 1667 0048 120C     		lsrs	r2, r2, #16
 1668              		.loc 4 450 14
 1669 004a D2B2     		uxtb	r2, r2
 1670 004c D243     		mvns	r2, r2
 1671 004e D2B2     		uxtb	r2, r2
 1672 0050 1340     		ands	r3, r2
 1673 0052 DAB2     		uxtb	r2, r3
 1674 0054 7B68     		ldr	r3, [r7, #4]
 1675 0056 9A71     		strb	r2, [r3, #6]
 451:../drivers/fsl_lpsci.c **** }
 1676              		.loc 4 451 1
 1677 0058 C046     		nop
 1678 005a BD46     		mov	sp, r7
 1679 005c 02B0     		add	sp, sp, #8
 1680              		@ sp needed
 1681 005e 80BD     		pop	{r7, pc}
 1682              	.L91:
 1683              		.align	2
 1684              	.L90:
 1685 0060 C0F00F00 		.word	1044672
 1686              		.cfi_endproc
 1687              	.LFE73:
 1689              		.section	.text.LPSCI_GetEnabledInterrupts,"ax",%progbits
 1690              		.align	1
 1691              		.global	LPSCI_GetEnabledInterrupts
 1692              		.syntax unified
 1693              		.code	16
 1694              		.thumb_func
 1695              		.fpu softvfp
 1697              	LPSCI_GetEnabledInterrupts:
 1698              	.LFB74:
 452:../drivers/fsl_lpsci.c **** 
 453:../drivers/fsl_lpsci.c **** uint32_t LPSCI_GetEnabledInterrupts(UART0_Type *base)
 454:../drivers/fsl_lpsci.c **** {
 1699              		.loc 4 454 1
 1700              		.cfi_startproc
 1701              		@ args = 0, pretend = 0, frame = 16
 1702              		@ frame_needed = 1, uses_anonymous_args = 0
 1703 0000 80B5     		push	{r7, lr}
 1704              		.cfi_def_cfa_offset 8
 1705              		.cfi_offset 7, -8
 1706              		.cfi_offset 14, -4
 1707 0002 84B0     		sub	sp, sp, #16
 1708              		.cfi_def_cfa_offset 24
 1709 0004 00AF     		add	r7, sp, #0
 1710              		.cfi_def_cfa_register 7
 1711 0006 7860     		str	r0, [r7, #4]
 455:../drivers/fsl_lpsci.c ****     uint32_t temp;
 456:../drivers/fsl_lpsci.c ****     temp = base->BDH | ((uint32_t)(base->C2) << 8) | ((uint32_t)(base->C3) << 16);
 1712              		.loc 4 456 16
 1713 0008 7B68     		ldr	r3, [r7, #4]
 1714 000a 1B78     		ldrb	r3, [r3]
 1715 000c DBB2     		uxtb	r3, r3
 1716 000e 1A00     		movs	r2, r3
 1717              		.loc 4 456 40
 1718 0010 7B68     		ldr	r3, [r7, #4]
 1719 0012 DB78     		ldrb	r3, [r3, #3]
 1720 0014 DBB2     		uxtb	r3, r3
 1721              		.loc 4 456 46
 1722 0016 1B02     		lsls	r3, r3, #8
 1723              		.loc 4 456 22
 1724 0018 1A43     		orrs	r2, r3
 1725              		.loc 4 456 70
 1726 001a 7B68     		ldr	r3, [r7, #4]
 1727 001c 9B79     		ldrb	r3, [r3, #6]
 1728 001e DBB2     		uxtb	r3, r3
 1729              		.loc 4 456 76
 1730 0020 1B04     		lsls	r3, r3, #16
 1731              		.loc 4 456 10
 1732 0022 1343     		orrs	r3, r2
 1733 0024 FB60     		str	r3, [r7, #12]
 457:../drivers/fsl_lpsci.c **** 
 458:../drivers/fsl_lpsci.c ****     return temp & kLPSCI_AllInterruptsEnable;
 1734              		.loc 4 458 17
 1735 0026 FB68     		ldr	r3, [r7, #12]
 1736 0028 024A     		ldr	r2, .L94
 1737 002a 1340     		ands	r3, r2
 459:../drivers/fsl_lpsci.c **** }
 1738              		.loc 4 459 1
 1739 002c 1800     		movs	r0, r3
 1740 002e BD46     		mov	sp, r7
 1741 0030 04B0     		add	sp, sp, #16
 1742              		@ sp needed
 1743 0032 80BD     		pop	{r7, pc}
 1744              	.L95:
 1745              		.align	2
 1746              	.L94:
 1747 0034 C0F00F00 		.word	1044672
 1748              		.cfi_endproc
 1749              	.LFE74:
 1751              		.section	.text.LPSCI_GetStatusFlags,"ax",%progbits
 1752              		.align	1
 1753              		.global	LPSCI_GetStatusFlags
 1754              		.syntax unified
 1755              		.code	16
 1756              		.thumb_func
 1757              		.fpu softvfp
 1759              	LPSCI_GetStatusFlags:
 1760              	.LFB75:
 460:../drivers/fsl_lpsci.c **** 
 461:../drivers/fsl_lpsci.c **** uint32_t LPSCI_GetStatusFlags(UART0_Type *base)
 462:../drivers/fsl_lpsci.c **** {
 1761              		.loc 4 462 1
 1762              		.cfi_startproc
 1763              		@ args = 0, pretend = 0, frame = 16
 1764              		@ frame_needed = 1, uses_anonymous_args = 0
 1765 0000 80B5     		push	{r7, lr}
 1766              		.cfi_def_cfa_offset 8
 1767              		.cfi_offset 7, -8
 1768              		.cfi_offset 14, -4
 1769 0002 84B0     		sub	sp, sp, #16
 1770              		.cfi_def_cfa_offset 24
 1771 0004 00AF     		add	r7, sp, #0
 1772              		.cfi_def_cfa_register 7
 1773 0006 7860     		str	r0, [r7, #4]
 463:../drivers/fsl_lpsci.c ****     uint32_t status_flag;
 464:../drivers/fsl_lpsci.c ****     status_flag = base->S1 | ((uint32_t)(base->S2) << 8);
 1774              		.loc 4 464 23
 1775 0008 7B68     		ldr	r3, [r7, #4]
 1776 000a 1B79     		ldrb	r3, [r3, #4]
 1777 000c DBB2     		uxtb	r3, r3
 1778 000e 1A00     		movs	r2, r3
 1779              		.loc 4 464 46
 1780 0010 7B68     		ldr	r3, [r7, #4]
 1781 0012 5B79     		ldrb	r3, [r3, #5]
 1782 0014 DBB2     		uxtb	r3, r3
 1783              		.loc 4 464 52
 1784 0016 1B02     		lsls	r3, r3, #8
 1785              		.loc 4 464 17
 1786 0018 1343     		orrs	r3, r2
 1787 001a FB60     		str	r3, [r7, #12]
 465:../drivers/fsl_lpsci.c **** 
 466:../drivers/fsl_lpsci.c **** #if defined(FSL_FEATURE_LPSCI_HAS_EXTENDED_DATA_REGISTER_FLAGS) && FSL_FEATURE_LPSCI_HAS_EXTENDED_D
 467:../drivers/fsl_lpsci.c ****     status_flag |= ((uint32_t)(base->ED) << 16);
 468:../drivers/fsl_lpsci.c **** #endif
 469:../drivers/fsl_lpsci.c **** 
 470:../drivers/fsl_lpsci.c ****     return status_flag;
 1788              		.loc 4 470 12
 1789 001c FB68     		ldr	r3, [r7, #12]
 471:../drivers/fsl_lpsci.c **** }
 1790              		.loc 4 471 1
 1791 001e 1800     		movs	r0, r3
 1792 0020 BD46     		mov	sp, r7
 1793 0022 04B0     		add	sp, sp, #16
 1794              		@ sp needed
 1795 0024 80BD     		pop	{r7, pc}
 1796              		.cfi_endproc
 1797              	.LFE75:
 1799              		.section	.text.LPSCI_ClearStatusFlags,"ax",%progbits
 1800              		.align	1
 1801              		.global	LPSCI_ClearStatusFlags
 1802              		.syntax unified
 1803              		.code	16
 1804              		.thumb_func
 1805              		.fpu softvfp
 1807              	LPSCI_ClearStatusFlags:
 1808              	.LFB76:
 472:../drivers/fsl_lpsci.c **** 
 473:../drivers/fsl_lpsci.c **** status_t LPSCI_ClearStatusFlags(UART0_Type *base, uint32_t mask)
 474:../drivers/fsl_lpsci.c **** {
 1809              		.loc 4 474 1
 1810              		.cfi_startproc
 1811              		@ args = 0, pretend = 0, frame = 16
 1812              		@ frame_needed = 1, uses_anonymous_args = 0
 1813 0000 80B5     		push	{r7, lr}
 1814              		.cfi_def_cfa_offset 8
 1815              		.cfi_offset 7, -8
 1816              		.cfi_offset 14, -4
 1817 0002 84B0     		sub	sp, sp, #16
 1818              		.cfi_def_cfa_offset 24
 1819 0004 00AF     		add	r7, sp, #0
 1820              		.cfi_def_cfa_register 7
 1821 0006 7860     		str	r0, [r7, #4]
 1822 0008 3960     		str	r1, [r7]
 475:../drivers/fsl_lpsci.c ****     volatile uint8_t dummy = 0;
 1823              		.loc 4 475 22
 1824 000a 0B21     		movs	r1, #11
 1825 000c 7B18     		adds	r3, r7, r1
 1826 000e 0022     		movs	r2, #0
 1827 0010 1A70     		strb	r2, [r3]
 476:../drivers/fsl_lpsci.c ****     status_t status;
 477:../drivers/fsl_lpsci.c ****     dummy++; /* For unused variable warning */
 1828              		.loc 4 477 10
 1829 0012 7B18     		adds	r3, r7, r1
 1830 0014 1B78     		ldrb	r3, [r3]
 1831 0016 DBB2     		uxtb	r3, r3
 1832 0018 0133     		adds	r3, r3, #1
 1833 001a DAB2     		uxtb	r2, r3
 1834 001c 7B18     		adds	r3, r7, r1
 1835 001e 1A70     		strb	r2, [r3]
 478:../drivers/fsl_lpsci.c **** 
 479:../drivers/fsl_lpsci.c **** #if defined(FSL_FEATURE_LPSCI_HAS_LIN_BREAK_DETECT) && FSL_FEATURE_LPSCI_HAS_LIN_BREAK_DETECT
 480:../drivers/fsl_lpsci.c ****     if (mask & kLPSCI_LinBreakFlag)
 1836              		.loc 4 480 14
 1837 0020 3A68     		ldr	r2, [r7]
 1838 0022 8023     		movs	r3, #128
 1839 0024 1B02     		lsls	r3, r3, #8
 1840 0026 1340     		ands	r3, r2
 1841              		.loc 4 480 8
 1842 0028 06D0     		beq	.L99
 481:../drivers/fsl_lpsci.c ****     {
 482:../drivers/fsl_lpsci.c ****         base->S2 = UART0_S2_LBKDIF_MASK;
 1843              		.loc 4 482 18
 1844 002a 7B68     		ldr	r3, [r7, #4]
 1845 002c 8022     		movs	r2, #128
 1846 002e 5A71     		strb	r2, [r3, #5]
 483:../drivers/fsl_lpsci.c ****         mask &= ~(uint32_t)kLPSCI_LinBreakFlag;
 1847              		.loc 4 483 14
 1848 0030 3B68     		ldr	r3, [r7]
 1849 0032 154A     		ldr	r2, .L105
 1850 0034 1340     		ands	r3, r2
 1851 0036 3B60     		str	r3, [r7]
 1852              	.L99:
 484:../drivers/fsl_lpsci.c ****     }
 485:../drivers/fsl_lpsci.c **** #endif
 486:../drivers/fsl_lpsci.c **** 
 487:../drivers/fsl_lpsci.c ****     if (mask & kLPSCI_RxActiveEdgeFlag)
 1853              		.loc 4 487 14
 1854 0038 3A68     		ldr	r2, [r7]
 1855 003a 8023     		movs	r3, #128
 1856 003c DB01     		lsls	r3, r3, #7
 1857 003e 1340     		ands	r3, r2
 1858              		.loc 4 487 8
 1859 0040 06D0     		beq	.L100
 488:../drivers/fsl_lpsci.c ****     {
 489:../drivers/fsl_lpsci.c ****         base->S2 = UART0_S2_RXEDGIF_MASK;
 1860              		.loc 4 489 18
 1861 0042 7B68     		ldr	r3, [r7, #4]
 1862 0044 4022     		movs	r2, #64
 1863 0046 5A71     		strb	r2, [r3, #5]
 490:../drivers/fsl_lpsci.c ****         mask &= ~(uint32_t)kLPSCI_RxActiveEdgeFlag;
 1864              		.loc 4 490 14
 1865 0048 3B68     		ldr	r3, [r7]
 1866 004a 104A     		ldr	r2, .L105+4
 1867 004c 1340     		ands	r3, r2
 1868 004e 3B60     		str	r3, [r7]
 1869              	.L100:
 491:../drivers/fsl_lpsci.c ****     }
 492:../drivers/fsl_lpsci.c **** 
 493:../drivers/fsl_lpsci.c ****     if ((mask & (kLPSCI_IdleLineFlag | kLPSCI_RxOverrunFlag | kLPSCI_NoiseErrorFlag | kLPSCI_Framin
 1870              		.loc 4 493 15
 1871 0050 3B68     		ldr	r3, [r7]
 1872 0052 1F22     		movs	r2, #31
 1873 0054 1340     		ands	r3, r2
 1874              		.loc 4 493 8
 1875 0056 0AD0     		beq	.L101
 494:../drivers/fsl_lpsci.c ****                  kLPSCI_ParityErrorFlag)))
 495:../drivers/fsl_lpsci.c ****     {
 496:../drivers/fsl_lpsci.c ****         base->S1 = (mask & (kLPSCI_IdleLineFlag | kLPSCI_RxOverrunFlag | kLPSCI_NoiseErrorFlag |
 1876              		.loc 4 496 26
 1877 0058 3B68     		ldr	r3, [r7]
 1878 005a DBB2     		uxtb	r3, r3
 1879 005c 1F22     		movs	r2, #31
 1880 005e 1340     		ands	r3, r2
 1881 0060 DAB2     		uxtb	r2, r3
 1882              		.loc 4 496 18
 1883 0062 7B68     		ldr	r3, [r7, #4]
 1884 0064 1A71     		strb	r2, [r3, #4]
 497:../drivers/fsl_lpsci.c ****                             kLPSCI_FramingErrorFlag | kLPSCI_ParityErrorFlag));
 498:../drivers/fsl_lpsci.c ****         mask &= ~(uint32_t)(kLPSCI_IdleLineFlag | kLPSCI_RxOverrunFlag | kLPSCI_NoiseErrorFlag |
 1885              		.loc 4 498 14
 1886 0066 3B68     		ldr	r3, [r7]
 1887 0068 1F22     		movs	r2, #31
 1888 006a 9343     		bics	r3, r2
 1889 006c 3B60     		str	r3, [r7]
 1890              	.L101:
 499:../drivers/fsl_lpsci.c ****                             kLPSCI_FramingErrorFlag | kLPSCI_ParityErrorFlag);
 500:../drivers/fsl_lpsci.c ****     }
 501:../drivers/fsl_lpsci.c **** 
 502:../drivers/fsl_lpsci.c ****     if (mask)
 1891              		.loc 4 502 8
 1892 006e 3B68     		ldr	r3, [r7]
 1893 0070 002B     		cmp	r3, #0
 1894 0072 02D0     		beq	.L102
 503:../drivers/fsl_lpsci.c ****     {
 504:../drivers/fsl_lpsci.c ****         /* Some flags can only clear or set by the hardware itself, these flags are: kLPSCI_TxDataR
 505:../drivers/fsl_lpsci.c ****         kLPSCI_TransmissionCompleteFlag, kLPSCI_RxDataRegFullFlag, kLPSCI_RxActiveFlag,
 506:../drivers/fsl_lpsci.c ****         kLPSCI_NoiseErrorInRxDataRegFlag,
 507:../drivers/fsl_lpsci.c ****         kLPSCI_ParityErrorInRxDataRegFlag*/
 508:../drivers/fsl_lpsci.c **** 
 509:../drivers/fsl_lpsci.c ****         status = kStatus_LPSCI_FlagCannotClearManually;
 1895              		.loc 4 509 16
 1896 0074 064B     		ldr	r3, .L105+8
 1897 0076 FB60     		str	r3, [r7, #12]
 1898 0078 01E0     		b	.L103
 1899              	.L102:
 510:../drivers/fsl_lpsci.c ****     }
 511:../drivers/fsl_lpsci.c ****     else
 512:../drivers/fsl_lpsci.c ****     {
 513:../drivers/fsl_lpsci.c ****         status = kStatus_Success;
 1900              		.loc 4 513 16
 1901 007a 0023     		movs	r3, #0
 1902 007c FB60     		str	r3, [r7, #12]
 1903              	.L103:
 514:../drivers/fsl_lpsci.c ****     }
 515:../drivers/fsl_lpsci.c **** 
 516:../drivers/fsl_lpsci.c ****     return status;
 1904              		.loc 4 516 12
 1905 007e FB68     		ldr	r3, [r7, #12]
 517:../drivers/fsl_lpsci.c **** }
 1906              		.loc 4 517 1
 1907 0080 1800     		movs	r0, r3
 1908 0082 BD46     		mov	sp, r7
 1909 0084 04B0     		add	sp, sp, #16
 1910              		@ sp needed
 1911 0086 80BD     		pop	{r7, pc}
 1912              	.L106:
 1913              		.align	2
 1914              	.L105:
 1915 0088 FF7FFFFF 		.word	-32769
 1916 008c FFBFFFFF 		.word	-16385
 1917 0090 B4040000 		.word	1204
 1918              		.cfi_endproc
 1919              	.LFE76:
 1921              		.section	.rodata.LPSCI_WriteBlocking.str1.4,"aMS",%progbits,1
 1922              		.align	2
 1923              	.LC18:
 1924 0000 2E66736C 		.ascii	".fsl_lpsci.c:521 : data\000"
 1924      5F6C7073 
 1924      63692E63 
 1924      3A353231 
 1924      203A2064 
 1925              		.section	.text.LPSCI_WriteBlocking,"ax",%progbits
 1926              		.align	1
 1927              		.global	LPSCI_WriteBlocking
 1928              		.syntax unified
 1929              		.code	16
 1930              		.thumb_func
 1931              		.fpu softvfp
 1933              	LPSCI_WriteBlocking:
 1934              	.LFB77:
 518:../drivers/fsl_lpsci.c **** 
 519:../drivers/fsl_lpsci.c **** void LPSCI_WriteBlocking(UART0_Type *base, const uint8_t *data, size_t length)
 520:../drivers/fsl_lpsci.c **** {
 1935              		.loc 4 520 1
 1936              		.cfi_startproc
 1937              		@ args = 0, pretend = 0, frame = 16
 1938              		@ frame_needed = 1, uses_anonymous_args = 0
 1939 0000 80B5     		push	{r7, lr}
 1940              		.cfi_def_cfa_offset 8
 1941              		.cfi_offset 7, -8
 1942              		.cfi_offset 14, -4
 1943 0002 84B0     		sub	sp, sp, #16
 1944              		.cfi_def_cfa_offset 24
 1945 0004 00AF     		add	r7, sp, #0
 1946              		.cfi_def_cfa_register 7
 1947 0006 F860     		str	r0, [r7, #12]
 1948 0008 B960     		str	r1, [r7, #8]
 1949 000a 7A60     		str	r2, [r7, #4]
 521:../drivers/fsl_lpsci.c ****     assert(data);
 1950              		.loc 4 521 5
 1951 000c BB68     		ldr	r3, [r7, #8]
 1952 000e 002B     		cmp	r3, #0
 1953 0010 10D1     		bne	.L109
 1954              		.loc 4 521 5 is_stmt 0 discriminator 1
 1955 0012 0D4B     		ldr	r3, .L112
 1956 0014 1800     		movs	r0, r3
 1957 0016 FFF7FEFF 		bl	__assertion_failed
 1958              	.L111:
 522:../drivers/fsl_lpsci.c **** 
 523:../drivers/fsl_lpsci.c ****     /* This API can only ensure that the data is written into the data buffer but can't
 524:../drivers/fsl_lpsci.c ****     ensure all data in the data buffer are sent into the transmit shift buffer. */
 525:../drivers/fsl_lpsci.c ****     while (length--)
 526:../drivers/fsl_lpsci.c ****     {
 527:../drivers/fsl_lpsci.c ****         while (!(base->S1 & UART0_S1_TDRE_MASK))
 1959              		.loc 4 527 15 is_stmt 1
 1960 001a C046     		nop
 1961              	.L110:
 1962              		.loc 4 527 22 discriminator 1
 1963 001c FB68     		ldr	r3, [r7, #12]
 1964 001e 1B79     		ldrb	r3, [r3, #4]
 1965 0020 DBB2     		uxtb	r3, r3
 1966              		.loc 4 527 16 discriminator 1
 1967 0022 5BB2     		sxtb	r3, r3
 1968              		.loc 4 527 15 discriminator 1
 1969 0024 002B     		cmp	r3, #0
 1970 0026 F9DA     		bge	.L110
 528:../drivers/fsl_lpsci.c ****         {
 529:../drivers/fsl_lpsci.c ****         }
 530:../drivers/fsl_lpsci.c ****         base->D = *(data++);
 1971              		.loc 4 530 25
 1972 0028 BB68     		ldr	r3, [r7, #8]
 1973 002a 5A1C     		adds	r2, r3, #1
 1974 002c BA60     		str	r2, [r7, #8]
 1975              		.loc 4 530 19
 1976 002e 1A78     		ldrb	r2, [r3]
 1977              		.loc 4 530 17
 1978 0030 FB68     		ldr	r3, [r7, #12]
 1979 0032 DA71     		strb	r2, [r3, #7]
 1980              	.L109:
 525:../drivers/fsl_lpsci.c ****     {
 1981              		.loc 4 525 18
 1982 0034 7B68     		ldr	r3, [r7, #4]
 1983 0036 5A1E     		subs	r2, r3, #1
 1984 0038 7A60     		str	r2, [r7, #4]
 525:../drivers/fsl_lpsci.c ****     {
 1985              		.loc 4 525 11
 1986 003a 002B     		cmp	r3, #0
 1987 003c EDD1     		bne	.L111
 531:../drivers/fsl_lpsci.c ****     }
 532:../drivers/fsl_lpsci.c **** }
 1988              		.loc 4 532 1
 1989 003e C046     		nop
 1990 0040 C046     		nop
 1991 0042 BD46     		mov	sp, r7
 1992 0044 04B0     		add	sp, sp, #16
 1993              		@ sp needed
 1994 0046 80BD     		pop	{r7, pc}
 1995              	.L113:
 1996              		.align	2
 1997              	.L112:
 1998 0048 00000000 		.word	.LC18
 1999              		.cfi_endproc
 2000              	.LFE77:
 2002              		.section	.rodata.LPSCI_ReadBlocking.str1.4,"aMS",%progbits,1
 2003              		.align	2
 2004              	.LC20:
 2005 0000 2E66736C 		.ascii	".fsl_lpsci.c:536 : data\000"
 2005      5F6C7073 
 2005      63692E63 
 2005      3A353336 
 2005      203A2064 
 2006              		.section	.text.LPSCI_ReadBlocking,"ax",%progbits
 2007              		.align	1
 2008              		.global	LPSCI_ReadBlocking
 2009              		.syntax unified
 2010              		.code	16
 2011              		.thumb_func
 2012              		.fpu softvfp
 2014              	LPSCI_ReadBlocking:
 2015              	.LFB78:
 533:../drivers/fsl_lpsci.c **** 
 534:../drivers/fsl_lpsci.c **** status_t LPSCI_ReadBlocking(UART0_Type *base, uint8_t *data, size_t length)
 535:../drivers/fsl_lpsci.c **** {
 2016              		.loc 4 535 1
 2017              		.cfi_startproc
 2018              		@ args = 0, pretend = 0, frame = 24
 2019              		@ frame_needed = 1, uses_anonymous_args = 0
 2020 0000 80B5     		push	{r7, lr}
 2021              		.cfi_def_cfa_offset 8
 2022              		.cfi_offset 7, -8
 2023              		.cfi_offset 14, -4
 2024 0002 86B0     		sub	sp, sp, #24
 2025              		.cfi_def_cfa_offset 32
 2026 0004 00AF     		add	r7, sp, #0
 2027              		.cfi_def_cfa_register 7
 2028 0006 F860     		str	r0, [r7, #12]
 2029 0008 B960     		str	r1, [r7, #8]
 2030 000a 7A60     		str	r2, [r7, #4]
 536:../drivers/fsl_lpsci.c ****     assert(data);
 2031              		.loc 4 536 5
 2032 000c BB68     		ldr	r3, [r7, #8]
 2033 000e 002B     		cmp	r3, #0
 2034 0010 44D1     		bne	.L116
 2035              		.loc 4 536 5 is_stmt 0 discriminator 1
 2036 0012 274B     		ldr	r3, .L124
 2037 0014 1800     		movs	r0, r3
 2038 0016 FFF7FEFF 		bl	__assertion_failed
 2039              	.L122:
 537:../drivers/fsl_lpsci.c **** 
 538:../drivers/fsl_lpsci.c ****     uint32_t statusFlag;
 539:../drivers/fsl_lpsci.c **** 
 540:../drivers/fsl_lpsci.c ****     while (length--)
 541:../drivers/fsl_lpsci.c ****     {
 542:../drivers/fsl_lpsci.c ****         while (!(base->S1 & UART0_S1_RDRF_MASK))
 543:../drivers/fsl_lpsci.c ****         {
 544:../drivers/fsl_lpsci.c ****             statusFlag = LPSCI_GetStatusFlags(base);
 2040              		.loc 4 544 26 is_stmt 1
 2041 001a FB68     		ldr	r3, [r7, #12]
 2042 001c 1800     		movs	r0, r3
 2043 001e FFF7FEFF 		bl	LPSCI_GetStatusFlags
 2044 0022 0300     		movs	r3, r0
 2045 0024 7B61     		str	r3, [r7, #20]
 545:../drivers/fsl_lpsci.c **** 
 546:../drivers/fsl_lpsci.c ****             if (statusFlag & kLPSCI_RxOverrunFlag)
 2046              		.loc 4 546 28
 2047 0026 7B69     		ldr	r3, [r7, #20]
 2048 0028 0822     		movs	r2, #8
 2049 002a 1340     		ands	r3, r2
 2050              		.loc 4 546 16
 2051 002c 07D0     		beq	.L118
 547:../drivers/fsl_lpsci.c ****             {
 548:../drivers/fsl_lpsci.c ****                 LPSCI_ClearStatusFlags(base, kLPSCI_RxOverrunFlag);
 2052              		.loc 4 548 17
 2053 002e FB68     		ldr	r3, [r7, #12]
 2054 0030 0821     		movs	r1, #8
 2055 0032 1800     		movs	r0, r3
 2056 0034 FFF7FEFF 		bl	LPSCI_ClearStatusFlags
 549:../drivers/fsl_lpsci.c ****                 return kStatus_LPSCI_RxHardwareOverrun;
 2057              		.loc 4 549 24
 2058 0038 9723     		movs	r3, #151
 2059 003a DB00     		lsls	r3, r3, #3
 2060 003c 34E0     		b	.L119
 2061              	.L118:
 550:../drivers/fsl_lpsci.c ****             }
 551:../drivers/fsl_lpsci.c **** 
 552:../drivers/fsl_lpsci.c ****             if (statusFlag & kLPSCI_NoiseErrorFlag)
 2062              		.loc 4 552 28
 2063 003e 7B69     		ldr	r3, [r7, #20]
 2064 0040 0422     		movs	r2, #4
 2065 0042 1340     		ands	r3, r2
 2066              		.loc 4 552 16
 2067 0044 06D0     		beq	.L120
 553:../drivers/fsl_lpsci.c ****             {
 554:../drivers/fsl_lpsci.c ****                 LPSCI_ClearStatusFlags(base, kLPSCI_NoiseErrorFlag);
 2068              		.loc 4 554 17
 2069 0046 FB68     		ldr	r3, [r7, #12]
 2070 0048 0421     		movs	r1, #4
 2071 004a 1800     		movs	r0, r3
 2072 004c FFF7FEFF 		bl	LPSCI_ClearStatusFlags
 555:../drivers/fsl_lpsci.c ****                 return kStatus_LPSCI_NoiseError;
 2073              		.loc 4 555 24
 2074 0050 184B     		ldr	r3, .L124+4
 2075 0052 29E0     		b	.L119
 2076              	.L120:
 556:../drivers/fsl_lpsci.c ****             }
 557:../drivers/fsl_lpsci.c **** 
 558:../drivers/fsl_lpsci.c ****             if (statusFlag & kLPSCI_FramingErrorFlag)
 2077              		.loc 4 558 28
 2078 0054 7B69     		ldr	r3, [r7, #20]
 2079 0056 0222     		movs	r2, #2
 2080 0058 1340     		ands	r3, r2
 2081              		.loc 4 558 16
 2082 005a 06D0     		beq	.L121
 559:../drivers/fsl_lpsci.c ****             {
 560:../drivers/fsl_lpsci.c ****                 LPSCI_ClearStatusFlags(base, kLPSCI_FramingErrorFlag);
 2083              		.loc 4 560 17
 2084 005c FB68     		ldr	r3, [r7, #12]
 2085 005e 0221     		movs	r1, #2
 2086 0060 1800     		movs	r0, r3
 2087 0062 FFF7FEFF 		bl	LPSCI_ClearStatusFlags
 561:../drivers/fsl_lpsci.c ****                 return kStatus_LPSCI_FramingError;
 2088              		.loc 4 561 24
 2089 0066 144B     		ldr	r3, .L124+8
 2090 0068 1EE0     		b	.L119
 2091              	.L121:
 562:../drivers/fsl_lpsci.c ****             }
 563:../drivers/fsl_lpsci.c **** 
 564:../drivers/fsl_lpsci.c ****             if (statusFlag & kLPSCI_ParityErrorFlag)
 2092              		.loc 4 564 28
 2093 006a 7B69     		ldr	r3, [r7, #20]
 2094 006c 0122     		movs	r2, #1
 2095 006e 1340     		ands	r3, r2
 2096              		.loc 4 564 16
 2097 0070 06D0     		beq	.L117
 565:../drivers/fsl_lpsci.c ****             {
 566:../drivers/fsl_lpsci.c ****                 LPSCI_ClearStatusFlags(base, kLPSCI_ParityErrorFlag);
 2098              		.loc 4 566 17
 2099 0072 FB68     		ldr	r3, [r7, #12]
 2100 0074 0121     		movs	r1, #1
 2101 0076 1800     		movs	r0, r3
 2102 0078 FFF7FEFF 		bl	LPSCI_ClearStatusFlags
 567:../drivers/fsl_lpsci.c ****                 return kStatus_LPSCI_ParityError;
 2103              		.loc 4 567 24
 2104 007c 0F4B     		ldr	r3, .L124+12
 2105 007e 13E0     		b	.L119
 2106              	.L117:
 542:../drivers/fsl_lpsci.c ****         {
 2107              		.loc 4 542 22
 2108 0080 FB68     		ldr	r3, [r7, #12]
 2109 0082 1B79     		ldrb	r3, [r3, #4]
 2110 0084 DBB2     		uxtb	r3, r3
 542:../drivers/fsl_lpsci.c ****         {
 2111              		.loc 4 542 27
 2112 0086 1A00     		movs	r2, r3
 2113 0088 2023     		movs	r3, #32
 2114 008a 1340     		ands	r3, r2
 542:../drivers/fsl_lpsci.c ****         {
 2115              		.loc 4 542 15
 2116 008c C5D0     		beq	.L122
 568:../drivers/fsl_lpsci.c ****             }
 569:../drivers/fsl_lpsci.c ****         }
 570:../drivers/fsl_lpsci.c ****         *(data++) = base->D;
 2117              		.loc 4 570 15
 2118 008e BB68     		ldr	r3, [r7, #8]
 2119 0090 5A1C     		adds	r2, r3, #1
 2120 0092 BA60     		str	r2, [r7, #8]
 2121              		.loc 4 570 25
 2122 0094 FA68     		ldr	r2, [r7, #12]
 2123 0096 D279     		ldrb	r2, [r2, #7]
 2124 0098 D2B2     		uxtb	r2, r2
 2125              		.loc 4 570 19
 2126 009a 1A70     		strb	r2, [r3]
 2127              	.L116:
 540:../drivers/fsl_lpsci.c ****     {
 2128              		.loc 4 540 18
 2129 009c 7B68     		ldr	r3, [r7, #4]
 2130 009e 5A1E     		subs	r2, r3, #1
 2131 00a0 7A60     		str	r2, [r7, #4]
 540:../drivers/fsl_lpsci.c ****     {
 2132              		.loc 4 540 11
 2133 00a2 002B     		cmp	r3, #0
 2134 00a4 ECD1     		bne	.L117
 571:../drivers/fsl_lpsci.c ****     }
 572:../drivers/fsl_lpsci.c **** 
 573:../drivers/fsl_lpsci.c ****     return kStatus_Success;
 2135              		.loc 4 573 12
 2136 00a6 0023     		movs	r3, #0
 2137              	.L119:
 574:../drivers/fsl_lpsci.c **** }
 2138              		.loc 4 574 1
 2139 00a8 1800     		movs	r0, r3
 2140 00aa BD46     		mov	sp, r7
 2141 00ac 06B0     		add	sp, sp, #24
 2142              		@ sp needed
 2143 00ae 80BD     		pop	{r7, pc}
 2144              	.L125:
 2145              		.align	2
 2146              	.L124:
 2147 00b0 00000000 		.word	.LC20
 2148 00b4 B9040000 		.word	1209
 2149 00b8 BA040000 		.word	1210
 2150 00bc BB040000 		.word	1211
 2151              		.cfi_endproc
 2152              	.LFE78:
 2154              		.section	.rodata.LPSCI_TransferCreateHandle.str1.4,"aMS",%progbits,1
 2155              		.align	2
 2156              	.LC22:
 2157 0000 2E66736C 		.ascii	".fsl_lpsci.c:581 : handle\000"
 2157      5F6C7073 
 2157      63692E63 
 2157      3A353831 
 2157      203A2068 
 2158              		.section	.text.LPSCI_TransferCreateHandle,"ax",%progbits
 2159              		.align	1
 2160              		.global	LPSCI_TransferCreateHandle
 2161              		.syntax unified
 2162              		.code	16
 2163              		.thumb_func
 2164              		.fpu softvfp
 2166              	LPSCI_TransferCreateHandle:
 2167              	.LFB79:
 575:../drivers/fsl_lpsci.c **** 
 576:../drivers/fsl_lpsci.c **** void LPSCI_TransferCreateHandle(UART0_Type *base,
 577:../drivers/fsl_lpsci.c ****                                 lpsci_handle_t *handle,
 578:../drivers/fsl_lpsci.c ****                                 lpsci_transfer_callback_t callback,
 579:../drivers/fsl_lpsci.c ****                                 void *userData)
 580:../drivers/fsl_lpsci.c **** {
 2168              		.loc 4 580 1
 2169              		.cfi_startproc
 2170              		@ args = 0, pretend = 0, frame = 24
 2171              		@ frame_needed = 1, uses_anonymous_args = 0
 2172 0000 80B5     		push	{r7, lr}
 2173              		.cfi_def_cfa_offset 8
 2174              		.cfi_offset 7, -8
 2175              		.cfi_offset 14, -4
 2176 0002 86B0     		sub	sp, sp, #24
 2177              		.cfi_def_cfa_offset 32
 2178 0004 00AF     		add	r7, sp, #0
 2179              		.cfi_def_cfa_register 7
 2180 0006 F860     		str	r0, [r7, #12]
 2181 0008 B960     		str	r1, [r7, #8]
 2182 000a 7A60     		str	r2, [r7, #4]
 2183 000c 3B60     		str	r3, [r7]
 581:../drivers/fsl_lpsci.c ****     assert(handle);
 2184              		.loc 4 581 5
 2185 000e BB68     		ldr	r3, [r7, #8]
 2186 0010 002B     		cmp	r3, #0
 2187 0012 03D1     		bne	.L127
 2188              		.loc 4 581 5 is_stmt 0 discriminator 1
 2189 0014 164B     		ldr	r3, .L128
 2190 0016 1800     		movs	r0, r3
 2191 0018 FFF7FEFF 		bl	__assertion_failed
 2192              	.L127:
 582:../drivers/fsl_lpsci.c **** 
 583:../drivers/fsl_lpsci.c ****     uint32_t instance;
 584:../drivers/fsl_lpsci.c **** 
 585:../drivers/fsl_lpsci.c ****     /* Zero the handle. */
 586:../drivers/fsl_lpsci.c ****     memset(handle, 0, sizeof(lpsci_handle_t));
 2193              		.loc 4 586 5 is_stmt 1
 2194 001c BB68     		ldr	r3, [r7, #8]
 2195 001e 3022     		movs	r2, #48
 2196 0020 0021     		movs	r1, #0
 2197 0022 1800     		movs	r0, r3
 2198 0024 FFF7FEFF 		bl	memset
 587:../drivers/fsl_lpsci.c **** 
 588:../drivers/fsl_lpsci.c ****     /* Set the TX/RX state. */
 589:../drivers/fsl_lpsci.c ****     handle->rxState = kLPSCI_RxIdle;
 2199              		.loc 4 589 21
 2200 0028 BB68     		ldr	r3, [r7, #8]
 2201 002a 2D22     		movs	r2, #45
 2202 002c 0221     		movs	r1, #2
 2203 002e 9954     		strb	r1, [r3, r2]
 590:../drivers/fsl_lpsci.c ****     handle->txState = kLPSCI_TxIdle;
 2204              		.loc 4 590 21
 2205 0030 BB68     		ldr	r3, [r7, #8]
 2206 0032 2C22     		movs	r2, #44
 2207 0034 0021     		movs	r1, #0
 2208 0036 9954     		strb	r1, [r3, r2]
 591:../drivers/fsl_lpsci.c **** 
 592:../drivers/fsl_lpsci.c ****     /* Set the callback and user data. */
 593:../drivers/fsl_lpsci.c ****     handle->callback = callback;
 2209              		.loc 4 593 22
 2210 0038 BB68     		ldr	r3, [r7, #8]
 2211 003a 7A68     		ldr	r2, [r7, #4]
 2212 003c 5A62     		str	r2, [r3, #36]
 594:../drivers/fsl_lpsci.c ****     handle->userData = userData;
 2213              		.loc 4 594 22
 2214 003e BB68     		ldr	r3, [r7, #8]
 2215 0040 3A68     		ldr	r2, [r7]
 2216 0042 9A62     		str	r2, [r3, #40]
 595:../drivers/fsl_lpsci.c **** 
 596:../drivers/fsl_lpsci.c ****     /* Get instance from peripheral base address. */
 597:../drivers/fsl_lpsci.c ****     instance = LPSCI_GetInstance(base);
 2217              		.loc 4 597 16
 2218 0044 FB68     		ldr	r3, [r7, #12]
 2219 0046 1800     		movs	r0, r3
 2220 0048 FFF7FEFF 		bl	LPSCI_GetInstance
 2221 004c 0300     		movs	r3, r0
 2222 004e 7B61     		str	r3, [r7, #20]
 598:../drivers/fsl_lpsci.c **** 
 599:../drivers/fsl_lpsci.c ****     /* Save the handle in global variables to support the double weak mechanism. */
 600:../drivers/fsl_lpsci.c ****     s_lpsciHandle[instance] = handle;
 2223              		.loc 4 600 29
 2224 0050 084B     		ldr	r3, .L128+4
 2225 0052 7A69     		ldr	r2, [r7, #20]
 2226 0054 9200     		lsls	r2, r2, #2
 2227 0056 B968     		ldr	r1, [r7, #8]
 2228 0058 D150     		str	r1, [r2, r3]
 601:../drivers/fsl_lpsci.c **** 
 602:../drivers/fsl_lpsci.c ****     s_lpsciIsr = LPSCI_TransferHandleIRQ;
 2229              		.loc 4 602 16
 2230 005a 074B     		ldr	r3, .L128+8
 2231 005c 074A     		ldr	r2, .L128+12
 2232 005e 1A60     		str	r2, [r3]
 603:../drivers/fsl_lpsci.c **** 
 604:../drivers/fsl_lpsci.c ****     /* Enable interrupt in NVIC. */
 605:../drivers/fsl_lpsci.c ****     EnableIRQ(s_lpsciIRQ[instance]);
 2233              		.loc 4 605 5
 2234 0060 0C23     		movs	r3, #12
 2235 0062 1800     		movs	r0, r3
 2236 0064 FFF7FEFF 		bl	EnableIRQ
 606:../drivers/fsl_lpsci.c **** }
 2237              		.loc 4 606 1
 2238 0068 C046     		nop
 2239 006a BD46     		mov	sp, r7
 2240 006c 06B0     		add	sp, sp, #24
 2241              		@ sp needed
 2242 006e 80BD     		pop	{r7, pc}
 2243              	.L129:
 2244              		.align	2
 2245              	.L128:
 2246 0070 00000000 		.word	.LC22
 2247 0074 00000000 		.word	s_lpsciHandle
 2248 0078 00000000 		.word	s_lpsciIsr
 2249 007c 00000000 		.word	LPSCI_TransferHandleIRQ
 2250              		.cfi_endproc
 2251              	.LFE79:
 2253              		.section	.rodata.LPSCI_TransferStartRingBuffer.str1.4,"aMS",%progbits,1
 2254              		.align	2
 2255              	.LC27:
 2256 0000 2E66736C 		.ascii	".fsl_lpsci.c:610 : handle\000"
 2256      5F6C7073 
 2256      63692E63 
 2256      3A363130 
 2256      203A2068 
 2257 001a 0000     		.align	2
 2258              	.LC29:
 2259 001c 2E66736C 		.ascii	".fsl_lpsci.c:611 : ringBuffer\000"
 2259      5F6C7073 
 2259      63692E63 
 2259      3A363131 
 2259      203A2072 
 2260              		.section	.text.LPSCI_TransferStartRingBuffer,"ax",%progbits
 2261              		.align	1
 2262              		.global	LPSCI_TransferStartRingBuffer
 2263              		.syntax unified
 2264              		.code	16
 2265              		.thumb_func
 2266              		.fpu softvfp
 2268              	LPSCI_TransferStartRingBuffer:
 2269              	.LFB80:
 607:../drivers/fsl_lpsci.c **** 
 608:../drivers/fsl_lpsci.c **** void LPSCI_TransferStartRingBuffer(UART0_Type *base, lpsci_handle_t *handle, uint8_t *ringBuffer, s
 609:../drivers/fsl_lpsci.c **** {
 2270              		.loc 4 609 1
 2271              		.cfi_startproc
 2272              		@ args = 0, pretend = 0, frame = 16
 2273              		@ frame_needed = 1, uses_anonymous_args = 0
 2274 0000 80B5     		push	{r7, lr}
 2275              		.cfi_def_cfa_offset 8
 2276              		.cfi_offset 7, -8
 2277              		.cfi_offset 14, -4
 2278 0002 84B0     		sub	sp, sp, #16
 2279              		.cfi_def_cfa_offset 24
 2280 0004 00AF     		add	r7, sp, #0
 2281              		.cfi_def_cfa_register 7
 2282 0006 F860     		str	r0, [r7, #12]
 2283 0008 B960     		str	r1, [r7, #8]
 2284 000a 7A60     		str	r2, [r7, #4]
 2285 000c 3B60     		str	r3, [r7]
 610:../drivers/fsl_lpsci.c ****     assert(handle);
 2286              		.loc 4 610 5
 2287 000e BB68     		ldr	r3, [r7, #8]
 2288 0010 002B     		cmp	r3, #0
 2289 0012 03D1     		bne	.L131
 2290              		.loc 4 610 5 is_stmt 0 discriminator 1
 2291 0014 184B     		ldr	r3, .L135
 2292 0016 1800     		movs	r0, r3
 2293 0018 FFF7FEFF 		bl	__assertion_failed
 2294              	.L131:
 611:../drivers/fsl_lpsci.c ****     assert(ringBuffer);
 2295              		.loc 4 611 5 is_stmt 1
 2296 001c 7B68     		ldr	r3, [r7, #4]
 2297 001e 002B     		cmp	r3, #0
 2298 0020 03D1     		bne	.L132
 2299              		.loc 4 611 5 is_stmt 0 discriminator 1
 2300 0022 164B     		ldr	r3, .L135+4
 2301 0024 1800     		movs	r0, r3
 2302 0026 FFF7FEFF 		bl	__assertion_failed
 2303              	.L132:
 612:../drivers/fsl_lpsci.c **** 
 613:../drivers/fsl_lpsci.c ****     /* Setup the ringbuffer address */
 614:../drivers/fsl_lpsci.c ****     handle->rxRingBuffer = ringBuffer;
 2304              		.loc 4 614 26 is_stmt 1
 2305 002a BB68     		ldr	r3, [r7, #8]
 2306 002c 7A68     		ldr	r2, [r7, #4]
 2307 002e 9A61     		str	r2, [r3, #24]
 615:../drivers/fsl_lpsci.c ****     handle->rxRingBufferSize = ringBufferSize;
 2308              		.loc 4 615 30
 2309 0030 BB68     		ldr	r3, [r7, #8]
 2310 0032 3A68     		ldr	r2, [r7]
 2311 0034 DA61     		str	r2, [r3, #28]
 616:../drivers/fsl_lpsci.c ****     handle->rxRingBufferHead = 0U;
 2312              		.loc 4 616 30
 2313 0036 BB68     		ldr	r3, [r7, #8]
 2314 0038 0022     		movs	r2, #0
 2315 003a 1A84     		strh	r2, [r3, #32]
 617:../drivers/fsl_lpsci.c ****     handle->rxRingBufferTail = 0U;
 2316              		.loc 4 617 30
 2317 003c BB68     		ldr	r3, [r7, #8]
 2318 003e 0022     		movs	r2, #0
 2319 0040 5A84     		strh	r2, [r3, #34]
 618:../drivers/fsl_lpsci.c **** 
 619:../drivers/fsl_lpsci.c ****     /* Enable the interrupt to accept the data when user need the ring buffer. */
 620:../drivers/fsl_lpsci.c ****     LPSCI_EnableInterrupts(base, kLPSCI_RxDataRegFullInterruptEnable | kLPSCI_RxOverrunInterruptEna
 2320              		.loc 4 620 5
 2321 0042 A223     		movs	r3, #162
 2322 0044 1A03     		lsls	r2, r3, #12
 2323 0046 FB68     		ldr	r3, [r7, #12]
 2324 0048 1100     		movs	r1, r2
 2325 004a 1800     		movs	r0, r3
 2326 004c FFF7FEFF 		bl	LPSCI_EnableInterrupts
 621:../drivers/fsl_lpsci.c ****                                      kLPSCI_FramingErrorInterruptEnable);
 622:../drivers/fsl_lpsci.c ****     /* Enable parity error interrupt when parity mode is enable*/
 623:../drivers/fsl_lpsci.c ****     if (UART0_C1_PE_MASK & base->C1)
 2327              		.loc 4 623 32
 2328 0050 FB68     		ldr	r3, [r7, #12]
 2329 0052 9B78     		ldrb	r3, [r3, #2]
 2330 0054 DBB2     		uxtb	r3, r3
 2331              		.loc 4 623 9
 2332 0056 0222     		movs	r2, #2
 2333 0058 1340     		ands	r3, r2
 2334 005a DBB2     		uxtb	r3, r3
 2335              		.loc 4 623 8
 2336 005c 002B     		cmp	r3, #0
 2337 005e 06D0     		beq	.L134
 624:../drivers/fsl_lpsci.c ****     {
 625:../drivers/fsl_lpsci.c ****         LPSCI_EnableInterrupts(base, kLPSCI_ParityErrorInterruptEnable);
 2338              		.loc 4 625 9
 2339 0060 8023     		movs	r3, #128
 2340 0062 5A02     		lsls	r2, r3, #9
 2341 0064 FB68     		ldr	r3, [r7, #12]
 2342 0066 1100     		movs	r1, r2
 2343 0068 1800     		movs	r0, r3
 2344 006a FFF7FEFF 		bl	LPSCI_EnableInterrupts
 2345              	.L134:
 626:../drivers/fsl_lpsci.c ****     }
 627:../drivers/fsl_lpsci.c **** }
 2346              		.loc 4 627 1
 2347 006e C046     		nop
 2348 0070 BD46     		mov	sp, r7
 2349 0072 04B0     		add	sp, sp, #16
 2350              		@ sp needed
 2351 0074 80BD     		pop	{r7, pc}
 2352              	.L136:
 2353 0076 C046     		.align	2
 2354              	.L135:
 2355 0078 00000000 		.word	.LC27
 2356 007c 1C000000 		.word	.LC29
 2357              		.cfi_endproc
 2358              	.LFE80:
 2360              		.section	.rodata.LPSCI_TransferStopRingBuffer.str1.4,"aMS",%progbits,1
 2361              		.align	2
 2362              	.LC31:
 2363 0000 2E66736C 		.ascii	".fsl_lpsci.c:631 : handle\000"
 2363      5F6C7073 
 2363      63692E63 
 2363      3A363331 
 2363      203A2068 
 2364              		.section	.text.LPSCI_TransferStopRingBuffer,"ax",%progbits
 2365              		.align	1
 2366              		.global	LPSCI_TransferStopRingBuffer
 2367              		.syntax unified
 2368              		.code	16
 2369              		.thumb_func
 2370              		.fpu softvfp
 2372              	LPSCI_TransferStopRingBuffer:
 2373              	.LFB81:
 628:../drivers/fsl_lpsci.c **** 
 629:../drivers/fsl_lpsci.c **** void LPSCI_TransferStopRingBuffer(UART0_Type *base, lpsci_handle_t *handle)
 630:../drivers/fsl_lpsci.c **** {
 2374              		.loc 4 630 1
 2375              		.cfi_startproc
 2376              		@ args = 0, pretend = 0, frame = 8
 2377              		@ frame_needed = 1, uses_anonymous_args = 0
 2378 0000 80B5     		push	{r7, lr}
 2379              		.cfi_def_cfa_offset 8
 2380              		.cfi_offset 7, -8
 2381              		.cfi_offset 14, -4
 2382 0002 82B0     		sub	sp, sp, #8
 2383              		.cfi_def_cfa_offset 16
 2384 0004 00AF     		add	r7, sp, #0
 2385              		.cfi_def_cfa_register 7
 2386 0006 7860     		str	r0, [r7, #4]
 2387 0008 3960     		str	r1, [r7]
 631:../drivers/fsl_lpsci.c ****     assert(handle);
 2388              		.loc 4 631 5
 2389 000a 3B68     		ldr	r3, [r7]
 2390 000c 002B     		cmp	r3, #0
 2391 000e 03D1     		bne	.L138
 2392              		.loc 4 631 5 is_stmt 0 discriminator 1
 2393 0010 174B     		ldr	r3, .L140
 2394 0012 1800     		movs	r0, r3
 2395 0014 FFF7FEFF 		bl	__assertion_failed
 2396              	.L138:
 632:../drivers/fsl_lpsci.c **** 
 633:../drivers/fsl_lpsci.c ****     if (handle->rxState == kLPSCI_RxIdle)
 2397              		.loc 4 633 15 is_stmt 1
 2398 0018 3B68     		ldr	r3, [r7]
 2399 001a 2D22     		movs	r2, #45
 2400 001c 9B5C     		ldrb	r3, [r3, r2]
 2401 001e DBB2     		uxtb	r3, r3
 2402              		.loc 4 633 8
 2403 0020 022B     		cmp	r3, #2
 2404 0022 15D1     		bne	.L139
 634:../drivers/fsl_lpsci.c ****     {
 635:../drivers/fsl_lpsci.c ****         LPSCI_DisableInterrupts(base, kLPSCI_RxDataRegFullInterruptEnable | kLPSCI_RxOverrunInterru
 2405              		.loc 4 635 9
 2406 0024 A223     		movs	r3, #162
 2407 0026 1A03     		lsls	r2, r3, #12
 2408 0028 7B68     		ldr	r3, [r7, #4]
 2409 002a 1100     		movs	r1, r2
 2410 002c 1800     		movs	r0, r3
 2411 002e FFF7FEFF 		bl	LPSCI_DisableInterrupts
 636:../drivers/fsl_lpsci.c ****                                           kLPSCI_FramingErrorInterruptEnable);
 637:../drivers/fsl_lpsci.c **** 
 638:../drivers/fsl_lpsci.c ****         /* Disable parity error interrupt when parity mode is enable*/
 639:../drivers/fsl_lpsci.c ****         if (UART0_C1_PE_MASK & base->C1)
 2412              		.loc 4 639 36
 2413 0032 7B68     		ldr	r3, [r7, #4]
 2414 0034 9B78     		ldrb	r3, [r3, #2]
 2415 0036 DBB2     		uxtb	r3, r3
 2416              		.loc 4 639 13
 2417 0038 0222     		movs	r2, #2
 2418 003a 1340     		ands	r3, r2
 2419 003c DBB2     		uxtb	r3, r3
 2420              		.loc 4 639 12
 2421 003e 002B     		cmp	r3, #0
 2422 0040 06D0     		beq	.L139
 640:../drivers/fsl_lpsci.c ****         {
 641:../drivers/fsl_lpsci.c ****             LPSCI_DisableInterrupts(base, kLPSCI_ParityErrorInterruptEnable);
 2423              		.loc 4 641 13
 2424 0042 8023     		movs	r3, #128
 2425 0044 5A02     		lsls	r2, r3, #9
 2426 0046 7B68     		ldr	r3, [r7, #4]
 2427 0048 1100     		movs	r1, r2
 2428 004a 1800     		movs	r0, r3
 2429 004c FFF7FEFF 		bl	LPSCI_DisableInterrupts
 2430              	.L139:
 642:../drivers/fsl_lpsci.c ****         }
 643:../drivers/fsl_lpsci.c ****     }
 644:../drivers/fsl_lpsci.c **** 
 645:../drivers/fsl_lpsci.c ****     handle->rxRingBuffer = NULL;
 2431              		.loc 4 645 26
 2432 0050 3B68     		ldr	r3, [r7]
 2433 0052 0022     		movs	r2, #0
 2434 0054 9A61     		str	r2, [r3, #24]
 646:../drivers/fsl_lpsci.c ****     handle->rxRingBufferSize = 0U;
 2435              		.loc 4 646 30
 2436 0056 3B68     		ldr	r3, [r7]
 2437 0058 0022     		movs	r2, #0
 2438 005a DA61     		str	r2, [r3, #28]
 647:../drivers/fsl_lpsci.c ****     handle->rxRingBufferHead = 0U;
 2439              		.loc 4 647 30
 2440 005c 3B68     		ldr	r3, [r7]
 2441 005e 0022     		movs	r2, #0
 2442 0060 1A84     		strh	r2, [r3, #32]
 648:../drivers/fsl_lpsci.c ****     handle->rxRingBufferTail = 0U;
 2443              		.loc 4 648 30
 2444 0062 3B68     		ldr	r3, [r7]
 2445 0064 0022     		movs	r2, #0
 2446 0066 5A84     		strh	r2, [r3, #34]
 649:../drivers/fsl_lpsci.c **** }
 2447              		.loc 4 649 1
 2448 0068 C046     		nop
 2449 006a BD46     		mov	sp, r7
 2450 006c 02B0     		add	sp, sp, #8
 2451              		@ sp needed
 2452 006e 80BD     		pop	{r7, pc}
 2453              	.L141:
 2454              		.align	2
 2455              	.L140:
 2456 0070 00000000 		.word	.LC31
 2457              		.cfi_endproc
 2458              	.LFE81:
 2460              		.section	.rodata.LPSCI_TransferSendNonBlocking.str1.4,"aMS",%progbits,1
 2461              		.align	2
 2462              	.LC33:
 2463 0000 2E66736C 		.ascii	".fsl_lpsci.c:653 : handle\000"
 2463      5F6C7073 
 2463      63692E63 
 2463      3A363533 
 2463      203A2068 
 2464 001a 0000     		.align	2
 2465              	.LC35:
 2466 001c 2E66736C 		.ascii	".fsl_lpsci.c:654 : xfer\000"
 2466      5F6C7073 
 2466      63692E63 
 2466      3A363534 
 2466      203A2078 
 2467              		.align	2
 2468              	.LC37:
 2469 0034 2E66736C 		.ascii	".fsl_lpsci.c:655 : xfer->dataSize\000"
 2469      5F6C7073 
 2469      63692E63 
 2469      3A363535 
 2469      203A2078 
 2470 0056 0000     		.align	2
 2471              	.LC39:
 2472 0058 2E66736C 		.ascii	".fsl_lpsci.c:656 : xfer->data\000"
 2472      5F6C7073 
 2472      63692E63 
 2472      3A363536 
 2472      203A2078 
 2473              		.section	.text.LPSCI_TransferSendNonBlocking,"ax",%progbits
 2474              		.align	1
 2475              		.global	LPSCI_TransferSendNonBlocking
 2476              		.syntax unified
 2477              		.code	16
 2478              		.thumb_func
 2479              		.fpu softvfp
 2481              	LPSCI_TransferSendNonBlocking:
 2482              	.LFB82:
 650:../drivers/fsl_lpsci.c **** 
 651:../drivers/fsl_lpsci.c **** status_t LPSCI_TransferSendNonBlocking(UART0_Type *base, lpsci_handle_t *handle, lpsci_transfer_t *
 652:../drivers/fsl_lpsci.c **** {
 2483              		.loc 4 652 1
 2484              		.cfi_startproc
 2485              		@ args = 0, pretend = 0, frame = 24
 2486              		@ frame_needed = 1, uses_anonymous_args = 0
 2487 0000 80B5     		push	{r7, lr}
 2488              		.cfi_def_cfa_offset 8
 2489              		.cfi_offset 7, -8
 2490              		.cfi_offset 14, -4
 2491 0002 86B0     		sub	sp, sp, #24
 2492              		.cfi_def_cfa_offset 32
 2493 0004 00AF     		add	r7, sp, #0
 2494              		.cfi_def_cfa_register 7
 2495 0006 F860     		str	r0, [r7, #12]
 2496 0008 B960     		str	r1, [r7, #8]
 2497 000a 7A60     		str	r2, [r7, #4]
 653:../drivers/fsl_lpsci.c ****     assert(handle);
 2498              		.loc 4 653 5
 2499 000c BB68     		ldr	r3, [r7, #8]
 2500 000e 002B     		cmp	r3, #0
 2501 0010 03D1     		bne	.L143
 2502              		.loc 4 653 5 is_stmt 0 discriminator 1
 2503 0012 214B     		ldr	r3, .L150
 2504 0014 1800     		movs	r0, r3
 2505 0016 FFF7FEFF 		bl	__assertion_failed
 2506              	.L143:
 654:../drivers/fsl_lpsci.c ****     assert(xfer);
 2507              		.loc 4 654 5 is_stmt 1
 2508 001a 7B68     		ldr	r3, [r7, #4]
 2509 001c 002B     		cmp	r3, #0
 2510 001e 03D1     		bne	.L144
 2511              		.loc 4 654 5 is_stmt 0 discriminator 1
 2512 0020 1E4B     		ldr	r3, .L150+4
 2513 0022 1800     		movs	r0, r3
 2514 0024 FFF7FEFF 		bl	__assertion_failed
 2515              	.L144:
 655:../drivers/fsl_lpsci.c ****     assert(xfer->dataSize);
 2516              		.loc 4 655 5 is_stmt 1
 2517 0028 7B68     		ldr	r3, [r7, #4]
 2518 002a 5B68     		ldr	r3, [r3, #4]
 2519 002c 002B     		cmp	r3, #0
 2520 002e 03D1     		bne	.L145
 2521              		.loc 4 655 5 is_stmt 0 discriminator 1
 2522 0030 1B4B     		ldr	r3, .L150+8
 2523 0032 1800     		movs	r0, r3
 2524 0034 FFF7FEFF 		bl	__assertion_failed
 2525              	.L145:
 656:../drivers/fsl_lpsci.c ****     assert(xfer->data);
 2526              		.loc 4 656 5 is_stmt 1
 2527 0038 7B68     		ldr	r3, [r7, #4]
 2528 003a 1B68     		ldr	r3, [r3]
 2529 003c 002B     		cmp	r3, #0
 2530 003e 03D1     		bne	.L146
 2531              		.loc 4 656 5 is_stmt 0 discriminator 1
 2532 0040 184B     		ldr	r3, .L150+12
 2533 0042 1800     		movs	r0, r3
 2534 0044 FFF7FEFF 		bl	__assertion_failed
 2535              	.L146:
 657:../drivers/fsl_lpsci.c **** 
 658:../drivers/fsl_lpsci.c ****     status_t status;
 659:../drivers/fsl_lpsci.c **** 
 660:../drivers/fsl_lpsci.c ****     /* Return error if current TX busy. */
 661:../drivers/fsl_lpsci.c ****     if (kLPSCI_TxBusy == handle->txState)
 2536              		.loc 4 661 32 is_stmt 1
 2537 0048 BB68     		ldr	r3, [r7, #8]
 2538 004a 2C22     		movs	r2, #44
 2539 004c 9B5C     		ldrb	r3, [r3, r2]
 2540 004e DBB2     		uxtb	r3, r3
 2541              		.loc 4 661 8
 2542 0050 012B     		cmp	r3, #1
 2543 0052 03D1     		bne	.L147
 662:../drivers/fsl_lpsci.c ****     {
 663:../drivers/fsl_lpsci.c ****         status = kStatus_LPSCI_TxBusy;
 2544              		.loc 4 663 16
 2545 0054 9623     		movs	r3, #150
 2546 0056 DB00     		lsls	r3, r3, #3
 2547 0058 7B61     		str	r3, [r7, #20]
 2548 005a 18E0     		b	.L148
 2549              	.L147:
 664:../drivers/fsl_lpsci.c ****     }
 665:../drivers/fsl_lpsci.c ****     else
 666:../drivers/fsl_lpsci.c ****     {
 667:../drivers/fsl_lpsci.c ****         handle->txData = xfer->data;
 2550              		.loc 4 667 30
 2551 005c 7B68     		ldr	r3, [r7, #4]
 2552 005e 1A68     		ldr	r2, [r3]
 2553              		.loc 4 667 24
 2554 0060 BB68     		ldr	r3, [r7, #8]
 2555 0062 1A60     		str	r2, [r3]
 668:../drivers/fsl_lpsci.c ****         handle->txDataSize = xfer->dataSize;
 2556              		.loc 4 668 34
 2557 0064 7B68     		ldr	r3, [r7, #4]
 2558 0066 5A68     		ldr	r2, [r3, #4]
 2559              		.loc 4 668 28
 2560 0068 BB68     		ldr	r3, [r7, #8]
 2561 006a 5A60     		str	r2, [r3, #4]
 669:../drivers/fsl_lpsci.c ****         handle->txDataSizeAll = xfer->dataSize;
 2562              		.loc 4 669 37
 2563 006c 7B68     		ldr	r3, [r7, #4]
 2564 006e 5A68     		ldr	r2, [r3, #4]
 2565              		.loc 4 669 31
 2566 0070 BB68     		ldr	r3, [r7, #8]
 2567 0072 9A60     		str	r2, [r3, #8]
 670:../drivers/fsl_lpsci.c ****         handle->txState = kLPSCI_TxBusy;
 2568              		.loc 4 670 25
 2569 0074 BB68     		ldr	r3, [r7, #8]
 2570 0076 2C22     		movs	r2, #44
 2571 0078 0121     		movs	r1, #1
 2572 007a 9954     		strb	r1, [r3, r2]
 671:../drivers/fsl_lpsci.c **** 
 672:../drivers/fsl_lpsci.c ****         /* Enable transmiter interrupt. */
 673:../drivers/fsl_lpsci.c ****         LPSCI_EnableInterrupts(base, kLPSCI_TxDataRegEmptyInterruptEnable);
 2573              		.loc 4 673 9
 2574 007c 8023     		movs	r3, #128
 2575 007e 1A02     		lsls	r2, r3, #8
 2576 0080 FB68     		ldr	r3, [r7, #12]
 2577 0082 1100     		movs	r1, r2
 2578 0084 1800     		movs	r0, r3
 2579 0086 FFF7FEFF 		bl	LPSCI_EnableInterrupts
 674:../drivers/fsl_lpsci.c **** 
 675:../drivers/fsl_lpsci.c ****         status = kStatus_Success;
 2580              		.loc 4 675 16
 2581 008a 0023     		movs	r3, #0
 2582 008c 7B61     		str	r3, [r7, #20]
 2583              	.L148:
 676:../drivers/fsl_lpsci.c ****     }
 677:../drivers/fsl_lpsci.c **** 
 678:../drivers/fsl_lpsci.c ****     return status;
 2584              		.loc 4 678 12
 2585 008e 7B69     		ldr	r3, [r7, #20]
 679:../drivers/fsl_lpsci.c **** }
 2586              		.loc 4 679 1
 2587 0090 1800     		movs	r0, r3
 2588 0092 BD46     		mov	sp, r7
 2589 0094 06B0     		add	sp, sp, #24
 2590              		@ sp needed
 2591 0096 80BD     		pop	{r7, pc}
 2592              	.L151:
 2593              		.align	2
 2594              	.L150:
 2595 0098 00000000 		.word	.LC33
 2596 009c 1C000000 		.word	.LC35
 2597 00a0 34000000 		.word	.LC37
 2598 00a4 58000000 		.word	.LC39
 2599              		.cfi_endproc
 2600              	.LFE82:
 2602              		.section	.rodata.LPSCI_TransferAbortSend.str1.4,"aMS",%progbits,1
 2603              		.align	2
 2604              	.LC41:
 2605 0000 2E66736C 		.ascii	".fsl_lpsci.c:683 : handle\000"
 2605      5F6C7073 
 2605      63692E63 
 2605      3A363833 
 2605      203A2068 
 2606              		.section	.text.LPSCI_TransferAbortSend,"ax",%progbits
 2607              		.align	1
 2608              		.global	LPSCI_TransferAbortSend
 2609              		.syntax unified
 2610              		.code	16
 2611              		.thumb_func
 2612              		.fpu softvfp
 2614              	LPSCI_TransferAbortSend:
 2615              	.LFB83:
 680:../drivers/fsl_lpsci.c **** 
 681:../drivers/fsl_lpsci.c **** void LPSCI_TransferAbortSend(UART0_Type *base, lpsci_handle_t *handle)
 682:../drivers/fsl_lpsci.c **** {
 2616              		.loc 4 682 1
 2617              		.cfi_startproc
 2618              		@ args = 0, pretend = 0, frame = 8
 2619              		@ frame_needed = 1, uses_anonymous_args = 0
 2620 0000 80B5     		push	{r7, lr}
 2621              		.cfi_def_cfa_offset 8
 2622              		.cfi_offset 7, -8
 2623              		.cfi_offset 14, -4
 2624 0002 82B0     		sub	sp, sp, #8
 2625              		.cfi_def_cfa_offset 16
 2626 0004 00AF     		add	r7, sp, #0
 2627              		.cfi_def_cfa_register 7
 2628 0006 7860     		str	r0, [r7, #4]
 2629 0008 3960     		str	r1, [r7]
 683:../drivers/fsl_lpsci.c ****     assert(handle);
 2630              		.loc 4 683 5
 2631 000a 3B68     		ldr	r3, [r7]
 2632 000c 002B     		cmp	r3, #0
 2633 000e 03D1     		bne	.L153
 2634              		.loc 4 683 5 is_stmt 0 discriminator 1
 2635 0010 0A4B     		ldr	r3, .L154
 2636 0012 1800     		movs	r0, r3
 2637 0014 FFF7FEFF 		bl	__assertion_failed
 2638              	.L153:
 684:../drivers/fsl_lpsci.c **** 
 685:../drivers/fsl_lpsci.c ****     LPSCI_DisableInterrupts(base, kLPSCI_TxDataRegEmptyInterruptEnable | kLPSCI_TransmissionComplet
 2639              		.loc 4 685 5 is_stmt 1
 2640 0018 C023     		movs	r3, #192
 2641 001a 1A02     		lsls	r2, r3, #8
 2642 001c 7B68     		ldr	r3, [r7, #4]
 2643 001e 1100     		movs	r1, r2
 2644 0020 1800     		movs	r0, r3
 2645 0022 FFF7FEFF 		bl	LPSCI_DisableInterrupts
 686:../drivers/fsl_lpsci.c **** 
 687:../drivers/fsl_lpsci.c ****     handle->txDataSize = 0;
 2646              		.loc 4 687 24
 2647 0026 3B68     		ldr	r3, [r7]
 2648 0028 0022     		movs	r2, #0
 2649 002a 5A60     		str	r2, [r3, #4]
 688:../drivers/fsl_lpsci.c ****     handle->txState = kLPSCI_TxIdle;
 2650              		.loc 4 688 21
 2651 002c 3B68     		ldr	r3, [r7]
 2652 002e 2C22     		movs	r2, #44
 2653 0030 0021     		movs	r1, #0
 2654 0032 9954     		strb	r1, [r3, r2]
 689:../drivers/fsl_lpsci.c **** }
 2655              		.loc 4 689 1
 2656 0034 C046     		nop
 2657 0036 BD46     		mov	sp, r7
 2658 0038 02B0     		add	sp, sp, #8
 2659              		@ sp needed
 2660 003a 80BD     		pop	{r7, pc}
 2661              	.L155:
 2662              		.align	2
 2663              	.L154:
 2664 003c 00000000 		.word	.LC41
 2665              		.cfi_endproc
 2666              	.LFE83:
 2668              		.section	.rodata.LPSCI_TransferGetSendCount.str1.4,"aMS",%progbits,1
 2669              		.align	2
 2670              	.LC43:
 2671 0000 2E66736C 		.ascii	".fsl_lpsci.c:693 : handle\000"
 2671      5F6C7073 
 2671      63692E63 
 2671      3A363933 
 2671      203A2068 
 2672 001a 0000     		.align	2
 2673              	.LC45:
 2674 001c 2E66736C 		.ascii	".fsl_lpsci.c:694 : count\000"
 2674      5F6C7073 
 2674      63692E63 
 2674      3A363934 
 2674      203A2063 
 2675              		.section	.text.LPSCI_TransferGetSendCount,"ax",%progbits
 2676              		.align	1
 2677              		.global	LPSCI_TransferGetSendCount
 2678              		.syntax unified
 2679              		.code	16
 2680              		.thumb_func
 2681              		.fpu softvfp
 2683              	LPSCI_TransferGetSendCount:
 2684              	.LFB84:
 690:../drivers/fsl_lpsci.c **** 
 691:../drivers/fsl_lpsci.c **** status_t LPSCI_TransferGetSendCount(UART0_Type *base, lpsci_handle_t *handle, uint32_t *count)
 692:../drivers/fsl_lpsci.c **** {
 2685              		.loc 4 692 1
 2686              		.cfi_startproc
 2687              		@ args = 0, pretend = 0, frame = 16
 2688              		@ frame_needed = 1, uses_anonymous_args = 0
 2689 0000 80B5     		push	{r7, lr}
 2690              		.cfi_def_cfa_offset 8
 2691              		.cfi_offset 7, -8
 2692              		.cfi_offset 14, -4
 2693 0002 84B0     		sub	sp, sp, #16
 2694              		.cfi_def_cfa_offset 24
 2695 0004 00AF     		add	r7, sp, #0
 2696              		.cfi_def_cfa_register 7
 2697 0006 F860     		str	r0, [r7, #12]
 2698 0008 B960     		str	r1, [r7, #8]
 2699 000a 7A60     		str	r2, [r7, #4]
 693:../drivers/fsl_lpsci.c ****     assert(handle);
 2700              		.loc 4 693 5
 2701 000c BB68     		ldr	r3, [r7, #8]
 2702 000e 002B     		cmp	r3, #0
 2703 0010 03D1     		bne	.L157
 2704              		.loc 4 693 5 is_stmt 0 discriminator 1
 2705 0012 0F4B     		ldr	r3, .L161
 2706 0014 1800     		movs	r0, r3
 2707 0016 FFF7FEFF 		bl	__assertion_failed
 2708              	.L157:
 694:../drivers/fsl_lpsci.c ****     assert(count);
 2709              		.loc 4 694 5 is_stmt 1
 2710 001a 7B68     		ldr	r3, [r7, #4]
 2711 001c 002B     		cmp	r3, #0
 2712 001e 03D1     		bne	.L158
 2713              		.loc 4 694 5 is_stmt 0 discriminator 1
 2714 0020 0C4B     		ldr	r3, .L161+4
 2715 0022 1800     		movs	r0, r3
 2716 0024 FFF7FEFF 		bl	__assertion_failed
 2717              	.L158:
 695:../drivers/fsl_lpsci.c **** 
 696:../drivers/fsl_lpsci.c ****     if (kLPSCI_TxIdle == handle->txState)
 2718              		.loc 4 696 32 is_stmt 1
 2719 0028 BB68     		ldr	r3, [r7, #8]
 2720 002a 2C22     		movs	r2, #44
 2721 002c 9B5C     		ldrb	r3, [r3, r2]
 2722 002e DBB2     		uxtb	r3, r3
 2723              		.loc 4 696 8
 2724 0030 002B     		cmp	r3, #0
 2725 0032 01D1     		bne	.L159
 697:../drivers/fsl_lpsci.c ****     {
 698:../drivers/fsl_lpsci.c ****         return kStatus_NoTransferInProgress;
 2726              		.loc 4 698 16
 2727 0034 0623     		movs	r3, #6
 2728 0036 07E0     		b	.L160
 2729              	.L159:
 699:../drivers/fsl_lpsci.c ****     }
 700:../drivers/fsl_lpsci.c **** 
 701:../drivers/fsl_lpsci.c ****     *count = handle->txDataSizeAll - handle->txDataSize;
 2730              		.loc 4 701 20
 2731 0038 BB68     		ldr	r3, [r7, #8]
 2732 003a 9A68     		ldr	r2, [r3, #8]
 2733              		.loc 4 701 44
 2734 003c BB68     		ldr	r3, [r7, #8]
 2735 003e 5B68     		ldr	r3, [r3, #4]
 2736              		.loc 4 701 36
 2737 0040 D21A     		subs	r2, r2, r3
 2738              		.loc 4 701 12
 2739 0042 7B68     		ldr	r3, [r7, #4]
 2740 0044 1A60     		str	r2, [r3]
 702:../drivers/fsl_lpsci.c **** 
 703:../drivers/fsl_lpsci.c ****     return kStatus_Success;
 2741              		.loc 4 703 12
 2742 0046 0023     		movs	r3, #0
 2743              	.L160:
 704:../drivers/fsl_lpsci.c **** }
 2744              		.loc 4 704 1
 2745 0048 1800     		movs	r0, r3
 2746 004a BD46     		mov	sp, r7
 2747 004c 04B0     		add	sp, sp, #16
 2748              		@ sp needed
 2749 004e 80BD     		pop	{r7, pc}
 2750              	.L162:
 2751              		.align	2
 2752              	.L161:
 2753 0050 00000000 		.word	.LC43
 2754 0054 1C000000 		.word	.LC45
 2755              		.cfi_endproc
 2756              	.LFE84:
 2758              		.section	.rodata.LPSCI_TransferReceiveNonBlocking.str1.4,"aMS",%progbits,1
 2759              		.align	2
 2760              	.LC47:
 2761 0000 2E66736C 		.ascii	".fsl_lpsci.c:711 : handle\000"
 2761      5F6C7073 
 2761      63692E63 
 2761      3A373131 
 2761      203A2068 
 2762 001a 0000     		.align	2
 2763              	.LC49:
 2764 001c 2E66736C 		.ascii	".fsl_lpsci.c:712 : xfer\000"
 2764      5F6C7073 
 2764      63692E63 
 2764      3A373132 
 2764      203A2078 
 2765              		.align	2
 2766              	.LC51:
 2767 0034 2E66736C 		.ascii	".fsl_lpsci.c:713 : xfer->dataSize\000"
 2767      5F6C7073 
 2767      63692E63 
 2767      3A373133 
 2767      203A2078 
 2768 0056 0000     		.align	2
 2769              	.LC53:
 2770 0058 2E66736C 		.ascii	".fsl_lpsci.c:714 : xfer->data\000"
 2770      5F6C7073 
 2770      63692E63 
 2770      3A373134 
 2770      203A2078 
 2771              		.section	.text.LPSCI_TransferReceiveNonBlocking,"ax",%progbits
 2772              		.align	1
 2773              		.global	LPSCI_TransferReceiveNonBlocking
 2774              		.syntax unified
 2775              		.code	16
 2776              		.thumb_func
 2777              		.fpu softvfp
 2779              	LPSCI_TransferReceiveNonBlocking:
 2780              	.LFB85:
 705:../drivers/fsl_lpsci.c **** 
 706:../drivers/fsl_lpsci.c **** status_t LPSCI_TransferReceiveNonBlocking(UART0_Type *base,
 707:../drivers/fsl_lpsci.c ****                                           lpsci_handle_t *handle,
 708:../drivers/fsl_lpsci.c ****                                           lpsci_transfer_t *xfer,
 709:../drivers/fsl_lpsci.c ****                                           size_t *receivedBytes)
 710:../drivers/fsl_lpsci.c **** {
 2781              		.loc 4 710 1
 2782              		.cfi_startproc
 2783              		@ args = 0, pretend = 0, frame = 40
 2784              		@ frame_needed = 1, uses_anonymous_args = 0
 2785 0000 90B5     		push	{r4, r7, lr}
 2786              		.cfi_def_cfa_offset 12
 2787              		.cfi_offset 4, -12
 2788              		.cfi_offset 7, -8
 2789              		.cfi_offset 14, -4
 2790 0002 8BB0     		sub	sp, sp, #44
 2791              		.cfi_def_cfa_offset 56
 2792 0004 00AF     		add	r7, sp, #0
 2793              		.cfi_def_cfa_register 7
 2794 0006 F860     		str	r0, [r7, #12]
 2795 0008 B960     		str	r1, [r7, #8]
 2796 000a 7A60     		str	r2, [r7, #4]
 2797 000c 3B60     		str	r3, [r7]
 711:../drivers/fsl_lpsci.c ****     assert(handle);
 2798              		.loc 4 711 5
 2799 000e BB68     		ldr	r3, [r7, #8]
 2800 0010 002B     		cmp	r3, #0
 2801 0012 03D1     		bne	.L164
 2802              		.loc 4 711 5 is_stmt 0 discriminator 1
 2803 0014 684B     		ldr	r3, .L181
 2804 0016 1800     		movs	r0, r3
 2805 0018 FFF7FEFF 		bl	__assertion_failed
 2806              	.L164:
 712:../drivers/fsl_lpsci.c ****     assert(xfer);
 2807              		.loc 4 712 5 is_stmt 1
 2808 001c 7B68     		ldr	r3, [r7, #4]
 2809 001e 002B     		cmp	r3, #0
 2810 0020 03D1     		bne	.L165
 2811              		.loc 4 712 5 is_stmt 0 discriminator 1
 2812 0022 664B     		ldr	r3, .L181+4
 2813 0024 1800     		movs	r0, r3
 2814 0026 FFF7FEFF 		bl	__assertion_failed
 2815              	.L165:
 713:../drivers/fsl_lpsci.c ****     assert(xfer->dataSize);
 2816              		.loc 4 713 5 is_stmt 1
 2817 002a 7B68     		ldr	r3, [r7, #4]
 2818 002c 5B68     		ldr	r3, [r3, #4]
 2819 002e 002B     		cmp	r3, #0
 2820 0030 03D1     		bne	.L166
 2821              		.loc 4 713 5 is_stmt 0 discriminator 1
 2822 0032 634B     		ldr	r3, .L181+8
 2823 0034 1800     		movs	r0, r3
 2824 0036 FFF7FEFF 		bl	__assertion_failed
 2825              	.L166:
 714:../drivers/fsl_lpsci.c ****     assert(xfer->data);
 2826              		.loc 4 714 5 is_stmt 1
 2827 003a 7B68     		ldr	r3, [r7, #4]
 2828 003c 1B68     		ldr	r3, [r3]
 2829 003e 002B     		cmp	r3, #0
 2830 0040 03D1     		bne	.L167
 2831              		.loc 4 714 5 is_stmt 0 discriminator 1
 2832 0042 604B     		ldr	r3, .L181+12
 2833 0044 1800     		movs	r0, r3
 2834 0046 FFF7FEFF 		bl	__assertion_failed
 2835              	.L167:
 715:../drivers/fsl_lpsci.c **** 
 716:../drivers/fsl_lpsci.c ****     uint32_t i;
 717:../drivers/fsl_lpsci.c ****     status_t status;
 718:../drivers/fsl_lpsci.c ****     /* How many bytes to copy from ring buffer to user memory. */
 719:../drivers/fsl_lpsci.c ****     size_t bytesToCopy = 0U;
 2836              		.loc 4 719 12 is_stmt 1
 2837 004a 0023     		movs	r3, #0
 2838 004c 7B61     		str	r3, [r7, #20]
 720:../drivers/fsl_lpsci.c ****     /* How many bytes to receive. */
 721:../drivers/fsl_lpsci.c ****     size_t bytesToReceive;
 722:../drivers/fsl_lpsci.c ****     /* How many bytes currently have received. */
 723:../drivers/fsl_lpsci.c ****     size_t bytesCurrentReceived;
 724:../drivers/fsl_lpsci.c **** 
 725:../drivers/fsl_lpsci.c ****     /* How to get data:
 726:../drivers/fsl_lpsci.c ****        1. If RX ring buffer is not enabled, then save xfer->data and xfer->dataSize
 727:../drivers/fsl_lpsci.c ****           to lpsci handle, enable interrupt to store received data to xfer->data. When
 728:../drivers/fsl_lpsci.c ****           all data received, trigger callback.
 729:../drivers/fsl_lpsci.c ****        2. If RX ring buffer is enabled and not empty, get data from ring buffer first.
 730:../drivers/fsl_lpsci.c ****           If there are enough data in ring buffer, copy them to xfer->data and return.
 731:../drivers/fsl_lpsci.c ****           If there are not enough data in ring buffer, copy all of them to xfer->data,
 732:../drivers/fsl_lpsci.c ****           save the xfer->data remained empty space to lpsci handle, receive data
 733:../drivers/fsl_lpsci.c ****           to this empty space and trigger callback when finished. */
 734:../drivers/fsl_lpsci.c **** 
 735:../drivers/fsl_lpsci.c ****     if (kLPSCI_RxBusy == handle->rxState)
 2839              		.loc 4 735 32
 2840 004e BB68     		ldr	r3, [r7, #8]
 2841 0050 2D22     		movs	r2, #45
 2842 0052 9B5C     		ldrb	r3, [r3, r2]
 2843 0054 DBB2     		uxtb	r3, r3
 2844              		.loc 4 735 8
 2845 0056 032B     		cmp	r3, #3
 2846 0058 02D1     		bne	.L168
 736:../drivers/fsl_lpsci.c ****     {
 737:../drivers/fsl_lpsci.c ****         status = kStatus_LPSCI_RxBusy;
 2847              		.loc 4 737 16
 2848 005a 5B4B     		ldr	r3, .L181+16
 2849 005c 3B62     		str	r3, [r7, #32]
 2850 005e A6E0     		b	.L169
 2851              	.L168:
 738:../drivers/fsl_lpsci.c ****     }
 739:../drivers/fsl_lpsci.c ****     else
 740:../drivers/fsl_lpsci.c ****     {
 741:../drivers/fsl_lpsci.c ****         bytesToReceive = xfer->dataSize;
 2852              		.loc 4 741 24
 2853 0060 7B68     		ldr	r3, [r7, #4]
 2854 0062 5B68     		ldr	r3, [r3, #4]
 2855 0064 FB61     		str	r3, [r7, #28]
 742:../drivers/fsl_lpsci.c ****         bytesCurrentReceived = 0U;
 2856              		.loc 4 742 30
 2857 0066 0023     		movs	r3, #0
 2858 0068 BB61     		str	r3, [r7, #24]
 743:../drivers/fsl_lpsci.c **** 
 744:../drivers/fsl_lpsci.c ****         /* If RX ring buffer is used. */
 745:../drivers/fsl_lpsci.c ****         if (handle->rxRingBuffer)
 2859              		.loc 4 745 19
 2860 006a BB68     		ldr	r3, [r7, #8]
 2861 006c 9B69     		ldr	r3, [r3, #24]
 2862              		.loc 4 745 12
 2863 006e 002B     		cmp	r3, #0
 2864 0070 00D1     		bne	.LCB2301
 2865 0072 6EE0     		b	.L170	@long jump
 2866              	.LCB2301:
 746:../drivers/fsl_lpsci.c ****         {
 747:../drivers/fsl_lpsci.c ****             /* Disable LPSCI RX IRQ, protect ring buffer. */
 748:../drivers/fsl_lpsci.c ****             LPSCI_DisableInterrupts(base, kLPSCI_RxDataRegFullInterruptEnable);
 2867              		.loc 4 748 13
 2868 0074 8023     		movs	r3, #128
 2869 0076 9A01     		lsls	r2, r3, #6
 2870 0078 FB68     		ldr	r3, [r7, #12]
 2871 007a 1100     		movs	r1, r2
 2872 007c 1800     		movs	r0, r3
 2873 007e FFF7FEFF 		bl	LPSCI_DisableInterrupts
 749:../drivers/fsl_lpsci.c **** 
 750:../drivers/fsl_lpsci.c ****             /* How many bytes in RX ring buffer currently. */
 751:../drivers/fsl_lpsci.c ****             bytesToCopy = LPSCI_TransferGetRxRingBufferLength(handle);
 2874              		.loc 4 751 27
 2875 0082 BB68     		ldr	r3, [r7, #8]
 2876 0084 1800     		movs	r0, r3
 2877 0086 FFF7FEFF 		bl	LPSCI_TransferGetRxRingBufferLength
 2878 008a 0300     		movs	r3, r0
 2879 008c 7B61     		str	r3, [r7, #20]
 752:../drivers/fsl_lpsci.c **** 
 753:../drivers/fsl_lpsci.c ****             if (bytesToCopy)
 2880              		.loc 4 753 16
 2881 008e 7B69     		ldr	r3, [r7, #20]
 2882 0090 002B     		cmp	r3, #0
 2883 0092 34D0     		beq	.L171
 754:../drivers/fsl_lpsci.c ****             {
 755:../drivers/fsl_lpsci.c ****                 bytesToCopy = MIN(bytesToReceive, bytesToCopy);
 2884              		.loc 4 755 29
 2885 0094 FA69     		ldr	r2, [r7, #28]
 2886 0096 7B69     		ldr	r3, [r7, #20]
 2887 0098 9342     		cmp	r3, r2
 2888 009a 00D9     		bls	.L172
 2889 009c 1300     		movs	r3, r2
 2890              	.L172:
 2891 009e 7B61     		str	r3, [r7, #20]
 756:../drivers/fsl_lpsci.c **** 
 757:../drivers/fsl_lpsci.c ****                 bytesToReceive -= bytesToCopy;
 2892              		.loc 4 757 32
 2893 00a0 FA69     		ldr	r2, [r7, #28]
 2894 00a2 7B69     		ldr	r3, [r7, #20]
 2895 00a4 D31A     		subs	r3, r2, r3
 2896 00a6 FB61     		str	r3, [r7, #28]
 758:../drivers/fsl_lpsci.c **** 
 759:../drivers/fsl_lpsci.c ****                 /* Copy data from ring buffer to user memory. */
 760:../drivers/fsl_lpsci.c ****                 for (i = 0U; i < bytesToCopy; i++)
 2897              		.loc 4 760 24
 2898 00a8 0023     		movs	r3, #0
 2899 00aa 7B62     		str	r3, [r7, #36]
 2900              		.loc 4 760 17
 2901 00ac 23E0     		b	.L173
 2902              	.L176:
 761:../drivers/fsl_lpsci.c ****                 {
 762:../drivers/fsl_lpsci.c ****                     xfer->data[bytesCurrentReceived++] = handle->rxRingBuffer[handle->rxRingBufferT
 2903              		.loc 4 762 64
 2904 00ae BB68     		ldr	r3, [r7, #8]
 2905 00b0 9B69     		ldr	r3, [r3, #24]
 2906              		.loc 4 762 85
 2907 00b2 BA68     		ldr	r2, [r7, #8]
 2908 00b4 528C     		ldrh	r2, [r2, #34]
 2909 00b6 92B2     		uxth	r2, r2
 2910              		.loc 4 762 78
 2911 00b8 9A18     		adds	r2, r3, r2
 2912              		.loc 4 762 25
 2913 00ba 7B68     		ldr	r3, [r7, #4]
 2914 00bc 1968     		ldr	r1, [r3]
 2915              		.loc 4 762 52
 2916 00be BB69     		ldr	r3, [r7, #24]
 2917 00c0 581C     		adds	r0, r3, #1
 2918 00c2 B861     		str	r0, [r7, #24]
 2919              		.loc 4 762 31
 2920 00c4 CB18     		adds	r3, r1, r3
 2921              		.loc 4 762 78
 2922 00c6 1278     		ldrb	r2, [r2]
 2923              		.loc 4 762 56
 2924 00c8 1A70     		strb	r2, [r3]
 763:../drivers/fsl_lpsci.c **** 
 764:../drivers/fsl_lpsci.c ****                     /* Wrap to 0. Not use modulo (%) because it might be large and slow. */
 765:../drivers/fsl_lpsci.c ****                     if (handle->rxRingBufferTail + 1U == handle->rxRingBufferSize)
 2925              		.loc 4 765 31
 2926 00ca BB68     		ldr	r3, [r7, #8]
 2927 00cc 5B8C     		ldrh	r3, [r3, #34]
 2928 00ce 9BB2     		uxth	r3, r3
 2929              		.loc 4 765 50
 2930 00d0 5A1C     		adds	r2, r3, #1
 2931              		.loc 4 765 64
 2932 00d2 BB68     		ldr	r3, [r7, #8]
 2933 00d4 DB69     		ldr	r3, [r3, #28]
 2934              		.loc 4 765 24
 2935 00d6 9A42     		cmp	r2, r3
 2936 00d8 03D1     		bne	.L174
 766:../drivers/fsl_lpsci.c ****                     {
 767:../drivers/fsl_lpsci.c ****                         handle->rxRingBufferTail = 0U;
 2937              		.loc 4 767 50
 2938 00da BB68     		ldr	r3, [r7, #8]
 2939 00dc 0022     		movs	r2, #0
 2940 00de 5A84     		strh	r2, [r3, #34]
 2941 00e0 06E0     		b	.L175
 2942              	.L174:
 768:../drivers/fsl_lpsci.c ****                     }
 769:../drivers/fsl_lpsci.c ****                     else
 770:../drivers/fsl_lpsci.c ****                     {
 771:../drivers/fsl_lpsci.c ****                         handle->rxRingBufferTail++;
 2943              		.loc 4 771 31
 2944 00e2 BB68     		ldr	r3, [r7, #8]
 2945 00e4 5B8C     		ldrh	r3, [r3, #34]
 2946 00e6 9BB2     		uxth	r3, r3
 2947              		.loc 4 771 49
 2948 00e8 0133     		adds	r3, r3, #1
 2949 00ea 9AB2     		uxth	r2, r3
 2950 00ec BB68     		ldr	r3, [r7, #8]
 2951 00ee 5A84     		strh	r2, [r3, #34]
 2952              	.L175:
 760:../drivers/fsl_lpsci.c ****                 {
 2953              		.loc 4 760 48 discriminator 2
 2954 00f0 7B6A     		ldr	r3, [r7, #36]
 2955 00f2 0133     		adds	r3, r3, #1
 2956 00f4 7B62     		str	r3, [r7, #36]
 2957              	.L173:
 760:../drivers/fsl_lpsci.c ****                 {
 2958              		.loc 4 760 17 discriminator 1
 2959 00f6 7A6A     		ldr	r2, [r7, #36]
 2960 00f8 7B69     		ldr	r3, [r7, #20]
 2961 00fa 9A42     		cmp	r2, r3
 2962 00fc D7D3     		bcc	.L176
 2963              	.L171:
 772:../drivers/fsl_lpsci.c ****                     }
 773:../drivers/fsl_lpsci.c ****                 }
 774:../drivers/fsl_lpsci.c ****             }
 775:../drivers/fsl_lpsci.c **** 
 776:../drivers/fsl_lpsci.c ****             /* If ring buffer does not have enough data, still need to read more data. */
 777:../drivers/fsl_lpsci.c ****             if (bytesToReceive)
 2964              		.loc 4 777 16
 2965 00fe FB69     		ldr	r3, [r7, #28]
 2966 0100 002B     		cmp	r3, #0
 2967 0102 0FD0     		beq	.L177
 778:../drivers/fsl_lpsci.c ****             {
 779:../drivers/fsl_lpsci.c ****                 /* No data in ring buffer, save the request to lpsci handle. */
 780:../drivers/fsl_lpsci.c ****                 handle->rxData = xfer->data + bytesCurrentReceived;
 2968              		.loc 4 780 38
 2969 0104 7B68     		ldr	r3, [r7, #4]
 2970 0106 1A68     		ldr	r2, [r3]
 2971              		.loc 4 780 45
 2972 0108 BB69     		ldr	r3, [r7, #24]
 2973 010a D218     		adds	r2, r2, r3
 2974              		.loc 4 780 32
 2975 010c BB68     		ldr	r3, [r7, #8]
 2976 010e DA60     		str	r2, [r3, #12]
 781:../drivers/fsl_lpsci.c ****                 handle->rxDataSize = bytesToReceive;
 2977              		.loc 4 781 36
 2978 0110 BB68     		ldr	r3, [r7, #8]
 2979 0112 FA69     		ldr	r2, [r7, #28]
 2980 0114 1A61     		str	r2, [r3, #16]
 782:../drivers/fsl_lpsci.c ****                 handle->rxDataSizeAll = bytesToReceive;
 2981              		.loc 4 782 39
 2982 0116 BB68     		ldr	r3, [r7, #8]
 2983 0118 FA69     		ldr	r2, [r7, #28]
 2984 011a 5A61     		str	r2, [r3, #20]
 783:../drivers/fsl_lpsci.c ****                 handle->rxState = kLPSCI_RxBusy;
 2985              		.loc 4 783 33
 2986 011c BB68     		ldr	r3, [r7, #8]
 2987 011e 2D22     		movs	r2, #45
 2988 0120 0321     		movs	r1, #3
 2989 0122 9954     		strb	r1, [r3, r2]
 2990              	.L177:
 784:../drivers/fsl_lpsci.c ****             }
 785:../drivers/fsl_lpsci.c **** 
 786:../drivers/fsl_lpsci.c ****             /* Enable LPSCI RX IRQ if previously enabled. */
 787:../drivers/fsl_lpsci.c ****             LPSCI_EnableInterrupts(base, kLPSCI_RxDataRegFullInterruptEnable);
 2991              		.loc 4 787 13
 2992 0124 8023     		movs	r3, #128
 2993 0126 9A01     		lsls	r2, r3, #6
 2994 0128 FB68     		ldr	r3, [r7, #12]
 2995 012a 1100     		movs	r1, r2
 2996 012c 1800     		movs	r0, r3
 2997 012e FFF7FEFF 		bl	LPSCI_EnableInterrupts
 788:../drivers/fsl_lpsci.c **** 
 789:../drivers/fsl_lpsci.c ****             /* Call user callback since all data are received. */
 790:../drivers/fsl_lpsci.c ****             if (0 == bytesToReceive)
 2998              		.loc 4 790 16
 2999 0132 FB69     		ldr	r3, [r7, #28]
 3000 0134 002B     		cmp	r3, #0
 3001 0136 32D1     		bne	.L178
 791:../drivers/fsl_lpsci.c ****             {
 792:../drivers/fsl_lpsci.c ****                 if (handle->callback)
 3002              		.loc 4 792 27
 3003 0138 BB68     		ldr	r3, [r7, #8]
 3004 013a 5B6A     		ldr	r3, [r3, #36]
 3005              		.loc 4 792 20
 3006 013c 002B     		cmp	r3, #0
 3007 013e 2ED0     		beq	.L178
 793:../drivers/fsl_lpsci.c ****                 {
 794:../drivers/fsl_lpsci.c ****                     handle->callback(base, handle, kStatus_LPSCI_RxIdle, handle->userData);
 3008              		.loc 4 794 27
 3009 0140 BB68     		ldr	r3, [r7, #8]
 3010 0142 5C6A     		ldr	r4, [r3, #36]
 3011              		.loc 4 794 21
 3012 0144 BB68     		ldr	r3, [r7, #8]
 3013 0146 9B6A     		ldr	r3, [r3, #40]
 3014 0148 204A     		ldr	r2, .L181+20
 3015 014a B968     		ldr	r1, [r7, #8]
 3016 014c F868     		ldr	r0, [r7, #12]
 3017 014e A047     		blx	r4
 3018              	.LVL10:
 3019 0150 25E0     		b	.L178
 3020              	.L170:
 795:../drivers/fsl_lpsci.c ****                 }
 796:../drivers/fsl_lpsci.c ****             }
 797:../drivers/fsl_lpsci.c ****         }
 798:../drivers/fsl_lpsci.c ****         /* Ring buffer not used. */
 799:../drivers/fsl_lpsci.c ****         else
 800:../drivers/fsl_lpsci.c ****         {
 801:../drivers/fsl_lpsci.c ****             handle->rxData = xfer->data + bytesCurrentReceived;
 3021              		.loc 4 801 34
 3022 0152 7B68     		ldr	r3, [r7, #4]
 3023 0154 1A68     		ldr	r2, [r3]
 3024              		.loc 4 801 41
 3025 0156 BB69     		ldr	r3, [r7, #24]
 3026 0158 D218     		adds	r2, r2, r3
 3027              		.loc 4 801 28
 3028 015a BB68     		ldr	r3, [r7, #8]
 3029 015c DA60     		str	r2, [r3, #12]
 802:../drivers/fsl_lpsci.c ****             handle->rxDataSize = bytesToReceive;
 3030              		.loc 4 802 32
 3031 015e BB68     		ldr	r3, [r7, #8]
 3032 0160 FA69     		ldr	r2, [r7, #28]
 3033 0162 1A61     		str	r2, [r3, #16]
 803:../drivers/fsl_lpsci.c ****             handle->rxDataSizeAll = bytesToReceive;
 3034              		.loc 4 803 35
 3035 0164 BB68     		ldr	r3, [r7, #8]
 3036 0166 FA69     		ldr	r2, [r7, #28]
 3037 0168 5A61     		str	r2, [r3, #20]
 804:../drivers/fsl_lpsci.c ****             handle->rxState = kLPSCI_RxBusy;
 3038              		.loc 4 804 29
 3039 016a BB68     		ldr	r3, [r7, #8]
 3040 016c 2D22     		movs	r2, #45
 3041 016e 0321     		movs	r1, #3
 3042 0170 9954     		strb	r1, [r3, r2]
 805:../drivers/fsl_lpsci.c **** 
 806:../drivers/fsl_lpsci.c ****             /* Enable RX interrupt. */
 807:../drivers/fsl_lpsci.c ****             LPSCI_EnableInterrupts(base, kLPSCI_RxDataRegFullInterruptEnable | kLPSCI_RxOverrunInte
 3043              		.loc 4 807 13
 3044 0172 A223     		movs	r3, #162
 3045 0174 1A03     		lsls	r2, r3, #12
 3046 0176 FB68     		ldr	r3, [r7, #12]
 3047 0178 1100     		movs	r1, r2
 3048 017a 1800     		movs	r0, r3
 3049 017c FFF7FEFF 		bl	LPSCI_EnableInterrupts
 808:../drivers/fsl_lpsci.c ****                                              kLPSCI_FramingErrorInterruptEnable);
 809:../drivers/fsl_lpsci.c ****             /* Enable parity error interrupt when parity mode is enable*/
 810:../drivers/fsl_lpsci.c ****             if (UART0_C1_PE_MASK & base->C1)
 3050              		.loc 4 810 40
 3051 0180 FB68     		ldr	r3, [r7, #12]
 3052 0182 9B78     		ldrb	r3, [r3, #2]
 3053 0184 DBB2     		uxtb	r3, r3
 3054              		.loc 4 810 17
 3055 0186 0222     		movs	r2, #2
 3056 0188 1340     		ands	r3, r2
 3057 018a DBB2     		uxtb	r3, r3
 3058              		.loc 4 810 16
 3059 018c 002B     		cmp	r3, #0
 3060 018e 06D0     		beq	.L178
 811:../drivers/fsl_lpsci.c ****             {
 812:../drivers/fsl_lpsci.c ****                 LPSCI_EnableInterrupts(base, kLPSCI_ParityErrorInterruptEnable);
 3061              		.loc 4 812 17
 3062 0190 8023     		movs	r3, #128
 3063 0192 5A02     		lsls	r2, r3, #9
 3064 0194 FB68     		ldr	r3, [r7, #12]
 3065 0196 1100     		movs	r1, r2
 3066 0198 1800     		movs	r0, r3
 3067 019a FFF7FEFF 		bl	LPSCI_EnableInterrupts
 3068              	.L178:
 813:../drivers/fsl_lpsci.c ****             }
 814:../drivers/fsl_lpsci.c ****         }
 815:../drivers/fsl_lpsci.c **** 
 816:../drivers/fsl_lpsci.c ****         /* Return the how many bytes have read. */
 817:../drivers/fsl_lpsci.c ****         if (receivedBytes)
 3069              		.loc 4 817 12
 3070 019e 3B68     		ldr	r3, [r7]
 3071 01a0 002B     		cmp	r3, #0
 3072 01a2 02D0     		beq	.L179
 818:../drivers/fsl_lpsci.c ****         {
 819:../drivers/fsl_lpsci.c ****             *receivedBytes = bytesCurrentReceived;
 3073              		.loc 4 819 28
 3074 01a4 3B68     		ldr	r3, [r7]
 3075 01a6 BA69     		ldr	r2, [r7, #24]
 3076 01a8 1A60     		str	r2, [r3]
 3077              	.L179:
 820:../drivers/fsl_lpsci.c ****         }
 821:../drivers/fsl_lpsci.c **** 
 822:../drivers/fsl_lpsci.c ****         status = kStatus_Success;
 3078              		.loc 4 822 16
 3079 01aa 0023     		movs	r3, #0
 3080 01ac 3B62     		str	r3, [r7, #32]
 3081              	.L169:
 823:../drivers/fsl_lpsci.c ****     }
 824:../drivers/fsl_lpsci.c **** 
 825:../drivers/fsl_lpsci.c ****     return status;
 3082              		.loc 4 825 12
 3083 01ae 3B6A     		ldr	r3, [r7, #32]
 826:../drivers/fsl_lpsci.c **** }
 3084              		.loc 4 826 1
 3085 01b0 1800     		movs	r0, r3
 3086 01b2 BD46     		mov	sp, r7
 3087 01b4 0BB0     		add	sp, sp, #44
 3088              		@ sp needed
 3089 01b6 90BD     		pop	{r4, r7, pc}
 3090              	.L182:
 3091              		.align	2
 3092              	.L181:
 3093 01b8 00000000 		.word	.LC47
 3094 01bc 1C000000 		.word	.LC49
 3095 01c0 34000000 		.word	.LC51
 3096 01c4 58000000 		.word	.LC53
 3097 01c8 B1040000 		.word	1201
 3098 01cc B3040000 		.word	1203
 3099              		.cfi_endproc
 3100              	.LFE85:
 3102              		.section	.rodata.LPSCI_TransferAbortReceive.str1.4,"aMS",%progbits,1
 3103              		.align	2
 3104              	.LC55:
 3105 0000 2E66736C 		.ascii	".fsl_lpsci.c:830 : handle\000"
 3105      5F6C7073 
 3105      63692E63 
 3105      3A383330 
 3105      203A2068 
 3106              		.section	.text.LPSCI_TransferAbortReceive,"ax",%progbits
 3107              		.align	1
 3108              		.global	LPSCI_TransferAbortReceive
 3109              		.syntax unified
 3110              		.code	16
 3111              		.thumb_func
 3112              		.fpu softvfp
 3114              	LPSCI_TransferAbortReceive:
 3115              	.LFB86:
 827:../drivers/fsl_lpsci.c **** 
 828:../drivers/fsl_lpsci.c **** void LPSCI_TransferAbortReceive(UART0_Type *base, lpsci_handle_t *handle)
 829:../drivers/fsl_lpsci.c **** {
 3116              		.loc 4 829 1
 3117              		.cfi_startproc
 3118              		@ args = 0, pretend = 0, frame = 8
 3119              		@ frame_needed = 1, uses_anonymous_args = 0
 3120 0000 80B5     		push	{r7, lr}
 3121              		.cfi_def_cfa_offset 8
 3122              		.cfi_offset 7, -8
 3123              		.cfi_offset 14, -4
 3124 0002 82B0     		sub	sp, sp, #8
 3125              		.cfi_def_cfa_offset 16
 3126 0004 00AF     		add	r7, sp, #0
 3127              		.cfi_def_cfa_register 7
 3128 0006 7860     		str	r0, [r7, #4]
 3129 0008 3960     		str	r1, [r7]
 830:../drivers/fsl_lpsci.c ****     assert(handle);
 3130              		.loc 4 830 5
 3131 000a 3B68     		ldr	r3, [r7]
 3132 000c 002B     		cmp	r3, #0
 3133 000e 03D1     		bne	.L184
 3134              		.loc 4 830 5 is_stmt 0 discriminator 1
 3135 0010 144B     		ldr	r3, .L186
 3136 0012 1800     		movs	r0, r3
 3137 0014 FFF7FEFF 		bl	__assertion_failed
 3138              	.L184:
 831:../drivers/fsl_lpsci.c **** 
 832:../drivers/fsl_lpsci.c ****     /* Only abort the receive to handle->rxData, the RX ring buffer is still working. */
 833:../drivers/fsl_lpsci.c ****     if (!handle->rxRingBuffer)
 3139              		.loc 4 833 16 is_stmt 1
 3140 0018 3B68     		ldr	r3, [r7]
 3141 001a 9B69     		ldr	r3, [r3, #24]
 3142              		.loc 4 833 8
 3143 001c 002B     		cmp	r3, #0
 3144 001e 15D1     		bne	.L185
 834:../drivers/fsl_lpsci.c ****     {
 835:../drivers/fsl_lpsci.c ****         /* Disable RX interrupt. */
 836:../drivers/fsl_lpsci.c ****         LPSCI_DisableInterrupts(base, kLPSCI_RxDataRegFullInterruptEnable | kLPSCI_RxOverrunInterru
 3145              		.loc 4 836 9
 3146 0020 A223     		movs	r3, #162
 3147 0022 1A03     		lsls	r2, r3, #12
 3148 0024 7B68     		ldr	r3, [r7, #4]
 3149 0026 1100     		movs	r1, r2
 3150 0028 1800     		movs	r0, r3
 3151 002a FFF7FEFF 		bl	LPSCI_DisableInterrupts
 837:../drivers/fsl_lpsci.c ****                                           kLPSCI_FramingErrorInterruptEnable);
 838:../drivers/fsl_lpsci.c ****         /* Disable parity error interrupt when parity mode is enable*/
 839:../drivers/fsl_lpsci.c ****         if (UART0_C1_PE_MASK & base->C1)
 3152              		.loc 4 839 36
 3153 002e 7B68     		ldr	r3, [r7, #4]
 3154 0030 9B78     		ldrb	r3, [r3, #2]
 3155 0032 DBB2     		uxtb	r3, r3
 3156              		.loc 4 839 13
 3157 0034 0222     		movs	r2, #2
 3158 0036 1340     		ands	r3, r2
 3159 0038 DBB2     		uxtb	r3, r3
 3160              		.loc 4 839 12
 3161 003a 002B     		cmp	r3, #0
 3162 003c 06D0     		beq	.L185
 840:../drivers/fsl_lpsci.c ****         {
 841:../drivers/fsl_lpsci.c ****             LPSCI_DisableInterrupts(base, kLPSCI_ParityErrorInterruptEnable);
 3163              		.loc 4 841 13
 3164 003e 8023     		movs	r3, #128
 3165 0040 5A02     		lsls	r2, r3, #9
 3166 0042 7B68     		ldr	r3, [r7, #4]
 3167 0044 1100     		movs	r1, r2
 3168 0046 1800     		movs	r0, r3
 3169 0048 FFF7FEFF 		bl	LPSCI_DisableInterrupts
 3170              	.L185:
 842:../drivers/fsl_lpsci.c ****         }
 843:../drivers/fsl_lpsci.c ****     }
 844:../drivers/fsl_lpsci.c **** 
 845:../drivers/fsl_lpsci.c ****     handle->rxDataSize = 0U;
 3171              		.loc 4 845 24
 3172 004c 3B68     		ldr	r3, [r7]
 3173 004e 0022     		movs	r2, #0
 3174 0050 1A61     		str	r2, [r3, #16]
 846:../drivers/fsl_lpsci.c ****     handle->rxState = kLPSCI_RxIdle;
 3175              		.loc 4 846 21
 3176 0052 3B68     		ldr	r3, [r7]
 3177 0054 2D22     		movs	r2, #45
 3178 0056 0221     		movs	r1, #2
 3179 0058 9954     		strb	r1, [r3, r2]
 847:../drivers/fsl_lpsci.c **** }
 3180              		.loc 4 847 1
 3181 005a C046     		nop
 3182 005c BD46     		mov	sp, r7
 3183 005e 02B0     		add	sp, sp, #8
 3184              		@ sp needed
 3185 0060 80BD     		pop	{r7, pc}
 3186              	.L187:
 3187 0062 C046     		.align	2
 3188              	.L186:
 3189 0064 00000000 		.word	.LC55
 3190              		.cfi_endproc
 3191              	.LFE86:
 3193              		.section	.rodata.LPSCI_TransferGetReceiveCount.str1.4,"aMS",%progbits,1
 3194              		.align	2
 3195              	.LC57:
 3196 0000 2E66736C 		.ascii	".fsl_lpsci.c:851 : handle\000"
 3196      5F6C7073 
 3196      63692E63 
 3196      3A383531 
 3196      203A2068 
 3197 001a 0000     		.align	2
 3198              	.LC59:
 3199 001c 2E66736C 		.ascii	".fsl_lpsci.c:852 : count\000"
 3199      5F6C7073 
 3199      63692E63 
 3199      3A383532 
 3199      203A2063 
 3200              		.section	.text.LPSCI_TransferGetReceiveCount,"ax",%progbits
 3201              		.align	1
 3202              		.global	LPSCI_TransferGetReceiveCount
 3203              		.syntax unified
 3204              		.code	16
 3205              		.thumb_func
 3206              		.fpu softvfp
 3208              	LPSCI_TransferGetReceiveCount:
 3209              	.LFB87:
 848:../drivers/fsl_lpsci.c **** 
 849:../drivers/fsl_lpsci.c **** status_t LPSCI_TransferGetReceiveCount(UART0_Type *base, lpsci_handle_t *handle, uint32_t *count)
 850:../drivers/fsl_lpsci.c **** {
 3210              		.loc 4 850 1
 3211              		.cfi_startproc
 3212              		@ args = 0, pretend = 0, frame = 16
 3213              		@ frame_needed = 1, uses_anonymous_args = 0
 3214 0000 80B5     		push	{r7, lr}
 3215              		.cfi_def_cfa_offset 8
 3216              		.cfi_offset 7, -8
 3217              		.cfi_offset 14, -4
 3218 0002 84B0     		sub	sp, sp, #16
 3219              		.cfi_def_cfa_offset 24
 3220 0004 00AF     		add	r7, sp, #0
 3221              		.cfi_def_cfa_register 7
 3222 0006 F860     		str	r0, [r7, #12]
 3223 0008 B960     		str	r1, [r7, #8]
 3224 000a 7A60     		str	r2, [r7, #4]
 851:../drivers/fsl_lpsci.c ****     assert(handle);
 3225              		.loc 4 851 5
 3226 000c BB68     		ldr	r3, [r7, #8]
 3227 000e 002B     		cmp	r3, #0
 3228 0010 03D1     		bne	.L189
 3229              		.loc 4 851 5 is_stmt 0 discriminator 1
 3230 0012 0F4B     		ldr	r3, .L193
 3231 0014 1800     		movs	r0, r3
 3232 0016 FFF7FEFF 		bl	__assertion_failed
 3233              	.L189:
 852:../drivers/fsl_lpsci.c ****     assert(count);
 3234              		.loc 4 852 5 is_stmt 1
 3235 001a 7B68     		ldr	r3, [r7, #4]
 3236 001c 002B     		cmp	r3, #0
 3237 001e 03D1     		bne	.L190
 3238              		.loc 4 852 5 is_stmt 0 discriminator 1
 3239 0020 0C4B     		ldr	r3, .L193+4
 3240 0022 1800     		movs	r0, r3
 3241 0024 FFF7FEFF 		bl	__assertion_failed
 3242              	.L190:
 853:../drivers/fsl_lpsci.c **** 
 854:../drivers/fsl_lpsci.c ****     if (kLPSCI_RxIdle == handle->rxState)
 3243              		.loc 4 854 32 is_stmt 1
 3244 0028 BB68     		ldr	r3, [r7, #8]
 3245 002a 2D22     		movs	r2, #45
 3246 002c 9B5C     		ldrb	r3, [r3, r2]
 3247 002e DBB2     		uxtb	r3, r3
 3248              		.loc 4 854 8
 3249 0030 022B     		cmp	r3, #2
 3250 0032 01D1     		bne	.L191
 855:../drivers/fsl_lpsci.c ****     {
 856:../drivers/fsl_lpsci.c ****         return kStatus_NoTransferInProgress;
 3251              		.loc 4 856 16
 3252 0034 0623     		movs	r3, #6
 3253 0036 07E0     		b	.L192
 3254              	.L191:
 857:../drivers/fsl_lpsci.c ****     }
 858:../drivers/fsl_lpsci.c **** 
 859:../drivers/fsl_lpsci.c ****     *count = handle->rxDataSizeAll - handle->rxDataSize;
 3255              		.loc 4 859 20
 3256 0038 BB68     		ldr	r3, [r7, #8]
 3257 003a 5A69     		ldr	r2, [r3, #20]
 3258              		.loc 4 859 44
 3259 003c BB68     		ldr	r3, [r7, #8]
 3260 003e 1B69     		ldr	r3, [r3, #16]
 3261              		.loc 4 859 36
 3262 0040 D21A     		subs	r2, r2, r3
 3263              		.loc 4 859 12
 3264 0042 7B68     		ldr	r3, [r7, #4]
 3265 0044 1A60     		str	r2, [r3]
 860:../drivers/fsl_lpsci.c **** 
 861:../drivers/fsl_lpsci.c ****     return kStatus_Success;
 3266              		.loc 4 861 12
 3267 0046 0023     		movs	r3, #0
 3268              	.L192:
 862:../drivers/fsl_lpsci.c **** }
 3269              		.loc 4 862 1
 3270 0048 1800     		movs	r0, r3
 3271 004a BD46     		mov	sp, r7
 3272 004c 04B0     		add	sp, sp, #16
 3273              		@ sp needed
 3274 004e 80BD     		pop	{r7, pc}
 3275              	.L194:
 3276              		.align	2
 3277              	.L193:
 3278 0050 00000000 		.word	.LC57
 3279 0054 1C000000 		.word	.LC59
 3280              		.cfi_endproc
 3281              	.LFE87:
 3283              		.section	.rodata.LPSCI_TransferHandleIRQ.str1.4,"aMS",%progbits,1
 3284              		.align	2
 3285              	.LC61:
 3286 0000 2E66736C 		.ascii	".fsl_lpsci.c:866 : handle\000"
 3286      5F6C7073 
 3286      63692E63 
 3286      3A383636 
 3286      203A2068 
 3287              		.section	.text.LPSCI_TransferHandleIRQ,"ax",%progbits
 3288              		.align	1
 3289              		.global	LPSCI_TransferHandleIRQ
 3290              		.syntax unified
 3291              		.code	16
 3292              		.thumb_func
 3293              		.fpu softvfp
 3295              	LPSCI_TransferHandleIRQ:
 3296              	.LFB88:
 863:../drivers/fsl_lpsci.c **** 
 864:../drivers/fsl_lpsci.c **** void LPSCI_TransferHandleIRQ(UART0_Type *base, lpsci_handle_t *handle)
 865:../drivers/fsl_lpsci.c **** {
 3297              		.loc 4 865 1
 3298              		.cfi_startproc
 3299              		@ args = 0, pretend = 0, frame = 16
 3300              		@ frame_needed = 1, uses_anonymous_args = 0
 3301 0000 90B5     		push	{r4, r7, lr}
 3302              		.cfi_def_cfa_offset 12
 3303              		.cfi_offset 4, -12
 3304              		.cfi_offset 7, -8
 3305              		.cfi_offset 14, -4
 3306 0002 85B0     		sub	sp, sp, #20
 3307              		.cfi_def_cfa_offset 32
 3308 0004 00AF     		add	r7, sp, #0
 3309              		.cfi_def_cfa_register 7
 3310 0006 7860     		str	r0, [r7, #4]
 3311 0008 3960     		str	r1, [r7]
 866:../drivers/fsl_lpsci.c ****     assert(handle);
 3312              		.loc 4 866 5
 3313 000a 3B68     		ldr	r3, [r7]
 3314 000c 002B     		cmp	r3, #0
 3315 000e 03D1     		bne	.L196
 3316              		.loc 4 866 5 is_stmt 0 discriminator 1
 3317 0010 B04B     		ldr	r3, .L219
 3318 0012 1800     		movs	r0, r3
 3319 0014 FFF7FEFF 		bl	__assertion_failed
 3320              	.L196:
 867:../drivers/fsl_lpsci.c **** 
 868:../drivers/fsl_lpsci.c ****     uint8_t count;
 869:../drivers/fsl_lpsci.c ****     uint8_t tempCount;
 870:../drivers/fsl_lpsci.c **** 
 871:../drivers/fsl_lpsci.c ****     /* If RX parity error */
 872:../drivers/fsl_lpsci.c ****     if (UART0_S1_PF_MASK & base->S1)
 3321              		.loc 4 872 32 is_stmt 1
 3322 0018 7B68     		ldr	r3, [r7, #4]
 3323 001a 1B79     		ldrb	r3, [r3, #4]
 3324 001c DBB2     		uxtb	r3, r3
 3325              		.loc 4 872 9
 3326 001e 0122     		movs	r2, #1
 3327 0020 1340     		ands	r3, r2
 3328 0022 DBB2     		uxtb	r3, r3
 3329              		.loc 4 872 8
 3330 0024 002B     		cmp	r3, #0
 3331 0026 14D0     		beq	.L197
 873:../drivers/fsl_lpsci.c ****     {
 874:../drivers/fsl_lpsci.c ****         handle->rxState = kLPSCI_RxParityError;
 3332              		.loc 4 874 25
 3333 0028 3B68     		ldr	r3, [r7]
 3334 002a 2D22     		movs	r2, #45
 3335 002c 0521     		movs	r1, #5
 3336 002e 9954     		strb	r1, [r3, r2]
 875:../drivers/fsl_lpsci.c **** 
 876:../drivers/fsl_lpsci.c ****         LPSCI_ClearStatusFlags(base, kLPSCI_ParityErrorFlag);
 3337              		.loc 4 876 9
 3338 0030 7B68     		ldr	r3, [r7, #4]
 3339 0032 0121     		movs	r1, #1
 3340 0034 1800     		movs	r0, r3
 3341 0036 FFF7FEFF 		bl	LPSCI_ClearStatusFlags
 877:../drivers/fsl_lpsci.c ****         /* Trigger callback. */
 878:../drivers/fsl_lpsci.c ****         if (handle->callback)
 3342              		.loc 4 878 19
 3343 003a 3B68     		ldr	r3, [r7]
 3344 003c 5B6A     		ldr	r3, [r3, #36]
 3345              		.loc 4 878 12
 3346 003e 002B     		cmp	r3, #0
 3347 0040 07D0     		beq	.L197
 879:../drivers/fsl_lpsci.c ****         {
 880:../drivers/fsl_lpsci.c ****             handle->callback(base, handle, kStatus_LPSCI_ParityError, handle->userData);
 3348              		.loc 4 880 19
 3349 0042 3B68     		ldr	r3, [r7]
 3350 0044 5C6A     		ldr	r4, [r3, #36]
 3351              		.loc 4 880 13
 3352 0046 3B68     		ldr	r3, [r7]
 3353 0048 9B6A     		ldr	r3, [r3, #40]
 3354 004a A34A     		ldr	r2, .L219+4
 3355 004c 3968     		ldr	r1, [r7]
 3356 004e 7868     		ldr	r0, [r7, #4]
 3357 0050 A047     		blx	r4
 3358              	.LVL11:
 3359              	.L197:
 881:../drivers/fsl_lpsci.c ****         }
 882:../drivers/fsl_lpsci.c ****     }
 883:../drivers/fsl_lpsci.c **** 
 884:../drivers/fsl_lpsci.c ****     /* If RX framing error */
 885:../drivers/fsl_lpsci.c ****     if (UART0_S1_FE_MASK & base->S1)
 3360              		.loc 4 885 32
 3361 0052 7B68     		ldr	r3, [r7, #4]
 3362 0054 1B79     		ldrb	r3, [r3, #4]
 3363 0056 DBB2     		uxtb	r3, r3
 3364              		.loc 4 885 9
 3365 0058 0222     		movs	r2, #2
 3366 005a 1340     		ands	r3, r2
 3367 005c DBB2     		uxtb	r3, r3
 3368              		.loc 4 885 8
 3369 005e 002B     		cmp	r3, #0
 3370 0060 14D0     		beq	.L198
 886:../drivers/fsl_lpsci.c ****     {
 887:../drivers/fsl_lpsci.c ****         handle->rxState = kLPSCI_RxFramingError;
 3371              		.loc 4 887 25
 3372 0062 3B68     		ldr	r3, [r7]
 3373 0064 2D22     		movs	r2, #45
 3374 0066 0421     		movs	r1, #4
 3375 0068 9954     		strb	r1, [r3, r2]
 888:../drivers/fsl_lpsci.c **** 
 889:../drivers/fsl_lpsci.c ****         LPSCI_ClearStatusFlags(base, kLPSCI_FramingErrorFlag);
 3376              		.loc 4 889 9
 3377 006a 7B68     		ldr	r3, [r7, #4]
 3378 006c 0221     		movs	r1, #2
 3379 006e 1800     		movs	r0, r3
 3380 0070 FFF7FEFF 		bl	LPSCI_ClearStatusFlags
 890:../drivers/fsl_lpsci.c ****         /* Trigger callback. */
 891:../drivers/fsl_lpsci.c ****         if (handle->callback)
 3381              		.loc 4 891 19
 3382 0074 3B68     		ldr	r3, [r7]
 3383 0076 5B6A     		ldr	r3, [r3, #36]
 3384              		.loc 4 891 12
 3385 0078 002B     		cmp	r3, #0
 3386 007a 07D0     		beq	.L198
 892:../drivers/fsl_lpsci.c ****         {
 893:../drivers/fsl_lpsci.c ****             handle->callback(base, handle, kStatus_LPSCI_FramingError, handle->userData);
 3387              		.loc 4 893 19
 3388 007c 3B68     		ldr	r3, [r7]
 3389 007e 5C6A     		ldr	r4, [r3, #36]
 3390              		.loc 4 893 13
 3391 0080 3B68     		ldr	r3, [r7]
 3392 0082 9B6A     		ldr	r3, [r3, #40]
 3393 0084 954A     		ldr	r2, .L219+8
 3394 0086 3968     		ldr	r1, [r7]
 3395 0088 7868     		ldr	r0, [r7, #4]
 3396 008a A047     		blx	r4
 3397              	.LVL12:
 3398              	.L198:
 894:../drivers/fsl_lpsci.c ****         }
 895:../drivers/fsl_lpsci.c ****     }
 896:../drivers/fsl_lpsci.c ****     /* If RX overrun. */
 897:../drivers/fsl_lpsci.c ****     if (UART0_S1_OR_MASK & base->S1)
 3399              		.loc 4 897 32
 3400 008c 7B68     		ldr	r3, [r7, #4]
 3401 008e 1B79     		ldrb	r3, [r3, #4]
 3402 0090 DBB2     		uxtb	r3, r3
 3403              		.loc 4 897 9
 3404 0092 0822     		movs	r2, #8
 3405 0094 1340     		ands	r3, r2
 3406 0096 DBB2     		uxtb	r3, r3
 3407              		.loc 4 897 8
 3408 0098 002B     		cmp	r3, #0
 3409 009a 1CD0     		beq	.L199
 898:../drivers/fsl_lpsci.c ****     {
 899:../drivers/fsl_lpsci.c ****         while (UART0_S1_RDRF_MASK & base->S1)
 3410              		.loc 4 899 15
 3411 009c 01E0     		b	.L200
 3412              	.L201:
 900:../drivers/fsl_lpsci.c ****         {
 901:../drivers/fsl_lpsci.c ****             (void)base->D;
 3413              		.loc 4 901 13
 3414 009e 7B68     		ldr	r3, [r7, #4]
 3415 00a0 DB79     		ldrb	r3, [r3, #7]
 3416              	.L200:
 899:../drivers/fsl_lpsci.c ****         {
 3417              		.loc 4 899 41
 3418 00a2 7B68     		ldr	r3, [r7, #4]
 3419 00a4 1B79     		ldrb	r3, [r3, #4]
 3420 00a6 DBB2     		uxtb	r3, r3
 899:../drivers/fsl_lpsci.c ****         {
 3421              		.loc 4 899 16
 3422 00a8 2022     		movs	r2, #32
 3423 00aa 1340     		ands	r3, r2
 3424 00ac DBB2     		uxtb	r3, r3
 899:../drivers/fsl_lpsci.c ****         {
 3425              		.loc 4 899 15
 3426 00ae 002B     		cmp	r3, #0
 3427 00b0 F5D1     		bne	.L201
 902:../drivers/fsl_lpsci.c ****         }
 903:../drivers/fsl_lpsci.c **** 
 904:../drivers/fsl_lpsci.c ****         LPSCI_ClearStatusFlags(base, kLPSCI_RxOverrunFlag);
 3428              		.loc 4 904 9
 3429 00b2 7B68     		ldr	r3, [r7, #4]
 3430 00b4 0821     		movs	r1, #8
 3431 00b6 1800     		movs	r0, r3
 3432 00b8 FFF7FEFF 		bl	LPSCI_ClearStatusFlags
 905:../drivers/fsl_lpsci.c ****         /* Trigger callback. */
 906:../drivers/fsl_lpsci.c ****         if (handle->callback)
 3433              		.loc 4 906 19
 3434 00bc 3B68     		ldr	r3, [r7]
 3435 00be 5B6A     		ldr	r3, [r3, #36]
 3436              		.loc 4 906 12
 3437 00c0 002B     		cmp	r3, #0
 3438 00c2 08D0     		beq	.L199
 907:../drivers/fsl_lpsci.c ****         {
 908:../drivers/fsl_lpsci.c ****             handle->callback(base, handle, kStatus_LPSCI_RxHardwareOverrun, handle->userData);
 3439              		.loc 4 908 19
 3440 00c4 3B68     		ldr	r3, [r7]
 3441 00c6 5C6A     		ldr	r4, [r3, #36]
 3442              		.loc 4 908 13
 3443 00c8 3B68     		ldr	r3, [r7]
 3444 00ca 9B6A     		ldr	r3, [r3, #40]
 3445 00cc 9722     		movs	r2, #151
 3446 00ce D200     		lsls	r2, r2, #3
 3447 00d0 3968     		ldr	r1, [r7]
 3448 00d2 7868     		ldr	r0, [r7, #4]
 3449 00d4 A047     		blx	r4
 3450              	.LVL13:
 3451              	.L199:
 909:../drivers/fsl_lpsci.c ****         }
 910:../drivers/fsl_lpsci.c ****     }
 911:../drivers/fsl_lpsci.c **** 
 912:../drivers/fsl_lpsci.c ****     /* Receive data register full */
 913:../drivers/fsl_lpsci.c ****     if ((UART0_S1_RDRF_MASK & base->S1) && (UART0_C2_RIE_MASK & base->C2))
 3452              		.loc 4 913 35
 3453 00d6 7B68     		ldr	r3, [r7, #4]
 3454 00d8 1B79     		ldrb	r3, [r3, #4]
 3455 00da DBB2     		uxtb	r3, r3
 3456              		.loc 4 913 9
 3457 00dc 2022     		movs	r2, #32
 3458 00de 1340     		ands	r3, r2
 3459 00e0 DBB2     		uxtb	r3, r3
 3460              		.loc 4 913 8
 3461 00e2 002B     		cmp	r3, #0
 3462 00e4 00D1     		bne	.LCB2780
 3463 00e6 BDE0     		b	.L202	@long jump
 3464              	.LCB2780:
 3465              		.loc 4 913 69 discriminator 1
 3466 00e8 7B68     		ldr	r3, [r7, #4]
 3467 00ea DB78     		ldrb	r3, [r3, #3]
 3468 00ec DBB2     		uxtb	r3, r3
 3469              		.loc 4 913 41 discriminator 1
 3470 00ee 2022     		movs	r2, #32
 3471 00f0 1340     		ands	r3, r2
 3472 00f2 DBB2     		uxtb	r3, r3
 3473 00f4 002B     		cmp	r3, #0
 3474 00f6 00D1     		bne	.LCB2788
 3475 00f8 B4E0     		b	.L202	@long jump
 3476              	.LCB2788:
 914:../drivers/fsl_lpsci.c ****     {
 915:../drivers/fsl_lpsci.c **** /* Get the size that can be stored into buffer for this interrupt. */
 916:../drivers/fsl_lpsci.c **** #if defined(FSL_FEATURE_LPSCI_HAS_FIFO) && FSL_FEATURE_LPSCI_HAS_FIFO
 917:../drivers/fsl_lpsci.c ****         count = base->RCFIFO;
 918:../drivers/fsl_lpsci.c **** #else
 919:../drivers/fsl_lpsci.c ****         count = 1;
 3477              		.loc 4 919 15
 3478 00fa 0F23     		movs	r3, #15
 3479 00fc FB18     		adds	r3, r7, r3
 3480 00fe 0122     		movs	r2, #1
 3481 0100 1A70     		strb	r2, [r3]
 920:../drivers/fsl_lpsci.c **** #endif
 921:../drivers/fsl_lpsci.c **** 
 922:../drivers/fsl_lpsci.c ****         /* If handle->rxDataSize is not 0, first save data to handle->rxData. */
 923:../drivers/fsl_lpsci.c ****         while ((count) && (handle->rxDataSize))
 3482              		.loc 4 923 15
 3483 0102 36E0     		b	.L203
 3484              	.L205:
 924:../drivers/fsl_lpsci.c ****         {
 925:../drivers/fsl_lpsci.c **** #if defined(FSL_FEATURE_LPSCI_HAS_FIFO) && FSL_FEATURE_LPSCI_HAS_FIFO
 926:../drivers/fsl_lpsci.c ****             tempCount = MIN(handle->rxDataSize, count);
 927:../drivers/fsl_lpsci.c **** #else
 928:../drivers/fsl_lpsci.c ****             tempCount = 1;
 3485              		.loc 4 928 23
 3486 0104 0E24     		movs	r4, #14
 3487 0106 3B19     		adds	r3, r7, r4
 3488 0108 0122     		movs	r2, #1
 3489 010a 1A70     		strb	r2, [r3]
 929:../drivers/fsl_lpsci.c **** #endif
 930:../drivers/fsl_lpsci.c **** 
 931:../drivers/fsl_lpsci.c ****             /* Using non block API to read the data from the registers. */
 932:../drivers/fsl_lpsci.c ****             LPSCI_ReadNonBlocking(base, handle->rxData, tempCount);
 3490              		.loc 4 932 13
 3491 010c 3B68     		ldr	r3, [r7]
 3492 010e D968     		ldr	r1, [r3, #12]
 3493 0110 3B19     		adds	r3, r7, r4
 3494 0112 1A78     		ldrb	r2, [r3]
 3495 0114 7B68     		ldr	r3, [r7, #4]
 3496 0116 1800     		movs	r0, r3
 3497 0118 FFF7FEFF 		bl	LPSCI_ReadNonBlocking
 933:../drivers/fsl_lpsci.c ****             handle->rxData += tempCount;
 3498              		.loc 4 933 28
 3499 011c 3B68     		ldr	r3, [r7]
 3500 011e DA68     		ldr	r2, [r3, #12]
 3501 0120 2000     		movs	r0, r4
 3502 0122 3B18     		adds	r3, r7, r0
 3503 0124 1B78     		ldrb	r3, [r3]
 3504 0126 D218     		adds	r2, r2, r3
 3505 0128 3B68     		ldr	r3, [r7]
 3506 012a DA60     		str	r2, [r3, #12]
 934:../drivers/fsl_lpsci.c ****             handle->rxDataSize -= tempCount;
 3507              		.loc 4 934 32
 3508 012c 3B68     		ldr	r3, [r7]
 3509 012e 1A69     		ldr	r2, [r3, #16]
 3510 0130 3B18     		adds	r3, r7, r0
 3511 0132 1B78     		ldrb	r3, [r3]
 3512 0134 D21A     		subs	r2, r2, r3
 3513 0136 3B68     		ldr	r3, [r7]
 3514 0138 1A61     		str	r2, [r3, #16]
 935:../drivers/fsl_lpsci.c ****             count -= tempCount;
 3515              		.loc 4 935 19
 3516 013a 0F22     		movs	r2, #15
 3517 013c BB18     		adds	r3, r7, r2
 3518 013e B918     		adds	r1, r7, r2
 3519 0140 3A18     		adds	r2, r7, r0
 3520 0142 0978     		ldrb	r1, [r1]
 3521 0144 1278     		ldrb	r2, [r2]
 3522 0146 8A1A     		subs	r2, r1, r2
 3523 0148 1A70     		strb	r2, [r3]
 936:../drivers/fsl_lpsci.c **** 
 937:../drivers/fsl_lpsci.c ****             /* If all the data required for upper layer is ready, trigger callback. */
 938:../drivers/fsl_lpsci.c ****             if (!handle->rxDataSize)
 3524              		.loc 4 938 24
 3525 014a 3B68     		ldr	r3, [r7]
 3526 014c 1B69     		ldr	r3, [r3, #16]
 3527              		.loc 4 938 16
 3528 014e 002B     		cmp	r3, #0
 3529 0150 0FD1     		bne	.L203
 939:../drivers/fsl_lpsci.c ****             {
 940:../drivers/fsl_lpsci.c ****                 handle->rxState = kLPSCI_RxIdle;
 3530              		.loc 4 940 33
 3531 0152 3B68     		ldr	r3, [r7]
 3532 0154 2D22     		movs	r2, #45
 3533 0156 0221     		movs	r1, #2
 3534 0158 9954     		strb	r1, [r3, r2]
 941:../drivers/fsl_lpsci.c **** 
 942:../drivers/fsl_lpsci.c ****                 if (handle->callback)
 3535              		.loc 4 942 27
 3536 015a 3B68     		ldr	r3, [r7]
 3537 015c 5B6A     		ldr	r3, [r3, #36]
 3538              		.loc 4 942 20
 3539 015e 002B     		cmp	r3, #0
 3540 0160 07D0     		beq	.L203
 943:../drivers/fsl_lpsci.c ****                 {
 944:../drivers/fsl_lpsci.c ****                     handle->callback(base, handle, kStatus_LPSCI_RxIdle, handle->userData);
 3541              		.loc 4 944 27
 3542 0162 3B68     		ldr	r3, [r7]
 3543 0164 5C6A     		ldr	r4, [r3, #36]
 3544              		.loc 4 944 21
 3545 0166 3B68     		ldr	r3, [r7]
 3546 0168 9B6A     		ldr	r3, [r3, #40]
 3547 016a 5D4A     		ldr	r2, .L219+12
 3548 016c 3968     		ldr	r1, [r7]
 3549 016e 7868     		ldr	r0, [r7, #4]
 3550 0170 A047     		blx	r4
 3551              	.LVL14:
 3552              	.L203:
 923:../drivers/fsl_lpsci.c ****         {
 3553              		.loc 4 923 15
 3554 0172 0F23     		movs	r3, #15
 3555 0174 FB18     		adds	r3, r7, r3
 3556 0176 1B78     		ldrb	r3, [r3]
 3557 0178 002B     		cmp	r3, #0
 3558 017a 03D0     		beq	.L204
 923:../drivers/fsl_lpsci.c ****         {
 3559              		.loc 4 923 34 discriminator 1
 3560 017c 3B68     		ldr	r3, [r7]
 3561 017e 1B69     		ldr	r3, [r3, #16]
 923:../drivers/fsl_lpsci.c ****         {
 3562              		.loc 4 923 24 discriminator 1
 3563 0180 002B     		cmp	r3, #0
 3564 0182 BFD1     		bne	.L205
 3565              	.L204:
 945:../drivers/fsl_lpsci.c ****                 }
 946:../drivers/fsl_lpsci.c ****             }
 947:../drivers/fsl_lpsci.c ****         }
 948:../drivers/fsl_lpsci.c **** 
 949:../drivers/fsl_lpsci.c ****         /* If use RX ring buffer, receive data to ring buffer. */
 950:../drivers/fsl_lpsci.c ****         if (handle->rxRingBuffer)
 3566              		.loc 4 950 19
 3567 0184 3B68     		ldr	r3, [r7]
 3568 0186 9B69     		ldr	r3, [r3, #24]
 3569              		.loc 4 950 12
 3570 0188 002B     		cmp	r3, #0
 3571 018a 51D0     		beq	.L206
 951:../drivers/fsl_lpsci.c ****         {
 952:../drivers/fsl_lpsci.c ****             while (count--)
 3572              		.loc 4 952 19
 3573 018c 47E0     		b	.L207
 3574              	.L212:
 953:../drivers/fsl_lpsci.c ****             {
 954:../drivers/fsl_lpsci.c ****                 /* If RX ring buffer is full, trigger callback to notify over run. */
 955:../drivers/fsl_lpsci.c ****                 if (LPSCI_TransferIsRxRingBufferFull(handle))
 3575              		.loc 4 955 21
 3576 018e 3B68     		ldr	r3, [r7]
 3577 0190 1800     		movs	r0, r3
 3578 0192 FFF7FEFF 		bl	LPSCI_TransferIsRxRingBufferFull
 3579 0196 031E     		subs	r3, r0, #0
 3580              		.loc 4 955 20
 3581 0198 0BD0     		beq	.L208
 956:../drivers/fsl_lpsci.c ****                 {
 957:../drivers/fsl_lpsci.c ****                     if (handle->callback)
 3582              		.loc 4 957 31
 3583 019a 3B68     		ldr	r3, [r7]
 3584 019c 5B6A     		ldr	r3, [r3, #36]
 3585              		.loc 4 957 24
 3586 019e 002B     		cmp	r3, #0
 3587 01a0 07D0     		beq	.L208
 958:../drivers/fsl_lpsci.c ****                     {
 959:../drivers/fsl_lpsci.c ****                         handle->callback(base, handle, kStatus_LPSCI_RxRingBufferOverrun, handle->u
 3588              		.loc 4 959 31
 3589 01a2 3B68     		ldr	r3, [r7]
 3590 01a4 5C6A     		ldr	r4, [r3, #36]
 3591              		.loc 4 959 25
 3592 01a6 3B68     		ldr	r3, [r7]
 3593 01a8 9B6A     		ldr	r3, [r3, #40]
 3594 01aa 4E4A     		ldr	r2, .L219+16
 3595 01ac 3968     		ldr	r1, [r7]
 3596 01ae 7868     		ldr	r0, [r7, #4]
 3597 01b0 A047     		blx	r4
 3598              	.LVL15:
 3599              	.L208:
 960:../drivers/fsl_lpsci.c ****                     }
 961:../drivers/fsl_lpsci.c ****                 }
 962:../drivers/fsl_lpsci.c **** 
 963:../drivers/fsl_lpsci.c ****                 /* If ring buffer is still full after callback function, the oldest data is overrid
 964:../drivers/fsl_lpsci.c ****                 if (LPSCI_TransferIsRxRingBufferFull(handle))
 3600              		.loc 4 964 21
 3601 01b2 3B68     		ldr	r3, [r7]
 3602 01b4 1800     		movs	r0, r3
 3603 01b6 FFF7FEFF 		bl	LPSCI_TransferIsRxRingBufferFull
 3604 01ba 031E     		subs	r3, r0, #0
 3605              		.loc 4 964 20
 3606 01bc 12D0     		beq	.L209
 965:../drivers/fsl_lpsci.c ****                 {
 966:../drivers/fsl_lpsci.c ****                     /* Increase handle->rxRingBufferTail to make room for new data. */
 967:../drivers/fsl_lpsci.c ****                     if (handle->rxRingBufferTail + 1U == handle->rxRingBufferSize)
 3607              		.loc 4 967 31
 3608 01be 3B68     		ldr	r3, [r7]
 3609 01c0 5B8C     		ldrh	r3, [r3, #34]
 3610 01c2 9BB2     		uxth	r3, r3
 3611              		.loc 4 967 50
 3612 01c4 5A1C     		adds	r2, r3, #1
 3613              		.loc 4 967 64
 3614 01c6 3B68     		ldr	r3, [r7]
 3615 01c8 DB69     		ldr	r3, [r3, #28]
 3616              		.loc 4 967 24
 3617 01ca 9A42     		cmp	r2, r3
 3618 01cc 03D1     		bne	.L210
 968:../drivers/fsl_lpsci.c ****                     {
 969:../drivers/fsl_lpsci.c ****                         handle->rxRingBufferTail = 0U;
 3619              		.loc 4 969 50
 3620 01ce 3B68     		ldr	r3, [r7]
 3621 01d0 0022     		movs	r2, #0
 3622 01d2 5A84     		strh	r2, [r3, #34]
 3623 01d4 06E0     		b	.L209
 3624              	.L210:
 970:../drivers/fsl_lpsci.c ****                     }
 971:../drivers/fsl_lpsci.c ****                     else
 972:../drivers/fsl_lpsci.c ****                     {
 973:../drivers/fsl_lpsci.c ****                         handle->rxRingBufferTail++;
 3625              		.loc 4 973 31
 3626 01d6 3B68     		ldr	r3, [r7]
 3627 01d8 5B8C     		ldrh	r3, [r3, #34]
 3628 01da 9BB2     		uxth	r3, r3
 3629              		.loc 4 973 49
 3630 01dc 0133     		adds	r3, r3, #1
 3631 01de 9AB2     		uxth	r2, r3
 3632 01e0 3B68     		ldr	r3, [r7]
 3633 01e2 5A84     		strh	r2, [r3, #34]
 3634              	.L209:
 974:../drivers/fsl_lpsci.c ****                     }
 975:../drivers/fsl_lpsci.c ****                 }
 976:../drivers/fsl_lpsci.c **** 
 977:../drivers/fsl_lpsci.c ****                 /* Read data. */
 978:../drivers/fsl_lpsci.c ****                 handle->rxRingBuffer[handle->rxRingBufferHead] = base->D;
 3635              		.loc 4 978 23
 3636 01e4 3B68     		ldr	r3, [r7]
 3637 01e6 9B69     		ldr	r3, [r3, #24]
 3638              		.loc 4 978 44
 3639 01e8 3A68     		ldr	r2, [r7]
 3640 01ea 128C     		ldrh	r2, [r2, #32]
 3641 01ec 92B2     		uxth	r2, r2
 3642              		.loc 4 978 37
 3643 01ee 9B18     		adds	r3, r3, r2
 3644              		.loc 4 978 70
 3645 01f0 7A68     		ldr	r2, [r7, #4]
 3646 01f2 D279     		ldrb	r2, [r2, #7]
 3647 01f4 D2B2     		uxtb	r2, r2
 3648              		.loc 4 978 64
 3649 01f6 1A70     		strb	r2, [r3]
 979:../drivers/fsl_lpsci.c **** 
 980:../drivers/fsl_lpsci.c ****                 /* Increase handle->rxRingBufferHead. */
 981:../drivers/fsl_lpsci.c ****                 if (handle->rxRingBufferHead + 1U == handle->rxRingBufferSize)
 3650              		.loc 4 981 27
 3651 01f8 3B68     		ldr	r3, [r7]
 3652 01fa 1B8C     		ldrh	r3, [r3, #32]
 3653 01fc 9BB2     		uxth	r3, r3
 3654              		.loc 4 981 46
 3655 01fe 5A1C     		adds	r2, r3, #1
 3656              		.loc 4 981 60
 3657 0200 3B68     		ldr	r3, [r7]
 3658 0202 DB69     		ldr	r3, [r3, #28]
 3659              		.loc 4 981 20
 3660 0204 9A42     		cmp	r2, r3
 3661 0206 03D1     		bne	.L211
 982:../drivers/fsl_lpsci.c ****                 {
 983:../drivers/fsl_lpsci.c ****                     handle->rxRingBufferHead = 0U;
 3662              		.loc 4 983 46
 3663 0208 3B68     		ldr	r3, [r7]
 3664 020a 0022     		movs	r2, #0
 3665 020c 1A84     		strh	r2, [r3, #32]
 3666 020e 06E0     		b	.L207
 3667              	.L211:
 984:../drivers/fsl_lpsci.c ****                 }
 985:../drivers/fsl_lpsci.c ****                 else
 986:../drivers/fsl_lpsci.c ****                 {
 987:../drivers/fsl_lpsci.c ****                     handle->rxRingBufferHead++;
 3668              		.loc 4 987 27
 3669 0210 3B68     		ldr	r3, [r7]
 3670 0212 1B8C     		ldrh	r3, [r3, #32]
 3671 0214 9BB2     		uxth	r3, r3
 3672              		.loc 4 987 45
 3673 0216 0133     		adds	r3, r3, #1
 3674 0218 9AB2     		uxth	r2, r3
 3675 021a 3B68     		ldr	r3, [r7]
 3676 021c 1A84     		strh	r2, [r3, #32]
 3677              	.L207:
 952:../drivers/fsl_lpsci.c ****             {
 3678              		.loc 4 952 25
 3679 021e 0F22     		movs	r2, #15
 3680 0220 BB18     		adds	r3, r7, r2
 3681 0222 1B78     		ldrb	r3, [r3]
 3682 0224 BA18     		adds	r2, r7, r2
 3683 0226 591E     		subs	r1, r3, #1
 3684 0228 1170     		strb	r1, [r2]
 952:../drivers/fsl_lpsci.c ****             {
 3685              		.loc 4 952 19
 3686 022a 002B     		cmp	r3, #0
 3687 022c AFD1     		bne	.L212
 3688 022e 19E0     		b	.L202
 3689              	.L206:
 988:../drivers/fsl_lpsci.c ****                 }
 989:../drivers/fsl_lpsci.c ****             }
 990:../drivers/fsl_lpsci.c ****         }
 991:../drivers/fsl_lpsci.c ****         /* If no receive requst pending, stop RX interrupt. */
 992:../drivers/fsl_lpsci.c ****         else if (!handle->rxDataSize)
 3690              		.loc 4 992 25
 3691 0230 3B68     		ldr	r3, [r7]
 3692 0232 1B69     		ldr	r3, [r3, #16]
 3693              		.loc 4 992 17
 3694 0234 002B     		cmp	r3, #0
 3695 0236 15D1     		bne	.L202
 993:../drivers/fsl_lpsci.c ****         {
 994:../drivers/fsl_lpsci.c ****             LPSCI_DisableInterrupts(base, kLPSCI_RxDataRegFullInterruptEnable | kLPSCI_RxOverrunInt
 3696              		.loc 4 994 13
 3697 0238 A223     		movs	r3, #162
 3698 023a 1A03     		lsls	r2, r3, #12
 3699 023c 7B68     		ldr	r3, [r7, #4]
 3700 023e 1100     		movs	r1, r2
 3701 0240 1800     		movs	r0, r3
 3702 0242 FFF7FEFF 		bl	LPSCI_DisableInterrupts
 995:../drivers/fsl_lpsci.c ****                                               kLPSCI_FramingErrorInterruptEnable);
 996:../drivers/fsl_lpsci.c **** 
 997:../drivers/fsl_lpsci.c ****             /* Disable parity error interrupt when parity mode is enable*/
 998:../drivers/fsl_lpsci.c ****             if (UART0_C1_PE_MASK & base->C1)
 3703              		.loc 4 998 40
 3704 0246 7B68     		ldr	r3, [r7, #4]
 3705 0248 9B78     		ldrb	r3, [r3, #2]
 3706 024a DBB2     		uxtb	r3, r3
 3707              		.loc 4 998 17
 3708 024c 0222     		movs	r2, #2
 3709 024e 1340     		ands	r3, r2
 3710 0250 DBB2     		uxtb	r3, r3
 3711              		.loc 4 998 16
 3712 0252 002B     		cmp	r3, #0
 3713 0254 06D0     		beq	.L202
 999:../drivers/fsl_lpsci.c ****             {
1000:../drivers/fsl_lpsci.c ****                 LPSCI_DisableInterrupts(base, kLPSCI_ParityErrorInterruptEnable);
 3714              		.loc 4 1000 17
 3715 0256 8023     		movs	r3, #128
 3716 0258 5A02     		lsls	r2, r3, #9
 3717 025a 7B68     		ldr	r3, [r7, #4]
 3718 025c 1100     		movs	r1, r2
 3719 025e 1800     		movs	r0, r3
 3720 0260 FFF7FEFF 		bl	LPSCI_DisableInterrupts
 3721              	.L202:
1001:../drivers/fsl_lpsci.c ****             }
1002:../drivers/fsl_lpsci.c ****         }
1003:../drivers/fsl_lpsci.c ****         else
1004:../drivers/fsl_lpsci.c ****         {
1005:../drivers/fsl_lpsci.c ****         }
1006:../drivers/fsl_lpsci.c ****     }
1007:../drivers/fsl_lpsci.c ****     /* If framing error or parity error happened, stop the RX interrupt when ues no ring buffer */
1008:../drivers/fsl_lpsci.c ****     if (((handle->rxState == kLPSCI_RxFramingError) || (handle->rxState == kLPSCI_RxParityError)) &
 3722              		.loc 4 1008 17
 3723 0264 3B68     		ldr	r3, [r7]
 3724 0266 2D22     		movs	r2, #45
 3725 0268 9B5C     		ldrb	r3, [r3, r2]
 3726 026a DBB2     		uxtb	r3, r3
 3727              		.loc 4 1008 8
 3728 026c 042B     		cmp	r3, #4
 3729 026e 05D0     		beq	.L213
 3730              		.loc 4 1008 63 discriminator 2
 3731 0270 3B68     		ldr	r3, [r7]
 3732 0272 2D22     		movs	r2, #45
 3733 0274 9B5C     		ldrb	r3, [r3, r2]
 3734 0276 DBB2     		uxtb	r3, r3
 3735              		.loc 4 1008 53 discriminator 2
 3736 0278 052B     		cmp	r3, #5
 3737 027a 19D1     		bne	.L214
 3738              	.L213:
1009:../drivers/fsl_lpsci.c ****         (!handle->rxRingBuffer))
 3739              		.loc 4 1009 17 discriminator 3
 3740 027c 3B68     		ldr	r3, [r7]
 3741 027e 9B69     		ldr	r3, [r3, #24]
1008:../drivers/fsl_lpsci.c ****         (!handle->rxRingBuffer))
 3742              		.loc 4 1008 99 discriminator 3
 3743 0280 002B     		cmp	r3, #0
 3744 0282 15D1     		bne	.L214
1010:../drivers/fsl_lpsci.c ****     {
1011:../drivers/fsl_lpsci.c ****         LPSCI_DisableInterrupts(base, kLPSCI_RxDataRegFullInterruptEnable | kLPSCI_RxOverrunInterru
 3745              		.loc 4 1011 9
 3746 0284 A223     		movs	r3, #162
 3747 0286 1A03     		lsls	r2, r3, #12
 3748 0288 7B68     		ldr	r3, [r7, #4]
 3749 028a 1100     		movs	r1, r2
 3750 028c 1800     		movs	r0, r3
 3751 028e FFF7FEFF 		bl	LPSCI_DisableInterrupts
1012:../drivers/fsl_lpsci.c ****                                           kLPSCI_FramingErrorInterruptEnable);
1013:../drivers/fsl_lpsci.c **** 
1014:../drivers/fsl_lpsci.c ****         /* Disable parity error interrupt when parity mode is enable*/
1015:../drivers/fsl_lpsci.c ****         if (UART0_C1_PE_MASK & base->C1)
 3752              		.loc 4 1015 36
 3753 0292 7B68     		ldr	r3, [r7, #4]
 3754 0294 9B78     		ldrb	r3, [r3, #2]
 3755 0296 DBB2     		uxtb	r3, r3
 3756              		.loc 4 1015 13
 3757 0298 0222     		movs	r2, #2
 3758 029a 1340     		ands	r3, r2
 3759 029c DBB2     		uxtb	r3, r3
 3760              		.loc 4 1015 12
 3761 029e 002B     		cmp	r3, #0
 3762 02a0 06D0     		beq	.L214
1016:../drivers/fsl_lpsci.c ****         {
1017:../drivers/fsl_lpsci.c ****             LPSCI_DisableInterrupts(base, kLPSCI_ParityErrorInterruptEnable);
 3763              		.loc 4 1017 13
 3764 02a2 8023     		movs	r3, #128
 3765 02a4 5A02     		lsls	r2, r3, #9
 3766 02a6 7B68     		ldr	r3, [r7, #4]
 3767 02a8 1100     		movs	r1, r2
 3768 02aa 1800     		movs	r0, r3
 3769 02ac FFF7FEFF 		bl	LPSCI_DisableInterrupts
 3770              	.L214:
1018:../drivers/fsl_lpsci.c ****         }
1019:../drivers/fsl_lpsci.c ****     }
1020:../drivers/fsl_lpsci.c **** 
1021:../drivers/fsl_lpsci.c ****     /* Send data register empty and the interrupt is enabled. */
1022:../drivers/fsl_lpsci.c ****     if ((base->S1 & UART0_S1_TDRE_MASK) && (base->C2 & UART0_C2_TIE_MASK))
 3771              		.loc 4 1022 14
 3772 02b0 7B68     		ldr	r3, [r7, #4]
 3773 02b2 1B79     		ldrb	r3, [r3, #4]
 3774 02b4 DBB2     		uxtb	r3, r3
 3775              		.loc 4 1022 9
 3776 02b6 5BB2     		sxtb	r3, r3
 3777              		.loc 4 1022 8
 3778 02b8 002B     		cmp	r3, #0
 3779 02ba 5DDA     		bge	.L218
 3780              		.loc 4 1022 49 discriminator 1
 3781 02bc 7B68     		ldr	r3, [r7, #4]
 3782 02be DB78     		ldrb	r3, [r3, #3]
 3783 02c0 DBB2     		uxtb	r3, r3
 3784              		.loc 4 1022 41 discriminator 1
 3785 02c2 5BB2     		sxtb	r3, r3
 3786 02c4 002B     		cmp	r3, #0
 3787 02c6 57DA     		bge	.L218
1023:../drivers/fsl_lpsci.c ****     {
1024:../drivers/fsl_lpsci.c **** /* Get the bytes that available at this moment. */
1025:../drivers/fsl_lpsci.c **** #if defined(FSL_FEATURE_LPSCI_HAS_FIFO) && FSL_FEATURE_LPSCI_HAS_FIFO
1026:../drivers/fsl_lpsci.c ****         count = FSL_FEATURE_LPSCI_FIFO_SIZEn(base) - base->TCFIFO;
1027:../drivers/fsl_lpsci.c **** #else
1028:../drivers/fsl_lpsci.c ****         count = 1;
 3788              		.loc 4 1028 15
 3789 02c8 0F23     		movs	r3, #15
 3790 02ca FB18     		adds	r3, r7, r3
 3791 02cc 0122     		movs	r2, #1
 3792 02ce 1A70     		strb	r2, [r3]
1029:../drivers/fsl_lpsci.c **** #endif
1030:../drivers/fsl_lpsci.c **** 
1031:../drivers/fsl_lpsci.c ****         while ((count) && (handle->txDataSize))
 3793              		.loc 4 1031 15
 3794 02d0 49E0     		b	.L216
 3795              	.L220:
 3796 02d2 C046     		.align	2
 3797              	.L219:
 3798 02d4 00000000 		.word	.LC61
 3799 02d8 BB040000 		.word	1211
 3800 02dc BA040000 		.word	1210
 3801 02e0 B3040000 		.word	1203
 3802 02e4 B7040000 		.word	1207
 3803              	.L217:
1032:../drivers/fsl_lpsci.c ****         {
1033:../drivers/fsl_lpsci.c **** #if defined(FSL_FEATURE_LPSCI_HAS_FIFO) && FSL_FEATURE_LPSCI_HAS_FIFO
1034:../drivers/fsl_lpsci.c ****             tempCount = MIN(handle->txDataSize, count);
1035:../drivers/fsl_lpsci.c **** #else
1036:../drivers/fsl_lpsci.c ****             tempCount = 1;
 3804              		.loc 4 1036 23
 3805 02e8 0E24     		movs	r4, #14
 3806 02ea 3B19     		adds	r3, r7, r4
 3807 02ec 0122     		movs	r2, #1
 3808 02ee 1A70     		strb	r2, [r3]
1037:../drivers/fsl_lpsci.c **** #endif
1038:../drivers/fsl_lpsci.c **** 
1039:../drivers/fsl_lpsci.c ****             /* Using non block API to write the data to the registers. */
1040:../drivers/fsl_lpsci.c ****             LPSCI_WriteNonBlocking(base, handle->txData, tempCount);
 3809              		.loc 4 1040 48
 3810 02f0 3B68     		ldr	r3, [r7]
 3811 02f2 1968     		ldr	r1, [r3]
 3812              		.loc 4 1040 13
 3813 02f4 3B19     		adds	r3, r7, r4
 3814 02f6 1A78     		ldrb	r2, [r3]
 3815 02f8 7B68     		ldr	r3, [r7, #4]
 3816 02fa 1800     		movs	r0, r3
 3817 02fc FFF7FEFF 		bl	LPSCI_WriteNonBlocking
1041:../drivers/fsl_lpsci.c ****             handle->txData += tempCount;
 3818              		.loc 4 1041 28
 3819 0300 3B68     		ldr	r3, [r7]
 3820 0302 1A68     		ldr	r2, [r3]
 3821 0304 2000     		movs	r0, r4
 3822 0306 3B18     		adds	r3, r7, r0
 3823 0308 1B78     		ldrb	r3, [r3]
 3824 030a D218     		adds	r2, r2, r3
 3825 030c 3B68     		ldr	r3, [r7]
 3826 030e 1A60     		str	r2, [r3]
1042:../drivers/fsl_lpsci.c ****             handle->txDataSize -= tempCount;
 3827              		.loc 4 1042 32
 3828 0310 3B68     		ldr	r3, [r7]
 3829 0312 5A68     		ldr	r2, [r3, #4]
 3830 0314 3B18     		adds	r3, r7, r0
 3831 0316 1B78     		ldrb	r3, [r3]
 3832 0318 D21A     		subs	r2, r2, r3
 3833 031a 3B68     		ldr	r3, [r7]
 3834 031c 5A60     		str	r2, [r3, #4]
1043:../drivers/fsl_lpsci.c ****             count -= tempCount;
 3835              		.loc 4 1043 19
 3836 031e 0F22     		movs	r2, #15
 3837 0320 BB18     		adds	r3, r7, r2
 3838 0322 B918     		adds	r1, r7, r2
 3839 0324 3A18     		adds	r2, r7, r0
 3840 0326 0978     		ldrb	r1, [r1]
 3841 0328 1278     		ldrb	r2, [r2]
 3842 032a 8A1A     		subs	r2, r1, r2
 3843 032c 1A70     		strb	r2, [r3]
1044:../drivers/fsl_lpsci.c **** 
1045:../drivers/fsl_lpsci.c ****             /* If all the data are written to data register, enable TX complete interrupt. */
1046:../drivers/fsl_lpsci.c ****             if (!handle->txDataSize)
 3844              		.loc 4 1046 24
 3845 032e 3B68     		ldr	r3, [r7]
 3846 0330 5B68     		ldr	r3, [r3, #4]
 3847              		.loc 4 1046 16
 3848 0332 002B     		cmp	r3, #0
 3849 0334 17D1     		bne	.L216
1047:../drivers/fsl_lpsci.c ****             {
1048:../drivers/fsl_lpsci.c ****                 handle->txState = kLPSCI_TxIdle;
 3850              		.loc 4 1048 33
 3851 0336 3B68     		ldr	r3, [r7]
 3852 0338 2C22     		movs	r2, #44
 3853 033a 0021     		movs	r1, #0
 3854 033c 9954     		strb	r1, [r3, r2]
1049:../drivers/fsl_lpsci.c **** 
1050:../drivers/fsl_lpsci.c ****                 /* Disable TX register empty interrupt. */
1051:../drivers/fsl_lpsci.c ****                 base->C2 &= ~UART0_C2_TIE_MASK;
 3855              		.loc 4 1051 26
 3856 033e 7B68     		ldr	r3, [r7, #4]
 3857 0340 DB78     		ldrb	r3, [r3, #3]
 3858 0342 DBB2     		uxtb	r3, r3
 3859 0344 7F22     		movs	r2, #127
 3860 0346 1340     		ands	r3, r2
 3861 0348 DAB2     		uxtb	r2, r3
 3862 034a 7B68     		ldr	r3, [r7, #4]
 3863 034c DA70     		strb	r2, [r3, #3]
1052:../drivers/fsl_lpsci.c **** 
1053:../drivers/fsl_lpsci.c ****                 /* Trigger callback. */
1054:../drivers/fsl_lpsci.c ****                 if (handle->callback)
 3864              		.loc 4 1054 27
 3865 034e 3B68     		ldr	r3, [r7]
 3866 0350 5B6A     		ldr	r3, [r3, #36]
 3867              		.loc 4 1054 20
 3868 0352 002B     		cmp	r3, #0
 3869 0354 07D0     		beq	.L216
1055:../drivers/fsl_lpsci.c ****                 {
1056:../drivers/fsl_lpsci.c ****                     handle->callback(base, handle, kStatus_LPSCI_TxIdle, handle->userData);
 3870              		.loc 4 1056 27
 3871 0356 3B68     		ldr	r3, [r7]
 3872 0358 5C6A     		ldr	r4, [r3, #36]
 3873              		.loc 4 1056 21
 3874 035a 3B68     		ldr	r3, [r7]
 3875 035c 9B6A     		ldr	r3, [r3, #40]
 3876 035e 084A     		ldr	r2, .L221
 3877 0360 3968     		ldr	r1, [r7]
 3878 0362 7868     		ldr	r0, [r7, #4]
 3879 0364 A047     		blx	r4
 3880              	.LVL16:
 3881              	.L216:
1031:../drivers/fsl_lpsci.c ****         {
 3882              		.loc 4 1031 15
 3883 0366 0F23     		movs	r3, #15
 3884 0368 FB18     		adds	r3, r7, r3
 3885 036a 1B78     		ldrb	r3, [r3]
 3886 036c 002B     		cmp	r3, #0
 3887 036e 03D0     		beq	.L218
1031:../drivers/fsl_lpsci.c ****         {
 3888              		.loc 4 1031 34 discriminator 1
 3889 0370 3B68     		ldr	r3, [r7]
 3890 0372 5B68     		ldr	r3, [r3, #4]
1031:../drivers/fsl_lpsci.c ****         {
 3891              		.loc 4 1031 24 discriminator 1
 3892 0374 002B     		cmp	r3, #0
 3893 0376 B7D1     		bne	.L217
 3894              	.L218:
1057:../drivers/fsl_lpsci.c ****                 }
1058:../drivers/fsl_lpsci.c ****             }
1059:../drivers/fsl_lpsci.c ****         }
1060:../drivers/fsl_lpsci.c ****     }
1061:../drivers/fsl_lpsci.c **** }
 3895              		.loc 4 1061 1
 3896 0378 C046     		nop
 3897 037a BD46     		mov	sp, r7
 3898 037c 05B0     		add	sp, sp, #20
 3899              		@ sp needed
 3900 037e 90BD     		pop	{r4, r7, pc}
 3901              	.L222:
 3902              		.align	2
 3903              	.L221:
 3904 0380 B2040000 		.word	1202
 3905              		.cfi_endproc
 3906              	.LFE88:
 3908              		.section	.text.LPSCI_TransferHandleErrorIRQ,"ax",%progbits
 3909              		.align	1
 3910              		.global	LPSCI_TransferHandleErrorIRQ
 3911              		.syntax unified
 3912              		.code	16
 3913              		.thumb_func
 3914              		.fpu softvfp
 3916              	LPSCI_TransferHandleErrorIRQ:
 3917              	.LFB89:
1062:../drivers/fsl_lpsci.c **** 
1063:../drivers/fsl_lpsci.c **** void LPSCI_TransferHandleErrorIRQ(UART0_Type *base, lpsci_handle_t *handle)
1064:../drivers/fsl_lpsci.c **** {
 3918              		.loc 4 1064 1
 3919              		.cfi_startproc
 3920              		@ args = 0, pretend = 0, frame = 8
 3921              		@ frame_needed = 1, uses_anonymous_args = 0
 3922 0000 80B5     		push	{r7, lr}
 3923              		.cfi_def_cfa_offset 8
 3924              		.cfi_offset 7, -8
 3925              		.cfi_offset 14, -4
 3926 0002 82B0     		sub	sp, sp, #8
 3927              		.cfi_def_cfa_offset 16
 3928 0004 00AF     		add	r7, sp, #0
 3929              		.cfi_def_cfa_register 7
 3930 0006 7860     		str	r0, [r7, #4]
 3931 0008 3960     		str	r1, [r7]
1065:../drivers/fsl_lpsci.c ****     /* To be implemented by User. */
1066:../drivers/fsl_lpsci.c **** }
 3932              		.loc 4 1066 1
 3933 000a C046     		nop
 3934 000c BD46     		mov	sp, r7
 3935 000e 02B0     		add	sp, sp, #8
 3936              		@ sp needed
 3937 0010 80BD     		pop	{r7, pc}
 3938              		.cfi_endproc
 3939              	.LFE89:
 3941              		.section	.text.UART0_DriverIRQHandler,"ax",%progbits
 3942              		.align	1
 3943              		.global	UART0_DriverIRQHandler
 3944              		.syntax unified
 3945              		.code	16
 3946              		.thumb_func
 3947              		.fpu softvfp
 3949              	UART0_DriverIRQHandler:
 3950              	.LFB90:
1067:../drivers/fsl_lpsci.c **** 
1068:../drivers/fsl_lpsci.c **** #if defined(UART0)
1069:../drivers/fsl_lpsci.c **** void UART0_DriverIRQHandler(void)
1070:../drivers/fsl_lpsci.c **** {
 3951              		.loc 4 1070 1
 3952              		.cfi_startproc
 3953              		@ args = 0, pretend = 0, frame = 0
 3954              		@ frame_needed = 1, uses_anonymous_args = 0
 3955 0000 80B5     		push	{r7, lr}
 3956              		.cfi_def_cfa_offset 8
 3957              		.cfi_offset 7, -8
 3958              		.cfi_offset 14, -4
 3959 0002 00AF     		add	r7, sp, #0
 3960              		.cfi_def_cfa_register 7
1071:../drivers/fsl_lpsci.c ****     s_lpsciIsr(UART0, s_lpsciHandle[0]);
 3961              		.loc 4 1071 5
 3962 0004 044B     		ldr	r3, .L225
 3963 0006 1A68     		ldr	r2, [r3]
 3964 0008 044B     		ldr	r3, .L225+4
 3965 000a 1B68     		ldr	r3, [r3]
 3966 000c 0448     		ldr	r0, .L225+8
 3967 000e 1900     		movs	r1, r3
 3968 0010 9047     		blx	r2
 3969              	.LVL17:
1072:../drivers/fsl_lpsci.c **** }
 3970              		.loc 4 1072 1
 3971 0012 C046     		nop
 3972 0014 BD46     		mov	sp, r7
 3973              		@ sp needed
 3974 0016 80BD     		pop	{r7, pc}
 3975              	.L226:
 3976              		.align	2
 3977              	.L225:
 3978 0018 00000000 		.word	s_lpsciIsr
 3979 001c 00000000 		.word	s_lpsciHandle
 3980 0020 00A00640 		.word	1074176000
 3981              		.cfi_endproc
 3982              	.LFE90:
 3984              		.text
 3985              	.Letext0:
 3986              		.file 5 "/usr/local/mcuxpressoide-11.2.0_4120/ide/plugins/com.nxp.mcuxpresso.tools.linux_11.2.0.20
 3987              		.file 6 "/usr/local/mcuxpressoide-11.2.0_4120/ide/plugins/com.nxp.mcuxpresso.tools.linux_11.2.0.20
 3988              		.file 7 "/home/arpit/studies/pes/Blinkenlights/CMSIS/MKL25Z4.h"
 3989              		.file 8 "/home/arpit/studies/pes/Blinkenlights/CMSIS/system_MKL25Z4.h"
 3990              		.file 9 "../drivers/fsl_lpsci.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 fsl_lpsci.c
     /tmp/ccSijER5.s:16     .text.NVIC_EnableIRQ:0000000000000000 $t
     /tmp/ccSijER5.s:23     .text.NVIC_EnableIRQ:0000000000000000 NVIC_EnableIRQ
     /tmp/ccSijER5.s:64     .text.NVIC_EnableIRQ:0000000000000028 $d
     /tmp/ccSijER5.s:69     .text.CLOCK_EnableClock:0000000000000000 $t
     /tmp/ccSijER5.s:75     .text.CLOCK_EnableClock:0000000000000000 CLOCK_EnableClock
     /tmp/ccSijER5.s:122    .text.CLOCK_EnableClock:0000000000000030 $d
     /tmp/ccSijER5.s:127    .text.CLOCK_DisableClock:0000000000000000 $t
     /tmp/ccSijER5.s:133    .text.CLOCK_DisableClock:0000000000000000 CLOCK_DisableClock
     /tmp/ccSijER5.s:182    .text.CLOCK_DisableClock:0000000000000034 $d
     /tmp/ccSijER5.s:187    .text.EnableIRQ:0000000000000000 $t
     /tmp/ccSijER5.s:193    .text.EnableIRQ:0000000000000000 EnableIRQ
     /tmp/ccSijER5.s:237    .bss.s_lpsciHandle:0000000000000000 $d
     /tmp/ccSijER5.s:240    .bss.s_lpsciHandle:0000000000000000 s_lpsciHandle
     /tmp/ccSijER5.s:243    .rodata.s_lpsciBases:0000000000000000 $d
     /tmp/ccSijER5.s:246    .rodata.s_lpsciBases:0000000000000000 s_lpsciBases
     /tmp/ccSijER5.s:249    .rodata.s_lpsciIRQ:0000000000000000 $d
     /tmp/ccSijER5.s:252    .rodata.s_lpsciIRQ:0000000000000000 s_lpsciIRQ
     /tmp/ccSijER5.s:255    .rodata.s_lpsciClock:0000000000000000 $d
     /tmp/ccSijER5.s:258    .rodata.s_lpsciClock:0000000000000000 s_lpsciClock
     /tmp/ccSijER5.s:261    .bss.s_lpsciIsr:0000000000000000 $d
     /tmp/ccSijER5.s:264    .bss.s_lpsciIsr:0000000000000000 s_lpsciIsr
     /tmp/ccSijER5.s:267    .rodata.LPSCI_GetInstance.str1.4:0000000000000000 $d
     /tmp/ccSijER5.s:272    .text.LPSCI_GetInstance:0000000000000000 $t
     /tmp/ccSijER5.s:279    .text.LPSCI_GetInstance:0000000000000000 LPSCI_GetInstance
     /tmp/ccSijER5.s:341    .text.LPSCI_GetInstance:0000000000000040 $d
     /tmp/ccSijER5.s:347    .rodata.LPSCI_TransferGetRxRingBufferLength.str1.4:0000000000000000 $d
     /tmp/ccSijER5.s:351    .text.LPSCI_TransferGetRxRingBufferLength:0000000000000000 $t
     /tmp/ccSijER5.s:357    .text.LPSCI_TransferGetRxRingBufferLength:0000000000000000 LPSCI_TransferGetRxRingBufferLength
     /tmp/ccSijER5.s:436    .text.LPSCI_TransferGetRxRingBufferLength:000000000000005c $d
     /tmp/ccSijER5.s:441    .rodata.LPSCI_TransferIsRxRingBufferFull.str1.4:0000000000000000 $d
     /tmp/ccSijER5.s:445    .text.LPSCI_TransferIsRxRingBufferFull:0000000000000000 $t
     /tmp/ccSijER5.s:451    .text.LPSCI_TransferIsRxRingBufferFull:0000000000000000 LPSCI_TransferIsRxRingBufferFull
     /tmp/ccSijER5.s:514    .text.LPSCI_TransferIsRxRingBufferFull:000000000000004c $d
     /tmp/ccSijER5.s:519    .rodata.LPSCI_ReadNonBlocking.str1.4:0000000000000000 $d
     /tmp/ccSijER5.s:523    .text.LPSCI_ReadNonBlocking:0000000000000000 $t
     /tmp/ccSijER5.s:529    .text.LPSCI_ReadNonBlocking:0000000000000000 LPSCI_ReadNonBlocking
     /tmp/ccSijER5.s:591    .text.LPSCI_ReadNonBlocking:0000000000000048 $d
     /tmp/ccSijER5.s:596    .rodata.LPSCI_WriteNonBlocking.str1.4:0000000000000000 $d
     /tmp/ccSijER5.s:600    .text.LPSCI_WriteNonBlocking:0000000000000000 $t
     /tmp/ccSijER5.s:606    .text.LPSCI_WriteNonBlocking:0000000000000000 LPSCI_WriteNonBlocking
     /tmp/ccSijER5.s:666    .text.LPSCI_WriteNonBlocking:0000000000000044 $d
     /tmp/ccSijER5.s:671    .rodata.LPSCI_Init.str1.4:0000000000000000 $d
     /tmp/ccSijER5.s:679    .text.LPSCI_Init:0000000000000000 $t
     /tmp/ccSijER5.s:686    .text.LPSCI_Init:0000000000000000 LPSCI_Init
     /tmp/ccSijER5.s:1085   .text.LPSCI_Init:0000000000000248 $d
     /tmp/ccSijER5.s:1093   .text.LPSCI_Deinit:0000000000000000 $t
     /tmp/ccSijER5.s:1100   .text.LPSCI_Deinit:0000000000000000 LPSCI_Deinit
     /tmp/ccSijER5.s:1145   .text.LPSCI_Deinit:0000000000000030 $d
     /tmp/ccSijER5.s:1150   .rodata.LPSCI_GetDefaultConfig.str1.4:0000000000000000 $d
     /tmp/ccSijER5.s:1154   .text.LPSCI_GetDefaultConfig:0000000000000000 $t
     /tmp/ccSijER5.s:1161   .text.LPSCI_GetDefaultConfig:0000000000000000 LPSCI_GetDefaultConfig
     /tmp/ccSijER5.s:1215   .text.LPSCI_GetDefaultConfig:0000000000000040 $d
     /tmp/ccSijER5.s:1220   .rodata.LPSCI_SetBaudRate.str1.4:0000000000000000 $d
     /tmp/ccSijER5.s:1224   .text.LPSCI_SetBaudRate:0000000000000000 $t
     /tmp/ccSijER5.s:1231   .text.LPSCI_SetBaudRate:0000000000000000 LPSCI_SetBaudRate
     /tmp/ccSijER5.s:1522   .text.LPSCI_SetBaudRate:00000000000001a0 $d
     /tmp/ccSijER5.s:1528   .text.LPSCI_EnableInterrupts:0000000000000000 $t
     /tmp/ccSijER5.s:1535   .text.LPSCI_EnableInterrupts:0000000000000000 LPSCI_EnableInterrupts
     /tmp/ccSijER5.s:1601   .text.LPSCI_EnableInterrupts:0000000000000054 $d
     /tmp/ccSijER5.s:1606   .text.LPSCI_DisableInterrupts:0000000000000000 $t
     /tmp/ccSijER5.s:1613   .text.LPSCI_DisableInterrupts:0000000000000000 LPSCI_DisableInterrupts
     /tmp/ccSijER5.s:1685   .text.LPSCI_DisableInterrupts:0000000000000060 $d
     /tmp/ccSijER5.s:1690   .text.LPSCI_GetEnabledInterrupts:0000000000000000 $t
     /tmp/ccSijER5.s:1697   .text.LPSCI_GetEnabledInterrupts:0000000000000000 LPSCI_GetEnabledInterrupts
     /tmp/ccSijER5.s:1747   .text.LPSCI_GetEnabledInterrupts:0000000000000034 $d
     /tmp/ccSijER5.s:1752   .text.LPSCI_GetStatusFlags:0000000000000000 $t
     /tmp/ccSijER5.s:1759   .text.LPSCI_GetStatusFlags:0000000000000000 LPSCI_GetStatusFlags
     /tmp/ccSijER5.s:1800   .text.LPSCI_ClearStatusFlags:0000000000000000 $t
     /tmp/ccSijER5.s:1807   .text.LPSCI_ClearStatusFlags:0000000000000000 LPSCI_ClearStatusFlags
     /tmp/ccSijER5.s:1915   .text.LPSCI_ClearStatusFlags:0000000000000088 $d
     /tmp/ccSijER5.s:1922   .rodata.LPSCI_WriteBlocking.str1.4:0000000000000000 $d
     /tmp/ccSijER5.s:1926   .text.LPSCI_WriteBlocking:0000000000000000 $t
     /tmp/ccSijER5.s:1933   .text.LPSCI_WriteBlocking:0000000000000000 LPSCI_WriteBlocking
     /tmp/ccSijER5.s:1998   .text.LPSCI_WriteBlocking:0000000000000048 $d
     /tmp/ccSijER5.s:2003   .rodata.LPSCI_ReadBlocking.str1.4:0000000000000000 $d
     /tmp/ccSijER5.s:2007   .text.LPSCI_ReadBlocking:0000000000000000 $t
     /tmp/ccSijER5.s:2014   .text.LPSCI_ReadBlocking:0000000000000000 LPSCI_ReadBlocking
     /tmp/ccSijER5.s:2147   .text.LPSCI_ReadBlocking:00000000000000b0 $d
     /tmp/ccSijER5.s:2155   .rodata.LPSCI_TransferCreateHandle.str1.4:0000000000000000 $d
     /tmp/ccSijER5.s:2159   .text.LPSCI_TransferCreateHandle:0000000000000000 $t
     /tmp/ccSijER5.s:2166   .text.LPSCI_TransferCreateHandle:0000000000000000 LPSCI_TransferCreateHandle
     /tmp/ccSijER5.s:2246   .text.LPSCI_TransferCreateHandle:0000000000000070 $d
     /tmp/ccSijER5.s:3295   .text.LPSCI_TransferHandleIRQ:0000000000000000 LPSCI_TransferHandleIRQ
     /tmp/ccSijER5.s:2254   .rodata.LPSCI_TransferStartRingBuffer.str1.4:0000000000000000 $d
     /tmp/ccSijER5.s:2261   .text.LPSCI_TransferStartRingBuffer:0000000000000000 $t
     /tmp/ccSijER5.s:2268   .text.LPSCI_TransferStartRingBuffer:0000000000000000 LPSCI_TransferStartRingBuffer
     /tmp/ccSijER5.s:2355   .text.LPSCI_TransferStartRingBuffer:0000000000000078 $d
     /tmp/ccSijER5.s:2361   .rodata.LPSCI_TransferStopRingBuffer.str1.4:0000000000000000 $d
     /tmp/ccSijER5.s:2365   .text.LPSCI_TransferStopRingBuffer:0000000000000000 $t
     /tmp/ccSijER5.s:2372   .text.LPSCI_TransferStopRingBuffer:0000000000000000 LPSCI_TransferStopRingBuffer
     /tmp/ccSijER5.s:2456   .text.LPSCI_TransferStopRingBuffer:0000000000000070 $d
     /tmp/ccSijER5.s:2461   .rodata.LPSCI_TransferSendNonBlocking.str1.4:0000000000000000 $d
     /tmp/ccSijER5.s:2474   .text.LPSCI_TransferSendNonBlocking:0000000000000000 $t
     /tmp/ccSijER5.s:2481   .text.LPSCI_TransferSendNonBlocking:0000000000000000 LPSCI_TransferSendNonBlocking
     /tmp/ccSijER5.s:2595   .text.LPSCI_TransferSendNonBlocking:0000000000000098 $d
     /tmp/ccSijER5.s:2603   .rodata.LPSCI_TransferAbortSend.str1.4:0000000000000000 $d
     /tmp/ccSijER5.s:2607   .text.LPSCI_TransferAbortSend:0000000000000000 $t
     /tmp/ccSijER5.s:2614   .text.LPSCI_TransferAbortSend:0000000000000000 LPSCI_TransferAbortSend
     /tmp/ccSijER5.s:2664   .text.LPSCI_TransferAbortSend:000000000000003c $d
     /tmp/ccSijER5.s:2669   .rodata.LPSCI_TransferGetSendCount.str1.4:0000000000000000 $d
     /tmp/ccSijER5.s:2676   .text.LPSCI_TransferGetSendCount:0000000000000000 $t
     /tmp/ccSijER5.s:2683   .text.LPSCI_TransferGetSendCount:0000000000000000 LPSCI_TransferGetSendCount
     /tmp/ccSijER5.s:2753   .text.LPSCI_TransferGetSendCount:0000000000000050 $d
     /tmp/ccSijER5.s:2759   .rodata.LPSCI_TransferReceiveNonBlocking.str1.4:0000000000000000 $d
     /tmp/ccSijER5.s:2772   .text.LPSCI_TransferReceiveNonBlocking:0000000000000000 $t
     /tmp/ccSijER5.s:2779   .text.LPSCI_TransferReceiveNonBlocking:0000000000000000 LPSCI_TransferReceiveNonBlocking
     /tmp/ccSijER5.s:3093   .text.LPSCI_TransferReceiveNonBlocking:00000000000001b8 $d
     /tmp/ccSijER5.s:3103   .rodata.LPSCI_TransferAbortReceive.str1.4:0000000000000000 $d
     /tmp/ccSijER5.s:3107   .text.LPSCI_TransferAbortReceive:0000000000000000 $t
     /tmp/ccSijER5.s:3114   .text.LPSCI_TransferAbortReceive:0000000000000000 LPSCI_TransferAbortReceive
     /tmp/ccSijER5.s:3189   .text.LPSCI_TransferAbortReceive:0000000000000064 $d
     /tmp/ccSijER5.s:3194   .rodata.LPSCI_TransferGetReceiveCount.str1.4:0000000000000000 $d
     /tmp/ccSijER5.s:3201   .text.LPSCI_TransferGetReceiveCount:0000000000000000 $t
     /tmp/ccSijER5.s:3208   .text.LPSCI_TransferGetReceiveCount:0000000000000000 LPSCI_TransferGetReceiveCount
     /tmp/ccSijER5.s:3278   .text.LPSCI_TransferGetReceiveCount:0000000000000050 $d
     /tmp/ccSijER5.s:3284   .rodata.LPSCI_TransferHandleIRQ.str1.4:0000000000000000 $d
     /tmp/ccSijER5.s:3288   .text.LPSCI_TransferHandleIRQ:0000000000000000 $t
     /tmp/ccSijER5.s:3798   .text.LPSCI_TransferHandleIRQ:00000000000002d4 $d
     /tmp/ccSijER5.s:3805   .text.LPSCI_TransferHandleIRQ:00000000000002e8 $t
     /tmp/ccSijER5.s:3904   .text.LPSCI_TransferHandleIRQ:0000000000000380 $d
     /tmp/ccSijER5.s:3909   .text.LPSCI_TransferHandleErrorIRQ:0000000000000000 $t
     /tmp/ccSijER5.s:3916   .text.LPSCI_TransferHandleErrorIRQ:0000000000000000 LPSCI_TransferHandleErrorIRQ
     /tmp/ccSijER5.s:3942   .text.UART0_DriverIRQHandler:0000000000000000 $t
     /tmp/ccSijER5.s:3949   .text.UART0_DriverIRQHandler:0000000000000000 UART0_DriverIRQHandler
     /tmp/ccSijER5.s:3978   .text.UART0_DriverIRQHandler:0000000000000018 $d
                           .group:0000000000000000 wm4.0.b17fa403cb9718989e7a4b461e73e1c9
                           .group:0000000000000000 wm4.redlib_version.h.16.f905717e4b3a91dcbdbb631865150df4
                           .group:0000000000000000 wm4.assert.h.25.5fa7b1099c5f353f7f0154f84a745cec
                           .group:0000000000000000 wm4.stdbool.h.15.fddf1cb2402fd739d8e2516677869231
                           .group:0000000000000000 wm4.libconfigarm.h.19.34723c94cbd19598192aa6b1e87fca41
                           .group:0000000000000000 wm4.stdint.h.31.58198de4ea930fb897655479091e17c7
                           .group:0000000000000000 wm4.fsl_device_registers.h.32.0bd0fc1949c4d5ee8778d13f693b6d67
                           .group:0000000000000000 wm4.MKL25Z4.h.103.6fa60f7365436a291410ac7ae38d8851
                           .group:0000000000000000 wm4.core_cm0plus.h.42.7e68c73109133db28e6113a0ee252d6f
                           .group:0000000000000000 wm4.cmsis_gcc.h.36.5bb14fd68ce7855540fcfe2d9305ae16
                           .group:0000000000000000 wm4.core_cm0plus.h.175.8e2cbb335a2ae70828db295817e11b6e
                           .group:0000000000000000 wm4.system_MKL25Z4.h.107.b43986f939b1bf0ee0f9aa04879788f4
                           .group:0000000000000000 wm4.MKL25Z4.h.379.376a3f36380a1b2f1e4cdc95287bb342
                           .group:0000000000000000 wm4.MKL25Z4_features.h.84.30fd6c6f11c9d2ffea2189829de10275
                           .group:0000000000000000 wm4.fsl_common.h.55.f0a989f874fed9062f996a5c92215a0e
                           .group:0000000000000000 wm4.fsl_clock.h.61.86ace3515ab77fa85db71e2d42e7d189
                           .group:0000000000000000 wm4.fsl_common.h.162.37daaf5dee6e1f72e10ac988afa1643d

UNDEFINED SYMBOLS
__assertion_failed
__aeabi_uidiv
memset
