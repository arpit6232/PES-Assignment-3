   1              		.cpu cortex-m0plus
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 6
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"fsl_clock.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.CLOCK_EnableClock,"ax",%progbits
  16              		.align	1
  17              		.arch armv6s-m
  18              		.syntax unified
  19              		.code	16
  20              		.thumb_func
  21              		.fpu softvfp
  23              	CLOCK_EnableClock:
  24              	.LFB38:
  25              		.file 1 "../drivers/fsl_clock.h"
   1:../drivers/fsl_clock.h **** /*
   2:../drivers/fsl_clock.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   3:../drivers/fsl_clock.h ****  * Copyright (c) 2016 - 2017 , NXP
   4:../drivers/fsl_clock.h ****  * All rights reserved.
   5:../drivers/fsl_clock.h ****  *
   6:../drivers/fsl_clock.h ****  * Redistribution and use in source and binary forms, with or without modification,
   7:../drivers/fsl_clock.h ****  * are permitted provided that the following conditions are met:
   8:../drivers/fsl_clock.h ****  *
   9:../drivers/fsl_clock.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  10:../drivers/fsl_clock.h ****  *   of conditions and the following disclaimer.
  11:../drivers/fsl_clock.h ****  *
  12:../drivers/fsl_clock.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  13:../drivers/fsl_clock.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  14:../drivers/fsl_clock.h ****  *   other materials provided with the distribution.
  15:../drivers/fsl_clock.h ****  *
  16:../drivers/fsl_clock.h ****  * o Neither the name of copyright holder nor the names of its
  17:../drivers/fsl_clock.h ****  *   contributors may be used to endorse or promote products derived from this
  18:../drivers/fsl_clock.h ****  *   software without specific prior written permission.
  19:../drivers/fsl_clock.h ****  *
  20:../drivers/fsl_clock.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  21:../drivers/fsl_clock.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  22:../drivers/fsl_clock.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  23:../drivers/fsl_clock.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  24:../drivers/fsl_clock.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  25:../drivers/fsl_clock.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  26:../drivers/fsl_clock.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  27:../drivers/fsl_clock.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  28:../drivers/fsl_clock.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  29:../drivers/fsl_clock.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  30:../drivers/fsl_clock.h ****  */
  31:../drivers/fsl_clock.h **** 
  32:../drivers/fsl_clock.h **** #ifndef _FSL_CLOCK_H_
  33:../drivers/fsl_clock.h **** #define _FSL_CLOCK_H_
  34:../drivers/fsl_clock.h **** 
  35:../drivers/fsl_clock.h **** #include "fsl_common.h"
  36:../drivers/fsl_clock.h **** 
  37:../drivers/fsl_clock.h **** /*! @addtogroup clock */
  38:../drivers/fsl_clock.h **** /*! @{ */
  39:../drivers/fsl_clock.h **** 
  40:../drivers/fsl_clock.h **** /*! @file */
  41:../drivers/fsl_clock.h **** 
  42:../drivers/fsl_clock.h **** /*******************************************************************************
  43:../drivers/fsl_clock.h ****  * Configurations
  44:../drivers/fsl_clock.h ****  ******************************************************************************/
  45:../drivers/fsl_clock.h **** 
  46:../drivers/fsl_clock.h **** /*! @brief Configures whether to check a parameter in a function.
  47:../drivers/fsl_clock.h ****  *
  48:../drivers/fsl_clock.h ****  * Some MCG settings must be changed with conditions, for example:
  49:../drivers/fsl_clock.h ****  *  1. MCGIRCLK settings, such as the source, divider, and the trim value should not change when
  50:../drivers/fsl_clock.h ****  *     MCGIRCLK is used as a system clock source.
  51:../drivers/fsl_clock.h ****  *  2. MCG_C7[OSCSEL] should not be changed  when the external reference clock is used
  52:../drivers/fsl_clock.h ****  *     as a system clock source. For example, in FBE/BLPE/PBE modes.
  53:../drivers/fsl_clock.h ****  *  3. The users should only switch between the supported clock modes.
  54:../drivers/fsl_clock.h ****  *
  55:../drivers/fsl_clock.h ****  * MCG functions check the parameter and MCG status before setting, if not allowed
  56:../drivers/fsl_clock.h ****  * to change, the functions return error. The parameter checking increases code size,
  57:../drivers/fsl_clock.h ****  * if code size is a critical requirement, change #MCG_CONFIG_CHECK_PARAM to 0 to
  58:../drivers/fsl_clock.h ****  * disable parameter checking.
  59:../drivers/fsl_clock.h ****  */
  60:../drivers/fsl_clock.h **** #ifndef MCG_CONFIG_CHECK_PARAM
  61:../drivers/fsl_clock.h **** #define MCG_CONFIG_CHECK_PARAM 0U
  62:../drivers/fsl_clock.h **** #endif
  63:../drivers/fsl_clock.h **** 
  64:../drivers/fsl_clock.h **** /*! @brief Configure whether driver controls clock
  65:../drivers/fsl_clock.h ****  *
  66:../drivers/fsl_clock.h ****  * When set to 0, peripheral drivers will enable clock in initialize function
  67:../drivers/fsl_clock.h ****  * and disable clock in de-initialize function. When set to 1, peripheral
  68:../drivers/fsl_clock.h ****  * driver will not control the clock, application could contol the clock out of
  69:../drivers/fsl_clock.h ****  * the driver.
  70:../drivers/fsl_clock.h ****  *
  71:../drivers/fsl_clock.h ****  * @note All drivers share this feature switcher. If it is set to 1, application
  72:../drivers/fsl_clock.h ****  * should handle clock enable and disable for all drivers.
  73:../drivers/fsl_clock.h ****  */
  74:../drivers/fsl_clock.h **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))
  75:../drivers/fsl_clock.h **** #define FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL 0
  76:../drivers/fsl_clock.h **** #endif
  77:../drivers/fsl_clock.h **** 
  78:../drivers/fsl_clock.h **** /*******************************************************************************
  79:../drivers/fsl_clock.h ****  * Definitions
  80:../drivers/fsl_clock.h ****  ******************************************************************************/
  81:../drivers/fsl_clock.h **** 
  82:../drivers/fsl_clock.h **** /*! @name Driver version */
  83:../drivers/fsl_clock.h **** /*@{*/
  84:../drivers/fsl_clock.h **** /*! @brief CLOCK driver version 2.2.1. */
  85:../drivers/fsl_clock.h **** #define FSL_CLOCK_DRIVER_VERSION (MAKE_VERSION(2, 2, 1))
  86:../drivers/fsl_clock.h **** /*@}*/
  87:../drivers/fsl_clock.h **** 
  88:../drivers/fsl_clock.h **** /*! @brief External XTAL0 (OSC0) clock frequency.
  89:../drivers/fsl_clock.h ****  *
  90:../drivers/fsl_clock.h ****  * The XTAL0/EXTAL0 (OSC0) clock frequency in Hz. When the clock is set up, use the
  91:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal0Freq to set the value in the clock driver. For example,
  92:../drivers/fsl_clock.h ****  * if XTAL0 is 8 MHz:
  93:../drivers/fsl_clock.h ****  * @code
  94:../drivers/fsl_clock.h ****  * CLOCK_InitOsc0(...); // Set up the OSC0
  95:../drivers/fsl_clock.h ****  * CLOCK_SetXtal0Freq(80000000); // Set the XTAL0 value to the clock driver.
  96:../drivers/fsl_clock.h ****  * @endcode
  97:../drivers/fsl_clock.h ****  *
  98:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where only one core needs to set up the
  99:../drivers/fsl_clock.h ****  * OSC0 using the CLOCK_InitOsc0. All other cores need to call the CLOCK_SetXtal0Freq
 100:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
 101:../drivers/fsl_clock.h ****  */
 102:../drivers/fsl_clock.h **** extern uint32_t g_xtal0Freq;
 103:../drivers/fsl_clock.h **** 
 104:../drivers/fsl_clock.h **** /*! @brief External XTAL32/EXTAL32/RTC_CLKIN clock frequency.
 105:../drivers/fsl_clock.h ****  *
 106:../drivers/fsl_clock.h ****  * The XTAL32/EXTAL32/RTC_CLKIN clock frequency in Hz. When the clock is set up, use the
 107:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal32Freq to set the value in the clock driver.
 108:../drivers/fsl_clock.h ****  *
 109:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where only one core needs to set up
 110:../drivers/fsl_clock.h ****  * the clock. All other cores need to call the CLOCK_SetXtal32Freq
 111:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
 112:../drivers/fsl_clock.h ****  */
 113:../drivers/fsl_clock.h **** extern uint32_t g_xtal32Freq;
 114:../drivers/fsl_clock.h **** 
 115:../drivers/fsl_clock.h **** #if (defined(OSC) && !(defined(OSC0)))
 116:../drivers/fsl_clock.h **** #define OSC0 OSC
 117:../drivers/fsl_clock.h **** #endif
 118:../drivers/fsl_clock.h **** 
 119:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMAMUX. */
 120:../drivers/fsl_clock.h **** #define DMAMUX_CLOCKS  \
 121:../drivers/fsl_clock.h ****     {                  \
 122:../drivers/fsl_clock.h ****         kCLOCK_Dmamux0 \
 123:../drivers/fsl_clock.h ****     }
 124:../drivers/fsl_clock.h **** 
 125:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RTC. */
 126:../drivers/fsl_clock.h **** #define RTC_CLOCKS  \
 127:../drivers/fsl_clock.h ****     {               \
 128:../drivers/fsl_clock.h ****         kCLOCK_Rtc0 \
 129:../drivers/fsl_clock.h ****     }
 130:../drivers/fsl_clock.h **** 
 131:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SPI. */
 132:../drivers/fsl_clock.h **** #define SPI_CLOCKS               \
 133:../drivers/fsl_clock.h ****     {                            \
 134:../drivers/fsl_clock.h ****         kCLOCK_Spi0, kCLOCK_Spi1 \
 135:../drivers/fsl_clock.h ****     }
 136:../drivers/fsl_clock.h **** 
 137:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PIT. */
 138:../drivers/fsl_clock.h **** #define PIT_CLOCKS  \
 139:../drivers/fsl_clock.h ****     {               \
 140:../drivers/fsl_clock.h ****         kCLOCK_Pit0 \
 141:../drivers/fsl_clock.h ****     }
 142:../drivers/fsl_clock.h **** 
 143:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PORT. */
 144:../drivers/fsl_clock.h **** #define PORT_CLOCKS                                                          \
 145:../drivers/fsl_clock.h ****     {                                                                        \
 146:../drivers/fsl_clock.h ****         kCLOCK_PortA, kCLOCK_PortB, kCLOCK_PortC, kCLOCK_PortD, kCLOCK_PortE \
 147:../drivers/fsl_clock.h ****     }
 148:../drivers/fsl_clock.h **** 
 149:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for TSI. */
 150:../drivers/fsl_clock.h **** #define TSI_CLOCKS  \
 151:../drivers/fsl_clock.h ****     {               \
 152:../drivers/fsl_clock.h ****         kCLOCK_Tsi0 \
 153:../drivers/fsl_clock.h ****     }
 154:../drivers/fsl_clock.h **** 
 155:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DAC. */
 156:../drivers/fsl_clock.h **** #define DAC_CLOCKS  \
 157:../drivers/fsl_clock.h ****     {               \
 158:../drivers/fsl_clock.h ****         kCLOCK_Dac0 \
 159:../drivers/fsl_clock.h ****     }
 160:../drivers/fsl_clock.h **** 
 161:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPTMR. */
 162:../drivers/fsl_clock.h **** #define LPTMR_CLOCKS  \
 163:../drivers/fsl_clock.h ****     {                 \
 164:../drivers/fsl_clock.h ****         kCLOCK_Lptmr0 \
 165:../drivers/fsl_clock.h ****     }
 166:../drivers/fsl_clock.h **** 
 167:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ADC16. */
 168:../drivers/fsl_clock.h **** #define ADC16_CLOCKS \
 169:../drivers/fsl_clock.h ****     {                \
 170:../drivers/fsl_clock.h ****         kCLOCK_Adc0  \
 171:../drivers/fsl_clock.h ****     }
 172:../drivers/fsl_clock.h **** 
 173:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMA. */
 174:../drivers/fsl_clock.h **** #define DMA_CLOCKS  \
 175:../drivers/fsl_clock.h ****     {               \
 176:../drivers/fsl_clock.h ****         kCLOCK_Dma0 \
 177:../drivers/fsl_clock.h ****     }
 178:../drivers/fsl_clock.h **** 
 179:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPSCI/UART0. */
 180:../drivers/fsl_clock.h **** #define UART0_CLOCKS \
 181:../drivers/fsl_clock.h ****     {                \
 182:../drivers/fsl_clock.h ****         kCLOCK_Uart0 \
 183:../drivers/fsl_clock.h ****     }
 184:../drivers/fsl_clock.h **** 
 185:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for UART. */
 186:../drivers/fsl_clock.h **** #define UART_CLOCKS                                  \
 187:../drivers/fsl_clock.h ****     {                                                \
 188:../drivers/fsl_clock.h ****         kCLOCK_IpInvalid, kCLOCK_Uart1, kCLOCK_Uart2 \
 189:../drivers/fsl_clock.h ****     }
 190:../drivers/fsl_clock.h **** 
 191:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for TPM. */
 192:../drivers/fsl_clock.h **** #define TPM_CLOCKS                            \
 193:../drivers/fsl_clock.h ****     {                                         \
 194:../drivers/fsl_clock.h ****         kCLOCK_Tpm0, kCLOCK_Tpm1, kCLOCK_Tpm2 \
 195:../drivers/fsl_clock.h ****     }
 196:../drivers/fsl_clock.h **** 
 197:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for I2C. */
 198:../drivers/fsl_clock.h **** #define I2C_CLOCKS               \
 199:../drivers/fsl_clock.h ****     {                            \
 200:../drivers/fsl_clock.h ****         kCLOCK_I2c0, kCLOCK_I2c1 \
 201:../drivers/fsl_clock.h ****     }
 202:../drivers/fsl_clock.h **** 
 203:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTF. */
 204:../drivers/fsl_clock.h **** #define FTF_CLOCKS  \
 205:../drivers/fsl_clock.h ****     {               \
 206:../drivers/fsl_clock.h ****         kCLOCK_Ftf0 \
 207:../drivers/fsl_clock.h ****     }
 208:../drivers/fsl_clock.h **** 
 209:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMP. */
 210:../drivers/fsl_clock.h **** #define CMP_CLOCKS  \
 211:../drivers/fsl_clock.h ****     {               \
 212:../drivers/fsl_clock.h ****         kCLOCK_Cmp0 \
 213:../drivers/fsl_clock.h ****     }
 214:../drivers/fsl_clock.h **** 
 215:../drivers/fsl_clock.h **** /*!
 216:../drivers/fsl_clock.h ****  * @brief LPO clock frequency.
 217:../drivers/fsl_clock.h ****  */
 218:../drivers/fsl_clock.h **** #define LPO_CLK_FREQ 1000U
 219:../drivers/fsl_clock.h **** 
 220:../drivers/fsl_clock.h **** /*! @brief Peripherals clock source definition. */
 221:../drivers/fsl_clock.h **** #define SYS_CLK kCLOCK_CoreSysClk
 222:../drivers/fsl_clock.h **** #define BUS_CLK kCLOCK_BusClk
 223:../drivers/fsl_clock.h **** 
 224:../drivers/fsl_clock.h **** #define I2C0_CLK_SRC BUS_CLK
 225:../drivers/fsl_clock.h **** #define I2C1_CLK_SRC BUS_CLK
 226:../drivers/fsl_clock.h **** #define SPI0_CLK_SRC BUS_CLK
 227:../drivers/fsl_clock.h **** #define SPI1_CLK_SRC SYS_CLK
 228:../drivers/fsl_clock.h **** #define UART1_CLK_SRC BUS_CLK
 229:../drivers/fsl_clock.h **** #define UART2_CLK_SRC BUS_CLK
 230:../drivers/fsl_clock.h **** 
 231:../drivers/fsl_clock.h **** /*! @brief Clock name used to get clock frequency. */
 232:../drivers/fsl_clock.h **** typedef enum _clock_name
 233:../drivers/fsl_clock.h **** {
 234:../drivers/fsl_clock.h **** 
 235:../drivers/fsl_clock.h ****     /* ----------------------------- System layer clock -------------------------------*/
 236:../drivers/fsl_clock.h ****     kCLOCK_CoreSysClk,   /*!< Core/system clock                                         */
 237:../drivers/fsl_clock.h ****     kCLOCK_PlatClk,      /*!< Platform clock                                            */
 238:../drivers/fsl_clock.h ****     kCLOCK_BusClk,       /*!< Bus clock                                                 */
 239:../drivers/fsl_clock.h ****     kCLOCK_FlexBusClk,   /*!< FlexBus clock                                             */
 240:../drivers/fsl_clock.h ****     kCLOCK_FlashClk,     /*!< Flash clock                                               */
 241:../drivers/fsl_clock.h ****     kCLOCK_PllFllSelClk, /*!< The clock after SIM[PLLFLLSEL].                           */
 242:../drivers/fsl_clock.h **** 
 243:../drivers/fsl_clock.h ****     /* ---------------------------------- OSC clock -----------------------------------*/
 244:../drivers/fsl_clock.h ****     kCLOCK_Er32kClk,  /*!< External reference 32K clock (ERCLK32K)                   */
 245:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClk, /*!< OSC0 external reference clock (OSC0ERCLK)                 */
 246:../drivers/fsl_clock.h **** 
 247:../drivers/fsl_clock.h ****     /* ----------------------------- MCG and MCG-Lite clock ---------------------------*/
 248:../drivers/fsl_clock.h ****     kCLOCK_McgFixedFreqClk,   /*!< MCG fixed frequency clock (MCGFFCLK)                      */
 249:../drivers/fsl_clock.h ****     kCLOCK_McgInternalRefClk, /*!< MCG internal reference clock (MCGIRCLK)                   */
 250:../drivers/fsl_clock.h ****     kCLOCK_McgFllClk,         /*!< MCGFLLCLK                                                 */
 251:../drivers/fsl_clock.h ****     kCLOCK_McgPll0Clk,        /*!< MCGPLL0CLK                                                */
 252:../drivers/fsl_clock.h ****     kCLOCK_McgExtPllClk,      /*!< EXT_PLLCLK                                                */
 253:../drivers/fsl_clock.h **** 
 254:../drivers/fsl_clock.h ****     /* --------------------------------- Other clock ----------------------------------*/
 255:../drivers/fsl_clock.h ****     kCLOCK_LpoClk, /*!< LPO clock                                                 */
 256:../drivers/fsl_clock.h **** 
 257:../drivers/fsl_clock.h **** } clock_name_t;
 258:../drivers/fsl_clock.h **** 
 259:../drivers/fsl_clock.h **** /*! @brief USB clock source definition. */
 260:../drivers/fsl_clock.h **** typedef enum _clock_usb_src
 261:../drivers/fsl_clock.h **** {
 262:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcPll0 = SIM_SOPT2_USBSRC(1U) | SIM_SOPT2_PLLFLLSEL(1U), /*!< Use PLL0.      */
 263:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcExt = SIM_SOPT2_USBSRC(0U)                             /*!< Use USB_CLKIN. */
 264:../drivers/fsl_clock.h **** } clock_usb_src_t;
 265:../drivers/fsl_clock.h **** 
 266:../drivers/fsl_clock.h **** /*------------------------------------------------------------------------------
 267:../drivers/fsl_clock.h **** 
 268:../drivers/fsl_clock.h ****  clock_gate_t definition:
 269:../drivers/fsl_clock.h **** 
 270:../drivers/fsl_clock.h ****  31                              16                              0
 271:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 272:../drivers/fsl_clock.h ****  | SIM_SCGC register offset       |   control bit offset in SCGC |
 273:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 274:../drivers/fsl_clock.h **** 
 275:../drivers/fsl_clock.h ****  For example, the SDHC clock gate is controlled by SIM_SCGC3[17], the
 276:../drivers/fsl_clock.h ****  SIM_SCGC3 offset in SIM is 0x1030, then kCLOCK_GateSdhc0 is defined as
 277:../drivers/fsl_clock.h **** 
 278:../drivers/fsl_clock.h ****               kCLOCK_GateSdhc0 = (0x1030 << 16) | 17;
 279:../drivers/fsl_clock.h **** 
 280:../drivers/fsl_clock.h **** ------------------------------------------------------------------------------*/
 281:../drivers/fsl_clock.h **** 
 282:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_SHIFT 16U
 283:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_MASK 0xFFFF0000U
 284:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_SHIFT 0U
 285:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_MASK 0x0000FFFFU
 286:../drivers/fsl_clock.h **** 
 287:../drivers/fsl_clock.h **** #define CLK_GATE_DEFINE(reg_offset, bit_shift)                                  \
 288:../drivers/fsl_clock.h ****     ((((reg_offset) << CLK_GATE_REG_OFFSET_SHIFT) & CLK_GATE_REG_OFFSET_MASK) | \
 289:../drivers/fsl_clock.h ****      (((bit_shift) << CLK_GATE_BIT_SHIFT_SHIFT) & CLK_GATE_BIT_SHIFT_MASK))
 290:../drivers/fsl_clock.h **** 
 291:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_REG_OFFSET(x) (((x)&CLK_GATE_REG_OFFSET_MASK) >> CLK_GATE_REG_OFFSET_SHIF
 292:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_BITS_SHIFT(x) (((x)&CLK_GATE_BIT_SHIFT_MASK) >> CLK_GATE_BIT_SHIFT_SHIFT)
 293:../drivers/fsl_clock.h **** 
 294:../drivers/fsl_clock.h **** /*! @brief Clock gate name used for CLOCK_EnableClock/CLOCK_DisableClock. */
 295:../drivers/fsl_clock.h **** typedef enum _clock_ip_name
 296:../drivers/fsl_clock.h **** {
 297:../drivers/fsl_clock.h ****     kCLOCK_IpInvalid = 0U,
 298:../drivers/fsl_clock.h ****     kCLOCK_I2c0 = CLK_GATE_DEFINE(0x1034U, 6U),
 299:../drivers/fsl_clock.h ****     kCLOCK_I2c1 = CLK_GATE_DEFINE(0x1034U, 7U),
 300:../drivers/fsl_clock.h ****     kCLOCK_Uart0 = CLK_GATE_DEFINE(0x1034U, 10U),
 301:../drivers/fsl_clock.h ****     kCLOCK_Uart1 = CLK_GATE_DEFINE(0x1034U, 11U),
 302:../drivers/fsl_clock.h ****     kCLOCK_Uart2 = CLK_GATE_DEFINE(0x1034U, 12U),
 303:../drivers/fsl_clock.h ****     kCLOCK_Usbfs0 = CLK_GATE_DEFINE(0x1034U, 18U),
 304:../drivers/fsl_clock.h ****     kCLOCK_Cmp0 = CLK_GATE_DEFINE(0x1034U, 19U),
 305:../drivers/fsl_clock.h ****     kCLOCK_Spi0 = CLK_GATE_DEFINE(0x1034U, 22U),
 306:../drivers/fsl_clock.h ****     kCLOCK_Spi1 = CLK_GATE_DEFINE(0x1034U, 23U),
 307:../drivers/fsl_clock.h **** 
 308:../drivers/fsl_clock.h ****     kCLOCK_Lptmr0 = CLK_GATE_DEFINE(0x1038U, 0U),
 309:../drivers/fsl_clock.h ****     kCLOCK_Tsi0 = CLK_GATE_DEFINE(0x1038U, 5U),
 310:../drivers/fsl_clock.h ****     kCLOCK_PortA = CLK_GATE_DEFINE(0x1038U, 9U),
 311:../drivers/fsl_clock.h ****     kCLOCK_PortB = CLK_GATE_DEFINE(0x1038U, 10U),
 312:../drivers/fsl_clock.h ****     kCLOCK_PortC = CLK_GATE_DEFINE(0x1038U, 11U),
 313:../drivers/fsl_clock.h ****     kCLOCK_PortD = CLK_GATE_DEFINE(0x1038U, 12U),
 314:../drivers/fsl_clock.h ****     kCLOCK_PortE = CLK_GATE_DEFINE(0x1038U, 13U),
 315:../drivers/fsl_clock.h **** 
 316:../drivers/fsl_clock.h ****     kCLOCK_Ftf0 = CLK_GATE_DEFINE(0x103CU, 0U),
 317:../drivers/fsl_clock.h ****     kCLOCK_Dmamux0 = CLK_GATE_DEFINE(0x103CU, 1U),
 318:../drivers/fsl_clock.h ****     kCLOCK_Pit0 = CLK_GATE_DEFINE(0x103CU, 23U),
 319:../drivers/fsl_clock.h ****     kCLOCK_Tpm0 = CLK_GATE_DEFINE(0x103CU, 24U),
 320:../drivers/fsl_clock.h ****     kCLOCK_Tpm1 = CLK_GATE_DEFINE(0x103CU, 25U),
 321:../drivers/fsl_clock.h ****     kCLOCK_Tpm2 = CLK_GATE_DEFINE(0x103CU, 26U),
 322:../drivers/fsl_clock.h ****     kCLOCK_Adc0 = CLK_GATE_DEFINE(0x103CU, 27U),
 323:../drivers/fsl_clock.h ****     kCLOCK_Rtc0 = CLK_GATE_DEFINE(0x103CU, 29U),
 324:../drivers/fsl_clock.h ****     kCLOCK_Dac0 = CLK_GATE_DEFINE(0x103CU, 31U),
 325:../drivers/fsl_clock.h **** 
 326:../drivers/fsl_clock.h ****     kCLOCK_Dma0 = CLK_GATE_DEFINE(0x1040U, 8U),
 327:../drivers/fsl_clock.h **** } clock_ip_name_t;
 328:../drivers/fsl_clock.h **** 
 329:../drivers/fsl_clock.h **** /*!@brief SIM configuration structure for clock setting. */
 330:../drivers/fsl_clock.h **** typedef struct _sim_clock_config
 331:../drivers/fsl_clock.h **** {
 332:../drivers/fsl_clock.h ****     uint8_t pllFllSel;
 333:../drivers/fsl_clock.h ****     uint8_t er32kSrc; /*!< ERCLK32K source selection.   */
 334:../drivers/fsl_clock.h ****     uint32_t clkdiv1; /*!< SIM_CLKDIV1.                 */
 335:../drivers/fsl_clock.h **** } sim_clock_config_t;
 336:../drivers/fsl_clock.h **** 
 337:../drivers/fsl_clock.h **** /*! @brief OSC work mode. */
 338:../drivers/fsl_clock.h **** typedef enum _osc_mode
 339:../drivers/fsl_clock.h **** {
 340:../drivers/fsl_clock.h ****     kOSC_ModeExt = 0U, /*!< Use an external clock.   */
 341:../drivers/fsl_clock.h **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
 342:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS_MASK, /*!< Oscillator low power. */
 343:../drivers/fsl_clock.h **** #else
 344:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS0_MASK, /*!< Oscillator low power. */
 345:../drivers/fsl_clock.h **** #endif
 346:../drivers/fsl_clock.h ****     kOSC_ModeOscHighGain = 0U
 347:../drivers/fsl_clock.h **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
 348:../drivers/fsl_clock.h ****                            |
 349:../drivers/fsl_clock.h ****                            MCG_C2_EREFS_MASK
 350:../drivers/fsl_clock.h **** #else
 351:../drivers/fsl_clock.h ****                            |
 352:../drivers/fsl_clock.h ****                            MCG_C2_EREFS0_MASK
 353:../drivers/fsl_clock.h **** #endif
 354:../drivers/fsl_clock.h **** #if (defined(MCG_C2_HGO_MASK) && !(defined(MCG_C2_HGO0_MASK)))
 355:../drivers/fsl_clock.h ****                            |
 356:../drivers/fsl_clock.h ****                            MCG_C2_HGO_MASK, /*!< Oscillator high gain. */
 357:../drivers/fsl_clock.h **** #else
 358:../drivers/fsl_clock.h ****                            |
 359:../drivers/fsl_clock.h ****                            MCG_C2_HGO0_MASK, /*!< Oscillator high gain. */
 360:../drivers/fsl_clock.h **** #endif
 361:../drivers/fsl_clock.h **** } osc_mode_t;
 362:../drivers/fsl_clock.h **** 
 363:../drivers/fsl_clock.h **** /*! @brief Oscillator capacitor load setting.*/
 364:../drivers/fsl_clock.h **** enum _osc_cap_load
 365:../drivers/fsl_clock.h **** {
 366:../drivers/fsl_clock.h ****     kOSC_Cap2P = OSC_CR_SC2P_MASK,  /*!< 2  pF capacitor load */
 367:../drivers/fsl_clock.h ****     kOSC_Cap4P = OSC_CR_SC4P_MASK,  /*!< 4  pF capacitor load */
 368:../drivers/fsl_clock.h ****     kOSC_Cap8P = OSC_CR_SC8P_MASK,  /*!< 8  pF capacitor load */
 369:../drivers/fsl_clock.h ****     kOSC_Cap16P = OSC_CR_SC16P_MASK /*!< 16 pF capacitor load */
 370:../drivers/fsl_clock.h **** };
 371:../drivers/fsl_clock.h **** 
 372:../drivers/fsl_clock.h **** /*! @brief OSCERCLK enable mode. */
 373:../drivers/fsl_clock.h **** enum _oscer_enable_mode
 374:../drivers/fsl_clock.h **** {
 375:../drivers/fsl_clock.h ****     kOSC_ErClkEnable = OSC_CR_ERCLKEN_MASK,       /*!< Enable.              */
 376:../drivers/fsl_clock.h ****     kOSC_ErClkEnableInStop = OSC_CR_EREFSTEN_MASK /*!< Enable in stop mode. */
 377:../drivers/fsl_clock.h **** };
 378:../drivers/fsl_clock.h **** 
 379:../drivers/fsl_clock.h **** /*! @brief OSC configuration for OSCERCLK. */
 380:../drivers/fsl_clock.h **** typedef struct _oscer_config
 381:../drivers/fsl_clock.h **** {
 382:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< OSCERCLK enable mode. OR'ed value of @ref _oscer_enable_mode. */
 383:../drivers/fsl_clock.h **** 
 384:../drivers/fsl_clock.h **** } oscer_config_t;
 385:../drivers/fsl_clock.h **** 
 386:../drivers/fsl_clock.h **** /*!
 387:../drivers/fsl_clock.h ****  * @brief OSC Initialization Configuration Structure
 388:../drivers/fsl_clock.h ****  *
 389:../drivers/fsl_clock.h ****  * Defines the configuration data structure to initialize the OSC.
 390:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 391:../drivers/fsl_clock.h ****  * according to the board setting:
 392:../drivers/fsl_clock.h ****  * 1. freq: The external frequency.
 393:../drivers/fsl_clock.h ****  * 2. workMode: The OSC module mode.
 394:../drivers/fsl_clock.h ****  */
 395:../drivers/fsl_clock.h **** typedef struct _osc_config
 396:../drivers/fsl_clock.h **** {
 397:../drivers/fsl_clock.h ****     uint32_t freq;              /*!< External clock frequency.    */
 398:../drivers/fsl_clock.h ****     uint8_t capLoad;            /*!< Capacitor load setting.      */
 399:../drivers/fsl_clock.h ****     osc_mode_t workMode;        /*!< OSC work mode setting.       */
 400:../drivers/fsl_clock.h ****     oscer_config_t oscerConfig; /*!< Configuration for OSCERCLK.  */
 401:../drivers/fsl_clock.h **** } osc_config_t;
 402:../drivers/fsl_clock.h **** 
 403:../drivers/fsl_clock.h **** /*! @brief MCG FLL reference clock source select. */
 404:../drivers/fsl_clock.h **** typedef enum _mcg_fll_src
 405:../drivers/fsl_clock.h **** {
 406:../drivers/fsl_clock.h ****     kMCG_FllSrcExternal, /*!< External reference clock is selected          */
 407:../drivers/fsl_clock.h ****     kMCG_FllSrcInternal  /*!< The slow internal reference clock is selected */
 408:../drivers/fsl_clock.h **** } mcg_fll_src_t;
 409:../drivers/fsl_clock.h **** 
 410:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock select */
 411:../drivers/fsl_clock.h **** typedef enum _mcg_irc_mode
 412:../drivers/fsl_clock.h **** {
 413:../drivers/fsl_clock.h ****     kMCG_IrcSlow, /*!< Slow internal reference clock selected */
 414:../drivers/fsl_clock.h ****     kMCG_IrcFast  /*!< Fast internal reference clock selected */
 415:../drivers/fsl_clock.h **** } mcg_irc_mode_t;
 416:../drivers/fsl_clock.h **** 
 417:../drivers/fsl_clock.h **** /*! @brief MCG DCO Maximum Frequency with 32.768 kHz Reference */
 418:../drivers/fsl_clock.h **** typedef enum _mcg_dmx32
 419:../drivers/fsl_clock.h **** {
 420:../drivers/fsl_clock.h ****     kMCG_Dmx32Default, /*!< DCO has a default range of 25% */
 421:../drivers/fsl_clock.h ****     kMCG_Dmx32Fine     /*!< DCO is fine-tuned for maximum frequency with 32.768 kHz reference */
 422:../drivers/fsl_clock.h **** } mcg_dmx32_t;
 423:../drivers/fsl_clock.h **** 
 424:../drivers/fsl_clock.h **** /*! @brief MCG DCO range select */
 425:../drivers/fsl_clock.h **** typedef enum _mcg_drs
 426:../drivers/fsl_clock.h **** {
 427:../drivers/fsl_clock.h ****     kMCG_DrsLow,     /*!< Low frequency range       */
 428:../drivers/fsl_clock.h ****     kMCG_DrsMid,     /*!< Mid frequency range       */
 429:../drivers/fsl_clock.h ****     kMCG_DrsMidHigh, /*!< Mid-High frequency range  */
 430:../drivers/fsl_clock.h ****     kMCG_DrsHigh     /*!< High frequency range      */
 431:../drivers/fsl_clock.h **** } mcg_drs_t;
 432:../drivers/fsl_clock.h **** 
 433:../drivers/fsl_clock.h **** /*! @brief MCG PLL reference clock select */
 434:../drivers/fsl_clock.h **** typedef enum _mcg_pll_ref_src
 435:../drivers/fsl_clock.h **** {
 436:../drivers/fsl_clock.h ****     kMCG_PllRefOsc0, /*!< Selects OSC0 as PLL reference clock                 */
 437:../drivers/fsl_clock.h ****     kMCG_PllRefOsc1  /*!< Selects OSC1 as PLL reference clock                 */
 438:../drivers/fsl_clock.h **** } mcg_pll_ref_src_t;
 439:../drivers/fsl_clock.h **** 
 440:../drivers/fsl_clock.h **** /*! @brief MCGOUT clock source. */
 441:../drivers/fsl_clock.h **** typedef enum _mcg_clkout_src
 442:../drivers/fsl_clock.h **** {
 443:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcOut,      /*!< Output of the FLL is selected (reset default)  */
 444:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcInternal, /*!< Internal reference clock is selected           */
 445:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcExternal, /*!< External reference clock is selected           */
 446:../drivers/fsl_clock.h **** } mcg_clkout_src_t;
 447:../drivers/fsl_clock.h **** 
 448:../drivers/fsl_clock.h **** /*! @brief MCG Automatic Trim Machine Select */
 449:../drivers/fsl_clock.h **** typedef enum _mcg_atm_select
 450:../drivers/fsl_clock.h **** {
 451:../drivers/fsl_clock.h ****     kMCG_AtmSel32k, /*!< 32 kHz Internal Reference Clock selected  */
 452:../drivers/fsl_clock.h ****     kMCG_AtmSel4m   /*!< 4 MHz Internal Reference Clock selected   */
 453:../drivers/fsl_clock.h **** } mcg_atm_select_t;
 454:../drivers/fsl_clock.h **** 
 455:../drivers/fsl_clock.h **** /*! @brief MCG OSC Clock Select */
 456:../drivers/fsl_clock.h **** typedef enum _mcg_oscsel
 457:../drivers/fsl_clock.h **** {
 458:../drivers/fsl_clock.h ****     kMCG_OscselOsc, /*!< Selects System Oscillator (OSCCLK) */
 459:../drivers/fsl_clock.h ****     kMCG_OscselRtc, /*!< Selects 32 kHz RTC Oscillator      */
 460:../drivers/fsl_clock.h **** } mcg_oscsel_t;
 461:../drivers/fsl_clock.h **** 
 462:../drivers/fsl_clock.h **** /*! @brief MCG PLLCS select */
 463:../drivers/fsl_clock.h **** typedef enum _mcg_pll_clk_select
 464:../drivers/fsl_clock.h **** {
 465:../drivers/fsl_clock.h ****     kMCG_PllClkSelPll0, /*!< PLL0 output clock is selected  */
 466:../drivers/fsl_clock.h ****     kMCG_PllClkSelPll1  /* PLL1 output clock is selected    */
 467:../drivers/fsl_clock.h **** } mcg_pll_clk_select_t;
 468:../drivers/fsl_clock.h **** 
 469:../drivers/fsl_clock.h **** /*! @brief MCG clock monitor mode. */
 470:../drivers/fsl_clock.h **** typedef enum _mcg_monitor_mode
 471:../drivers/fsl_clock.h **** {
 472:../drivers/fsl_clock.h ****     kMCG_MonitorNone, /*!< Clock monitor is disabled.         */
 473:../drivers/fsl_clock.h ****     kMCG_MonitorInt,  /*!< Trigger interrupt when clock lost. */
 474:../drivers/fsl_clock.h ****     kMCG_MonitorReset /*!< System reset when clock lost.      */
 475:../drivers/fsl_clock.h **** } mcg_monitor_mode_t;
 476:../drivers/fsl_clock.h **** 
 477:../drivers/fsl_clock.h **** /*! @brief MCG status. */
 478:../drivers/fsl_clock.h **** enum _mcg_status
 479:../drivers/fsl_clock.h **** {
 480:../drivers/fsl_clock.h ****     kStatus_MCG_ModeUnreachable = MAKE_STATUS(kStatusGroup_MCG, 0),       /*!< Can't switch to targ
 481:../drivers/fsl_clock.h ****     kStatus_MCG_ModeInvalid = MAKE_STATUS(kStatusGroup_MCG, 1),           /*!< Current mode invalid
 482:../drivers/fsl_clock.h ****                                                                                function. */
 483:../drivers/fsl_clock.h ****     kStatus_MCG_AtmBusClockInvalid = MAKE_STATUS(kStatusGroup_MCG, 2),    /*!< Invalid bus clock fo
 484:../drivers/fsl_clock.h ****     kStatus_MCG_AtmDesiredFreqInvalid = MAKE_STATUS(kStatusGroup_MCG, 3), /*!< Invalid desired freq
 485:../drivers/fsl_clock.h ****     kStatus_MCG_AtmIrcUsed = MAKE_STATUS(kStatusGroup_MCG, 4),            /*!< IRC is used when usi
 486:../drivers/fsl_clock.h ****     kStatus_MCG_AtmHardwareFail = MAKE_STATUS(kStatusGroup_MCG, 5),       /*!< Hardware fail occurs
 487:../drivers/fsl_clock.h ****     kStatus_MCG_SourceUsed = MAKE_STATUS(kStatusGroup_MCG, 6)             /*!< Can't change the clo
 488:../drivers/fsl_clock.h ****                                                                                it is in use. */
 489:../drivers/fsl_clock.h **** };
 490:../drivers/fsl_clock.h **** 
 491:../drivers/fsl_clock.h **** /*! @brief MCG status flags. */
 492:../drivers/fsl_clock.h **** enum _mcg_status_flags_t
 493:../drivers/fsl_clock.h **** {
 494:../drivers/fsl_clock.h ****     kMCG_Osc0LostFlag = (1U << 0U), /*!< OSC0 lost.         */
 495:../drivers/fsl_clock.h ****     kMCG_Osc0InitFlag = (1U << 1U), /*!< OSC0 crystal initialized. */
 496:../drivers/fsl_clock.h ****     kMCG_Pll0LostFlag = (1U << 5U), /*!< PLL0 lost.         */
 497:../drivers/fsl_clock.h ****     kMCG_Pll0LockFlag = (1U << 6U), /*!< PLL0 locked.       */
 498:../drivers/fsl_clock.h **** };
 499:../drivers/fsl_clock.h **** 
 500:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock (MCGIRCLK) enable mode definition. */
 501:../drivers/fsl_clock.h **** enum _mcg_irclk_enable_mode
 502:../drivers/fsl_clock.h **** {
 503:../drivers/fsl_clock.h ****     kMCG_IrclkEnable = MCG_C1_IRCLKEN_MASK,       /*!< MCGIRCLK enable.              */
 504:../drivers/fsl_clock.h ****     kMCG_IrclkEnableInStop = MCG_C1_IREFSTEN_MASK /*!< MCGIRCLK enable in stop mode. */
 505:../drivers/fsl_clock.h **** };
 506:../drivers/fsl_clock.h **** 
 507:../drivers/fsl_clock.h **** /*! @brief MCG PLL clock enable mode definition. */
 508:../drivers/fsl_clock.h **** enum _mcg_pll_enable_mode
 509:../drivers/fsl_clock.h **** {
 510:../drivers/fsl_clock.h ****     kMCG_PllEnableIndependent = MCG_C5_PLLCLKEN0_MASK, /*!< MCGPLLCLK enable independent of the
 511:../drivers/fsl_clock.h ****                                                            MCG clock mode. Generally, the PLL
 512:../drivers/fsl_clock.h ****                                                            is disabled in FLL modes
 513:../drivers/fsl_clock.h ****                                                            (FEI/FBI/FEE/FBE). Setting the PLL clock
 514:../drivers/fsl_clock.h ****                                                            enable independent, enables the
 515:../drivers/fsl_clock.h ****                                                            PLL in the FLL modes.          */
 516:../drivers/fsl_clock.h ****     kMCG_PllEnableInStop = MCG_C5_PLLSTEN0_MASK        /*!< MCGPLLCLK enable in STOP mode. */
 517:../drivers/fsl_clock.h **** };
 518:../drivers/fsl_clock.h **** 
 519:../drivers/fsl_clock.h **** /*! @brief MCG mode definitions */
 520:../drivers/fsl_clock.h **** typedef enum _mcg_mode
 521:../drivers/fsl_clock.h **** {
 522:../drivers/fsl_clock.h ****     kMCG_ModeFEI = 0U, /*!< FEI   - FLL Engaged Internal         */
 523:../drivers/fsl_clock.h ****     kMCG_ModeFBI,      /*!< FBI   - FLL Bypassed Internal        */
 524:../drivers/fsl_clock.h ****     kMCG_ModeBLPI,     /*!< BLPI  - Bypassed Low Power Internal  */
 525:../drivers/fsl_clock.h ****     kMCG_ModeFEE,      /*!< FEE   - FLL Engaged External         */
 526:../drivers/fsl_clock.h ****     kMCG_ModeFBE,      /*!< FBE   - FLL Bypassed External        */
 527:../drivers/fsl_clock.h ****     kMCG_ModeBLPE,     /*!< BLPE  - Bypassed Low Power External  */
 528:../drivers/fsl_clock.h ****     kMCG_ModePBE,      /*!< PBE   - PLL Bypassed External        */
 529:../drivers/fsl_clock.h ****     kMCG_ModePEE,      /*!< PEE   - PLL Engaged External         */
 530:../drivers/fsl_clock.h ****     kMCG_ModeError     /*!< Unknown mode                         */
 531:../drivers/fsl_clock.h **** } mcg_mode_t;
 532:../drivers/fsl_clock.h **** 
 533:../drivers/fsl_clock.h **** /*! @brief MCG PLL configuration. */
 534:../drivers/fsl_clock.h **** typedef struct _mcg_pll_config
 535:../drivers/fsl_clock.h **** {
 536:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< Enable mode. OR'ed value of @ref _mcg_pll_enable_mode. */
 537:../drivers/fsl_clock.h ****     uint8_t prdiv;      /*!< Reference divider PRDIV.    */
 538:../drivers/fsl_clock.h ****     uint8_t vdiv;       /*!< VCO divider VDIV.           */
 539:../drivers/fsl_clock.h **** } mcg_pll_config_t;
 540:../drivers/fsl_clock.h **** 
 541:../drivers/fsl_clock.h **** /*! @brief MCG mode change configuration structure
 542:../drivers/fsl_clock.h ****  *
 543:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 544:../drivers/fsl_clock.h ****  * according to the board setting:
 545:../drivers/fsl_clock.h ****  * 1. frdiv: If the FLL uses the external reference clock, set this
 546:../drivers/fsl_clock.h ****  *    value to ensure that the external reference clock divided by frdiv is
 547:../drivers/fsl_clock.h ****  *    in the 31.25 kHz to 39.0625 kHz range.
 548:../drivers/fsl_clock.h ****  * 2. The PLL reference clock divider PRDIV: PLL reference clock frequency after
 549:../drivers/fsl_clock.h ****  *    PRDIV should be in the FSL_FEATURE_MCG_PLL_REF_MIN to
 550:../drivers/fsl_clock.h ****  *    FSL_FEATURE_MCG_PLL_REF_MAX range.
 551:../drivers/fsl_clock.h ****  */
 552:../drivers/fsl_clock.h **** typedef struct _mcg_config
 553:../drivers/fsl_clock.h **** {
 554:../drivers/fsl_clock.h ****     mcg_mode_t mcgMode; /*!< MCG mode.                   */
 555:../drivers/fsl_clock.h **** 
 556:../drivers/fsl_clock.h ****     /* ----------------------- MCGIRCCLK settings ------------------------ */
 557:../drivers/fsl_clock.h ****     uint8_t irclkEnableMode; /*!< MCGIRCLK enable mode.       */
 558:../drivers/fsl_clock.h ****     mcg_irc_mode_t ircs;     /*!< Source, MCG_C2[IRCS].       */
 559:../drivers/fsl_clock.h ****     uint8_t fcrdiv;          /*!< Divider, MCG_SC[FCRDIV].    */
 560:../drivers/fsl_clock.h **** 
 561:../drivers/fsl_clock.h ****     /* ------------------------ MCG FLL settings ------------------------- */
 562:../drivers/fsl_clock.h ****     uint8_t frdiv;     /*!< Divider MCG_C1[FRDIV].      */
 563:../drivers/fsl_clock.h ****     mcg_drs_t drs;     /*!< DCO range MCG_C4[DRST_DRS]. */
 564:../drivers/fsl_clock.h ****     mcg_dmx32_t dmx32; /*!< MCG_C4[DMX32].              */
 565:../drivers/fsl_clock.h **** 
 566:../drivers/fsl_clock.h ****     /* ------------------------ MCG PLL settings ------------------------- */
 567:../drivers/fsl_clock.h ****     mcg_pll_config_t pll0Config; /*!< MCGPLL0CLK configuration.   */
 568:../drivers/fsl_clock.h **** 
 569:../drivers/fsl_clock.h **** } mcg_config_t;
 570:../drivers/fsl_clock.h **** 
 571:../drivers/fsl_clock.h **** /*******************************************************************************
 572:../drivers/fsl_clock.h ****  * API
 573:../drivers/fsl_clock.h ****  ******************************************************************************/
 574:../drivers/fsl_clock.h **** 
 575:../drivers/fsl_clock.h **** #if defined(__cplusplus)
 576:../drivers/fsl_clock.h **** extern "C" {
 577:../drivers/fsl_clock.h **** #endif /* __cplusplus */
 578:../drivers/fsl_clock.h **** 
 579:../drivers/fsl_clock.h **** /*!
 580:../drivers/fsl_clock.h ****  * @brief Enable the clock for specific IP.
 581:../drivers/fsl_clock.h ****  *
 582:../drivers/fsl_clock.h ****  * @param name  Which clock to enable, see \ref clock_ip_name_t.
 583:../drivers/fsl_clock.h ****  */
 584:../drivers/fsl_clock.h **** static inline void CLOCK_EnableClock(clock_ip_name_t name)
 585:../drivers/fsl_clock.h **** {
  26              		.loc 1 585 1
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 16
  29              		@ frame_needed = 1, uses_anonymous_args = 0
  30 0000 80B5     		push	{r7, lr}
  31              		.cfi_def_cfa_offset 8
  32              		.cfi_offset 7, -8
  33              		.cfi_offset 14, -4
  34 0002 84B0     		sub	sp, sp, #16
  35              		.cfi_def_cfa_offset 24
  36 0004 00AF     		add	r7, sp, #0
  37              		.cfi_def_cfa_register 7
  38 0006 7860     		str	r0, [r7, #4]
 586:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
  39              		.loc 1 586 35
  40 0008 7B68     		ldr	r3, [r7, #4]
  41 000a 1B0C     		lsrs	r3, r3, #16
  42              		.loc 1 586 14
  43 000c 084A     		ldr	r2, .L2
  44 000e 9446     		mov	ip, r2
  45 0010 6344     		add	r3, r3, ip
  46 0012 FB60     		str	r3, [r7, #12]
 587:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
  47              		.loc 1 587 37
  48 0014 FB68     		ldr	r3, [r7, #12]
  49 0016 1968     		ldr	r1, [r3]
  50              		.loc 1 587 47
  51 0018 7B68     		ldr	r3, [r7, #4]
  52 001a 1B04     		lsls	r3, r3, #16
  53 001c 1B0C     		lsrs	r3, r3, #16
  54              		.loc 1 587 44
  55 001e 0122     		movs	r2, #1
  56 0020 9A40     		lsls	r2, r2, r3
  57              		.loc 1 587 37
  58 0022 FB68     		ldr	r3, [r7, #12]
  59 0024 0A43     		orrs	r2, r1
  60 0026 1A60     		str	r2, [r3]
 588:../drivers/fsl_clock.h **** }
  61              		.loc 1 588 1
  62 0028 C046     		nop
  63 002a BD46     		mov	sp, r7
  64 002c 04B0     		add	sp, sp, #16
  65              		@ sp needed
  66 002e 80BD     		pop	{r7, pc}
  67              	.L3:
  68              		.align	2
  69              	.L2:
  70 0030 00700440 		.word	1074032640
  71              		.cfi_endproc
  72              	.LFE38:
  74              		.section	.text.CLOCK_DisableClock,"ax",%progbits
  75              		.align	1
  76              		.syntax unified
  77              		.code	16
  78              		.thumb_func
  79              		.fpu softvfp
  81              	CLOCK_DisableClock:
  82              	.LFB39:
 589:../drivers/fsl_clock.h **** 
 590:../drivers/fsl_clock.h **** /*!
 591:../drivers/fsl_clock.h ****  * @brief Disable the clock for specific IP.
 592:../drivers/fsl_clock.h ****  *
 593:../drivers/fsl_clock.h ****  * @param name  Which clock to disable, see \ref clock_ip_name_t.
 594:../drivers/fsl_clock.h ****  */
 595:../drivers/fsl_clock.h **** static inline void CLOCK_DisableClock(clock_ip_name_t name)
 596:../drivers/fsl_clock.h **** {
  83              		.loc 1 596 1
  84              		.cfi_startproc
  85              		@ args = 0, pretend = 0, frame = 16
  86              		@ frame_needed = 1, uses_anonymous_args = 0
  87 0000 80B5     		push	{r7, lr}
  88              		.cfi_def_cfa_offset 8
  89              		.cfi_offset 7, -8
  90              		.cfi_offset 14, -4
  91 0002 84B0     		sub	sp, sp, #16
  92              		.cfi_def_cfa_offset 24
  93 0004 00AF     		add	r7, sp, #0
  94              		.cfi_def_cfa_register 7
  95 0006 7860     		str	r0, [r7, #4]
 597:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
  96              		.loc 1 597 35
  97 0008 7B68     		ldr	r3, [r7, #4]
  98 000a 1B0C     		lsrs	r3, r3, #16
  99              		.loc 1 597 14
 100 000c 094A     		ldr	r2, .L5
 101 000e 9446     		mov	ip, r2
 102 0010 6344     		add	r3, r3, ip
 103 0012 FB60     		str	r3, [r7, #12]
 598:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) &= ~(1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 104              		.loc 1 598 37
 105 0014 FB68     		ldr	r3, [r7, #12]
 106 0016 1A68     		ldr	r2, [r3]
 107              		.loc 1 598 48
 108 0018 7B68     		ldr	r3, [r7, #4]
 109 001a 1B04     		lsls	r3, r3, #16
 110 001c 1B0C     		lsrs	r3, r3, #16
 111              		.loc 1 598 45
 112 001e 0121     		movs	r1, #1
 113 0020 9940     		lsls	r1, r1, r3
 114 0022 0B00     		movs	r3, r1
 115              		.loc 1 598 40
 116 0024 D943     		mvns	r1, r3
 117              		.loc 1 598 37
 118 0026 FB68     		ldr	r3, [r7, #12]
 119 0028 0A40     		ands	r2, r1
 120 002a 1A60     		str	r2, [r3]
 599:../drivers/fsl_clock.h **** }
 121              		.loc 1 599 1
 122 002c C046     		nop
 123 002e BD46     		mov	sp, r7
 124 0030 04B0     		add	sp, sp, #16
 125              		@ sp needed
 126 0032 80BD     		pop	{r7, pc}
 127              	.L6:
 128              		.align	2
 129              	.L5:
 130 0034 00700440 		.word	1074032640
 131              		.cfi_endproc
 132              	.LFE39:
 134              		.section	.text.CLOCK_SetEr32kClock,"ax",%progbits
 135              		.align	1
 136              		.syntax unified
 137              		.code	16
 138              		.thumb_func
 139              		.fpu softvfp
 141              	CLOCK_SetEr32kClock:
 142              	.LFB40:
 600:../drivers/fsl_clock.h **** 
 601:../drivers/fsl_clock.h **** /*! @brief Set ERCLK32K source. */
 602:../drivers/fsl_clock.h **** static inline void CLOCK_SetEr32kClock(uint32_t src)
 603:../drivers/fsl_clock.h **** {
 143              		.loc 1 603 1
 144              		.cfi_startproc
 145              		@ args = 0, pretend = 0, frame = 8
 146              		@ frame_needed = 1, uses_anonymous_args = 0
 147 0000 80B5     		push	{r7, lr}
 148              		.cfi_def_cfa_offset 8
 149              		.cfi_offset 7, -8
 150              		.cfi_offset 14, -4
 151 0002 82B0     		sub	sp, sp, #8
 152              		.cfi_def_cfa_offset 16
 153 0004 00AF     		add	r7, sp, #0
 154              		.cfi_def_cfa_register 7
 155 0006 7860     		str	r0, [r7, #4]
 604:../drivers/fsl_clock.h ****     SIM->SOPT1 = ((SIM->SOPT1 & ~SIM_SOPT1_OSC32KSEL_MASK) | SIM_SOPT1_OSC32KSEL(src));
 156              		.loc 1 604 23
 157 0008 084B     		ldr	r3, .L8
 158 000a 1B68     		ldr	r3, [r3]
 159              		.loc 1 604 31
 160 000c 084A     		ldr	r2, .L8+4
 161 000e 1340     		ands	r3, r2
 162 0010 1900     		movs	r1, r3
 163              		.loc 1 604 62
 164 0012 7B68     		ldr	r3, [r7, #4]
 165 0014 9A04     		lsls	r2, r3, #18
 166 0016 C023     		movs	r3, #192
 167 0018 1B03     		lsls	r3, r3, #12
 168 001a 1A40     		ands	r2, r3
 169              		.loc 1 604 8
 170 001c 034B     		ldr	r3, .L8
 171              		.loc 1 604 60
 172 001e 0A43     		orrs	r2, r1
 173              		.loc 1 604 16
 174 0020 1A60     		str	r2, [r3]
 605:../drivers/fsl_clock.h **** }
 175              		.loc 1 605 1
 176 0022 C046     		nop
 177 0024 BD46     		mov	sp, r7
 178 0026 02B0     		add	sp, sp, #8
 179              		@ sp needed
 180 0028 80BD     		pop	{r7, pc}
 181              	.L9:
 182 002a C046     		.align	2
 183              	.L8:
 184 002c 00700440 		.word	1074032640
 185 0030 FFFFF3FF 		.word	-786433
 186              		.cfi_endproc
 187              	.LFE40:
 189              		.section	.text.CLOCK_SetPllFllSelClock,"ax",%progbits
 190              		.align	1
 191              		.syntax unified
 192              		.code	16
 193              		.thumb_func
 194              		.fpu softvfp
 196              	CLOCK_SetPllFllSelClock:
 197              	.LFB41:
 606:../drivers/fsl_clock.h **** 
 607:../drivers/fsl_clock.h **** /*! @brief Set PLLFLLSEL clock source. */
 608:../drivers/fsl_clock.h **** static inline void CLOCK_SetPllFllSelClock(uint32_t src)
 609:../drivers/fsl_clock.h **** {
 198              		.loc 1 609 1
 199              		.cfi_startproc
 200              		@ args = 0, pretend = 0, frame = 8
 201              		@ frame_needed = 1, uses_anonymous_args = 0
 202 0000 80B5     		push	{r7, lr}
 203              		.cfi_def_cfa_offset 8
 204              		.cfi_offset 7, -8
 205              		.cfi_offset 14, -4
 206 0002 82B0     		sub	sp, sp, #8
 207              		.cfi_def_cfa_offset 16
 208 0004 00AF     		add	r7, sp, #0
 209              		.cfi_def_cfa_register 7
 210 0006 7860     		str	r0, [r7, #4]
 610:../drivers/fsl_clock.h ****     SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_PLLFLLSEL_MASK) | SIM_SOPT2_PLLFLLSEL(src));
 211              		.loc 1 610 23
 212 0008 084A     		ldr	r2, .L11
 213 000a 094B     		ldr	r3, .L11+4
 214 000c D358     		ldr	r3, [r2, r3]
 215              		.loc 1 610 31
 216 000e 094A     		ldr	r2, .L11+8
 217 0010 1A40     		ands	r2, r3
 218              		.loc 1 610 62
 219 0012 7B68     		ldr	r3, [r7, #4]
 220 0014 1904     		lsls	r1, r3, #16
 221 0016 8023     		movs	r3, #128
 222 0018 5B02     		lsls	r3, r3, #9
 223 001a 0B40     		ands	r3, r1
 224              		.loc 1 610 8
 225 001c 0349     		ldr	r1, .L11
 226              		.loc 1 610 60
 227 001e 1343     		orrs	r3, r2
 228              		.loc 1 610 16
 229 0020 034A     		ldr	r2, .L11+4
 230 0022 8B50     		str	r3, [r1, r2]
 611:../drivers/fsl_clock.h **** }
 231              		.loc 1 611 1
 232 0024 C046     		nop
 233 0026 BD46     		mov	sp, r7
 234 0028 02B0     		add	sp, sp, #8
 235              		@ sp needed
 236 002a 80BD     		pop	{r7, pc}
 237              	.L12:
 238              		.align	2
 239              	.L11:
 240 002c 00700440 		.word	1074032640
 241 0030 04100000 		.word	4100
 242 0034 FFFFFEFF 		.word	-65537
 243              		.cfi_endproc
 244              	.LFE41:
 246              		.section	.text.OSC_SetExtRefClkConfig,"ax",%progbits
 247              		.align	1
 248              		.syntax unified
 249              		.code	16
 250              		.thumb_func
 251              		.fpu softvfp
 253              	OSC_SetExtRefClkConfig:
 254              	.LFB52:
 612:../drivers/fsl_clock.h **** 
 613:../drivers/fsl_clock.h **** /*! @brief Set TPM clock source. */
 614:../drivers/fsl_clock.h **** static inline void CLOCK_SetTpmClock(uint32_t src)
 615:../drivers/fsl_clock.h **** {
 616:../drivers/fsl_clock.h ****     SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_TPMSRC_MASK) | SIM_SOPT2_TPMSRC(src));
 617:../drivers/fsl_clock.h **** }
 618:../drivers/fsl_clock.h **** 
 619:../drivers/fsl_clock.h **** /*! @brief Set LPSCI0 (UART0) clock source. */
 620:../drivers/fsl_clock.h **** static inline void CLOCK_SetLpsci0Clock(uint32_t src)
 621:../drivers/fsl_clock.h **** {
 622:../drivers/fsl_clock.h ****     SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_UART0SRC_MASK) | SIM_SOPT2_UART0SRC(src));
 623:../drivers/fsl_clock.h **** }
 624:../drivers/fsl_clock.h **** 
 625:../drivers/fsl_clock.h **** /*! @brief Enable USB FS clock.
 626:../drivers/fsl_clock.h ****  *
 627:../drivers/fsl_clock.h ****  * @param src  USB FS clock source.
 628:../drivers/fsl_clock.h ****  * @param freq The frequency specified by src.
 629:../drivers/fsl_clock.h ****  * @retval true The clock is set successfully.
 630:../drivers/fsl_clock.h ****  * @retval false The clock source is invalid to get proper USB FS clock.
 631:../drivers/fsl_clock.h ****  */
 632:../drivers/fsl_clock.h **** bool CLOCK_EnableUsbfs0Clock(clock_usb_src_t src, uint32_t freq);
 633:../drivers/fsl_clock.h **** 
 634:../drivers/fsl_clock.h **** /*! @brief Disable USB FS clock.
 635:../drivers/fsl_clock.h ****  *
 636:../drivers/fsl_clock.h ****  * Disable USB FS clock.
 637:../drivers/fsl_clock.h ****  */
 638:../drivers/fsl_clock.h **** static inline void CLOCK_DisableUsbfs0Clock(void)
 639:../drivers/fsl_clock.h **** {
 640:../drivers/fsl_clock.h ****     CLOCK_DisableClock(kCLOCK_Usbfs0);
 641:../drivers/fsl_clock.h **** }
 642:../drivers/fsl_clock.h **** 
 643:../drivers/fsl_clock.h **** /*! @brief Set CLKOUT source. */
 644:../drivers/fsl_clock.h **** static inline void CLOCK_SetClkOutClock(uint32_t src)
 645:../drivers/fsl_clock.h **** {
 646:../drivers/fsl_clock.h ****     SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_CLKOUTSEL_MASK) | SIM_SOPT2_CLKOUTSEL(src));
 647:../drivers/fsl_clock.h **** }
 648:../drivers/fsl_clock.h **** 
 649:../drivers/fsl_clock.h **** /*! @brief Set RTC_CLKOUT source. */
 650:../drivers/fsl_clock.h **** static inline void CLOCK_SetRtcClkOutClock(uint32_t src)
 651:../drivers/fsl_clock.h **** {
 652:../drivers/fsl_clock.h ****     SIM->SOPT2 = ((SIM->SOPT2 & ~SIM_SOPT2_RTCCLKOUTSEL_MASK) | SIM_SOPT2_RTCCLKOUTSEL(src));
 653:../drivers/fsl_clock.h **** }
 654:../drivers/fsl_clock.h **** 
 655:../drivers/fsl_clock.h **** /*!
 656:../drivers/fsl_clock.h ****  * @brief
 657:../drivers/fsl_clock.h ****  * Set the SIM_CLKDIV1[OUTDIV1], SIM_CLKDIV1[OUTDIV4].
 658:../drivers/fsl_clock.h ****  */
 659:../drivers/fsl_clock.h **** static inline void CLOCK_SetOutDiv(uint32_t outdiv1, uint32_t outdiv4)
 660:../drivers/fsl_clock.h **** {
 661:../drivers/fsl_clock.h ****     SIM->CLKDIV1 = SIM_CLKDIV1_OUTDIV1(outdiv1) | SIM_CLKDIV1_OUTDIV4(outdiv4);
 662:../drivers/fsl_clock.h **** }
 663:../drivers/fsl_clock.h **** 
 664:../drivers/fsl_clock.h **** /*!
 665:../drivers/fsl_clock.h ****  * @brief Gets the clock frequency for a specific clock name.
 666:../drivers/fsl_clock.h ****  *
 667:../drivers/fsl_clock.h ****  * This function checks the current clock configurations and then calculates
 668:../drivers/fsl_clock.h ****  * the clock frequency for a specific clock name defined in clock_name_t.
 669:../drivers/fsl_clock.h ****  * The MCG must be properly configured before using this function.
 670:../drivers/fsl_clock.h ****  *
 671:../drivers/fsl_clock.h ****  * @param clockName Clock names defined in clock_name_t
 672:../drivers/fsl_clock.h ****  * @return Clock frequency value in Hertz
 673:../drivers/fsl_clock.h ****  */
 674:../drivers/fsl_clock.h **** uint32_t CLOCK_GetFreq(clock_name_t clockName);
 675:../drivers/fsl_clock.h **** 
 676:../drivers/fsl_clock.h **** /*!
 677:../drivers/fsl_clock.h ****  * @brief Get the core clock or system clock frequency.
 678:../drivers/fsl_clock.h ****  *
 679:../drivers/fsl_clock.h ****  * @return Clock frequency in Hz.
 680:../drivers/fsl_clock.h ****  */
 681:../drivers/fsl_clock.h **** uint32_t CLOCK_GetCoreSysClkFreq(void);
 682:../drivers/fsl_clock.h **** 
 683:../drivers/fsl_clock.h **** /*!
 684:../drivers/fsl_clock.h ****  * @brief Get the platform clock frequency.
 685:../drivers/fsl_clock.h ****  *
 686:../drivers/fsl_clock.h ****  * @return Clock frequency in Hz.
 687:../drivers/fsl_clock.h ****  */
 688:../drivers/fsl_clock.h **** uint32_t CLOCK_GetPlatClkFreq(void);
 689:../drivers/fsl_clock.h **** 
 690:../drivers/fsl_clock.h **** /*!
 691:../drivers/fsl_clock.h ****  * @brief Get the bus clock frequency.
 692:../drivers/fsl_clock.h ****  *
 693:../drivers/fsl_clock.h ****  * @return Clock frequency in Hz.
 694:../drivers/fsl_clock.h ****  */
 695:../drivers/fsl_clock.h **** uint32_t CLOCK_GetBusClkFreq(void);
 696:../drivers/fsl_clock.h **** 
 697:../drivers/fsl_clock.h **** /*!
 698:../drivers/fsl_clock.h ****  * @brief Get the flash clock frequency.
 699:../drivers/fsl_clock.h ****  *
 700:../drivers/fsl_clock.h ****  * @return Clock frequency in Hz.
 701:../drivers/fsl_clock.h ****  */
 702:../drivers/fsl_clock.h **** uint32_t CLOCK_GetFlashClkFreq(void);
 703:../drivers/fsl_clock.h **** 
 704:../drivers/fsl_clock.h **** /*!
 705:../drivers/fsl_clock.h ****  * @brief Get the output clock frequency selected by SIM[PLLFLLSEL].
 706:../drivers/fsl_clock.h ****  *
 707:../drivers/fsl_clock.h ****  * @return Clock frequency in Hz.
 708:../drivers/fsl_clock.h ****  */
 709:../drivers/fsl_clock.h **** uint32_t CLOCK_GetPllFllSelClkFreq(void);
 710:../drivers/fsl_clock.h **** 
 711:../drivers/fsl_clock.h **** /*!
 712:../drivers/fsl_clock.h ****  * @brief Get the external reference 32K clock frequency (ERCLK32K).
 713:../drivers/fsl_clock.h ****  *
 714:../drivers/fsl_clock.h ****  * @return Clock frequency in Hz.
 715:../drivers/fsl_clock.h ****  */
 716:../drivers/fsl_clock.h **** uint32_t CLOCK_GetEr32kClkFreq(void);
 717:../drivers/fsl_clock.h **** 
 718:../drivers/fsl_clock.h **** /*!
 719:../drivers/fsl_clock.h ****  * @brief Get the OSC0 external reference clock frequency (OSC0ERCLK).
 720:../drivers/fsl_clock.h ****  *
 721:../drivers/fsl_clock.h ****  * @return Clock frequency in Hz.
 722:../drivers/fsl_clock.h ****  */
 723:../drivers/fsl_clock.h **** uint32_t CLOCK_GetOsc0ErClkFreq(void);
 724:../drivers/fsl_clock.h **** 
 725:../drivers/fsl_clock.h **** /*!
 726:../drivers/fsl_clock.h ****  * @brief Set the clock configure in SIM module.
 727:../drivers/fsl_clock.h ****  *
 728:../drivers/fsl_clock.h ****  * This function sets system layer clock settings in SIM module.
 729:../drivers/fsl_clock.h ****  *
 730:../drivers/fsl_clock.h ****  * @param config Pointer to the configure structure.
 731:../drivers/fsl_clock.h ****  */
 732:../drivers/fsl_clock.h **** void CLOCK_SetSimConfig(sim_clock_config_t const *config);
 733:../drivers/fsl_clock.h **** 
 734:../drivers/fsl_clock.h **** /*!
 735:../drivers/fsl_clock.h ****  * @brief Set the system clock dividers in SIM to safe value.
 736:../drivers/fsl_clock.h ****  *
 737:../drivers/fsl_clock.h ****  * The system level clocks (core clock, bus clock, flexbus clock and flash clock)
 738:../drivers/fsl_clock.h ****  * must be in allowed ranges. During MCG clock mode switch, the MCG output clock
 739:../drivers/fsl_clock.h ****  * changes then the system level clocks may be out of range. This function could
 740:../drivers/fsl_clock.h ****  * be used before MCG mode change, to make sure system level clocks are in allowed
 741:../drivers/fsl_clock.h ****  * range.
 742:../drivers/fsl_clock.h ****  *
 743:../drivers/fsl_clock.h ****  * @param config Pointer to the configure structure.
 744:../drivers/fsl_clock.h ****  */
 745:../drivers/fsl_clock.h **** static inline void CLOCK_SetSimSafeDivs(void)
 746:../drivers/fsl_clock.h **** {
 747:../drivers/fsl_clock.h ****     SIM->CLKDIV1 = 0x10030000U;
 748:../drivers/fsl_clock.h **** }
 749:../drivers/fsl_clock.h **** 
 750:../drivers/fsl_clock.h **** /*! @name MCG frequency functions. */
 751:../drivers/fsl_clock.h **** /*@{*/
 752:../drivers/fsl_clock.h **** 
 753:../drivers/fsl_clock.h **** /*!
 754:../drivers/fsl_clock.h ****  * @brief Gets the MCG output clock (MCGOUTCLK) frequency.
 755:../drivers/fsl_clock.h ****  *
 756:../drivers/fsl_clock.h ****  * This function gets the MCG output clock frequency in Hz based on the current MCG
 757:../drivers/fsl_clock.h ****  * register value.
 758:../drivers/fsl_clock.h ****  *
 759:../drivers/fsl_clock.h ****  * @return The frequency of MCGOUTCLK.
 760:../drivers/fsl_clock.h ****  */
 761:../drivers/fsl_clock.h **** uint32_t CLOCK_GetOutClkFreq(void);
 762:../drivers/fsl_clock.h **** 
 763:../drivers/fsl_clock.h **** /*!
 764:../drivers/fsl_clock.h ****  * @brief Gets the MCG FLL clock (MCGFLLCLK) frequency.
 765:../drivers/fsl_clock.h ****  *
 766:../drivers/fsl_clock.h ****  * This function gets the MCG FLL clock frequency in Hz based on the current MCG
 767:../drivers/fsl_clock.h ****  * register value. The FLL is enabled in FEI/FBI/FEE/FBE mode and
 768:../drivers/fsl_clock.h ****  * disabled in low power state in other modes.
 769:../drivers/fsl_clock.h ****  *
 770:../drivers/fsl_clock.h ****  * @return The frequency of MCGFLLCLK.
 771:../drivers/fsl_clock.h ****  */
 772:../drivers/fsl_clock.h **** uint32_t CLOCK_GetFllFreq(void);
 773:../drivers/fsl_clock.h **** 
 774:../drivers/fsl_clock.h **** /*!
 775:../drivers/fsl_clock.h ****  * @brief Gets the MCG internal reference clock (MCGIRCLK) frequency.
 776:../drivers/fsl_clock.h ****  *
 777:../drivers/fsl_clock.h ****  * This function gets the MCG internal reference clock frequency in Hz based
 778:../drivers/fsl_clock.h ****  * on the current MCG register value.
 779:../drivers/fsl_clock.h ****  *
 780:../drivers/fsl_clock.h ****  * @return The frequency of MCGIRCLK.
 781:../drivers/fsl_clock.h ****  */
 782:../drivers/fsl_clock.h **** uint32_t CLOCK_GetInternalRefClkFreq(void);
 783:../drivers/fsl_clock.h **** 
 784:../drivers/fsl_clock.h **** /*!
 785:../drivers/fsl_clock.h ****  * @brief Gets the MCG fixed frequency clock (MCGFFCLK) frequency.
 786:../drivers/fsl_clock.h ****  *
 787:../drivers/fsl_clock.h ****  * This function gets the MCG fixed frequency clock frequency in Hz based
 788:../drivers/fsl_clock.h ****  * on the current MCG register value.
 789:../drivers/fsl_clock.h ****  *
 790:../drivers/fsl_clock.h ****  * @return The frequency of MCGFFCLK.
 791:../drivers/fsl_clock.h ****  */
 792:../drivers/fsl_clock.h **** uint32_t CLOCK_GetFixedFreqClkFreq(void);
 793:../drivers/fsl_clock.h **** 
 794:../drivers/fsl_clock.h **** /*!
 795:../drivers/fsl_clock.h ****  * @brief Gets the MCG PLL0 clock (MCGPLL0CLK) frequency.
 796:../drivers/fsl_clock.h ****  *
 797:../drivers/fsl_clock.h ****  * This function gets the MCG PLL0 clock frequency in Hz based on the current MCG
 798:../drivers/fsl_clock.h ****  * register value.
 799:../drivers/fsl_clock.h ****  *
 800:../drivers/fsl_clock.h ****  * @return The frequency of MCGPLL0CLK.
 801:../drivers/fsl_clock.h ****  */
 802:../drivers/fsl_clock.h **** uint32_t CLOCK_GetPll0Freq(void);
 803:../drivers/fsl_clock.h **** 
 804:../drivers/fsl_clock.h **** /*@}*/
 805:../drivers/fsl_clock.h **** 
 806:../drivers/fsl_clock.h **** /*! @name MCG clock configuration. */
 807:../drivers/fsl_clock.h **** /*@{*/
 808:../drivers/fsl_clock.h **** 
 809:../drivers/fsl_clock.h **** /*!
 810:../drivers/fsl_clock.h ****  * @brief Enables or disables the MCG low power.
 811:../drivers/fsl_clock.h ****  *
 812:../drivers/fsl_clock.h ****  * Enabling the MCG low power disables the PLL and FLL in bypass modes. In other words,
 813:../drivers/fsl_clock.h ****  * in FBE and PBE modes, enabling low power sets the MCG to BLPE mode. In FBI and
 814:../drivers/fsl_clock.h ****  * PBI modes, enabling low power sets the MCG to BLPI mode.
 815:../drivers/fsl_clock.h ****  * When disabling the MCG low power, the PLL or FLL are enabled based on MCG settings.
 816:../drivers/fsl_clock.h ****  *
 817:../drivers/fsl_clock.h ****  * @param enable True to enable MCG low power, false to disable MCG low power.
 818:../drivers/fsl_clock.h ****  */
 819:../drivers/fsl_clock.h **** static inline void CLOCK_SetLowPowerEnable(bool enable)
 820:../drivers/fsl_clock.h **** {
 821:../drivers/fsl_clock.h ****     if (enable)
 822:../drivers/fsl_clock.h ****     {
 823:../drivers/fsl_clock.h ****         MCG->C2 |= MCG_C2_LP_MASK;
 824:../drivers/fsl_clock.h ****     }
 825:../drivers/fsl_clock.h ****     else
 826:../drivers/fsl_clock.h ****     {
 827:../drivers/fsl_clock.h ****         MCG->C2 &= ~MCG_C2_LP_MASK;
 828:../drivers/fsl_clock.h ****     }
 829:../drivers/fsl_clock.h **** }
 830:../drivers/fsl_clock.h **** 
 831:../drivers/fsl_clock.h **** /*!
 832:../drivers/fsl_clock.h ****  * @brief Configures the Internal Reference clock (MCGIRCLK).
 833:../drivers/fsl_clock.h ****  *
 834:../drivers/fsl_clock.h ****  * This function sets the \c MCGIRCLK base on parameters. It also selects the IRC
 835:../drivers/fsl_clock.h ****  * source. If the fast IRC is used, this function sets the fast IRC divider.
 836:../drivers/fsl_clock.h ****  * This function also sets whether the \c MCGIRCLK is enabled in stop mode.
 837:../drivers/fsl_clock.h ****  * Calling this function in FBI/PBI/BLPI modes may change the system clock. As a result,
 838:../drivers/fsl_clock.h ****  * using the function in these modes it is not allowed.
 839:../drivers/fsl_clock.h ****  *
 840:../drivers/fsl_clock.h ****  * @param enableMode MCGIRCLK enable mode, OR'ed value of @ref _mcg_irclk_enable_mode.
 841:../drivers/fsl_clock.h ****  * @param ircs       MCGIRCLK clock source, choose fast or slow.
 842:../drivers/fsl_clock.h ****  * @param fcrdiv     Fast IRC divider setting (\c FCRDIV).
 843:../drivers/fsl_clock.h ****  * @retval kStatus_MCG_SourceUsed Because the internall reference clock is used as a clock source,
 844:../drivers/fsl_clock.h ****  * the confuration should not be changed. Otherwise, a glitch occurs.
 845:../drivers/fsl_clock.h ****  * @retval kStatus_Success MCGIRCLK configuration finished successfully.
 846:../drivers/fsl_clock.h ****  */
 847:../drivers/fsl_clock.h **** status_t CLOCK_SetInternalRefClkConfig(uint8_t enableMode, mcg_irc_mode_t ircs, uint8_t fcrdiv);
 848:../drivers/fsl_clock.h **** 
 849:../drivers/fsl_clock.h **** /*!
 850:../drivers/fsl_clock.h ****  * @brief Selects the MCG external reference clock.
 851:../drivers/fsl_clock.h ****  *
 852:../drivers/fsl_clock.h ****  * Selects the MCG external reference clock source, changes the MCG_C7[OSCSEL],
 853:../drivers/fsl_clock.h ****  * and waits for the clock source to be stable. Because the external reference
 854:../drivers/fsl_clock.h ****  * clock should not be changed in FEE/FBE/BLPE/PBE/PEE modes, do not call this function in these mo
 855:../drivers/fsl_clock.h ****  *
 856:../drivers/fsl_clock.h ****  * @param oscsel MCG external reference clock source, MCG_C7[OSCSEL].
 857:../drivers/fsl_clock.h ****  * @retval kStatus_MCG_SourceUsed Because the external reference clock is used as a clock source,
 858:../drivers/fsl_clock.h ****  * the confuration should not be changed. Otherwise, a glitch occurs.
 859:../drivers/fsl_clock.h ****  * @retval kStatus_Success External reference clock set successfully.
 860:../drivers/fsl_clock.h ****  */
 861:../drivers/fsl_clock.h **** status_t CLOCK_SetExternalRefClkConfig(mcg_oscsel_t oscsel);
 862:../drivers/fsl_clock.h **** 
 863:../drivers/fsl_clock.h **** /*!
 864:../drivers/fsl_clock.h ****  * @brief Set the FLL external reference clock divider value.
 865:../drivers/fsl_clock.h ****  *
 866:../drivers/fsl_clock.h ****  * Sets the FLL external reference clock divider value, the register MCG_C1[FRDIV].
 867:../drivers/fsl_clock.h ****  *
 868:../drivers/fsl_clock.h ****  * @param frdiv The FLL external reference clock divider value, MCG_C1[FRDIV].
 869:../drivers/fsl_clock.h ****  */
 870:../drivers/fsl_clock.h **** static inline void CLOCK_SetFllExtRefDiv(uint8_t frdiv)
 871:../drivers/fsl_clock.h **** {
 872:../drivers/fsl_clock.h ****     MCG->C1 = (MCG->C1 & ~MCG_C1_FRDIV_MASK) | MCG_C1_FRDIV(frdiv);
 873:../drivers/fsl_clock.h **** }
 874:../drivers/fsl_clock.h **** 
 875:../drivers/fsl_clock.h **** /*!
 876:../drivers/fsl_clock.h ****  * @brief Enables the PLL0 in FLL mode.
 877:../drivers/fsl_clock.h ****  *
 878:../drivers/fsl_clock.h ****  * This function sets us the PLL0 in FLL mode and reconfigures
 879:../drivers/fsl_clock.h ****  * the PLL0. Ensure that the PLL reference
 880:../drivers/fsl_clock.h ****  * clock is enabled before calling this function and that the PLL0 is not used as a clock source.
 881:../drivers/fsl_clock.h ****  * The function CLOCK_CalcPllDiv gets the correct PLL
 882:../drivers/fsl_clock.h ****  * divider values.
 883:../drivers/fsl_clock.h ****  *
 884:../drivers/fsl_clock.h ****  * @param config Pointer to the configuration structure.
 885:../drivers/fsl_clock.h ****  */
 886:../drivers/fsl_clock.h **** void CLOCK_EnablePll0(mcg_pll_config_t const *config);
 887:../drivers/fsl_clock.h **** 
 888:../drivers/fsl_clock.h **** /*!
 889:../drivers/fsl_clock.h ****  * @brief Disables the PLL0 in FLL mode.
 890:../drivers/fsl_clock.h ****  *
 891:../drivers/fsl_clock.h ****  * This function disables the PLL0 in FLL mode. It should be used together with the
 892:../drivers/fsl_clock.h ****  * @ref CLOCK_EnablePll0.
 893:../drivers/fsl_clock.h ****  */
 894:../drivers/fsl_clock.h **** static inline void CLOCK_DisablePll0(void)
 895:../drivers/fsl_clock.h **** {
 896:../drivers/fsl_clock.h ****     MCG->C5 &= ~(MCG_C5_PLLCLKEN0_MASK | MCG_C5_PLLSTEN0_MASK);
 897:../drivers/fsl_clock.h **** }
 898:../drivers/fsl_clock.h **** 
 899:../drivers/fsl_clock.h **** /*!
 900:../drivers/fsl_clock.h ****  * @brief Calculates the PLL divider setting for a desired output frequency.
 901:../drivers/fsl_clock.h ****  *
 902:../drivers/fsl_clock.h ****  * This function calculates the correct reference clock divider (\c PRDIV) and
 903:../drivers/fsl_clock.h ****  * VCO divider (\c VDIV) to generate a desired PLL output frequency. It returns the
 904:../drivers/fsl_clock.h ****  * closest frequency match with the corresponding \c PRDIV/VDIV
 905:../drivers/fsl_clock.h ****  * returned from parameters. If a desired frequency is not valid, this function
 906:../drivers/fsl_clock.h ****  * returns 0.
 907:../drivers/fsl_clock.h ****  *
 908:../drivers/fsl_clock.h ****  * @param refFreq    PLL reference clock frequency.
 909:../drivers/fsl_clock.h ****  * @param desireFreq Desired PLL output frequency.
 910:../drivers/fsl_clock.h ****  * @param prdiv      PRDIV value to generate desired PLL frequency.
 911:../drivers/fsl_clock.h ****  * @param vdiv       VDIV value to generate desired PLL frequency.
 912:../drivers/fsl_clock.h ****  * @return Closest frequency match that the PLL was able generate.
 913:../drivers/fsl_clock.h ****  */
 914:../drivers/fsl_clock.h **** uint32_t CLOCK_CalcPllDiv(uint32_t refFreq, uint32_t desireFreq, uint8_t *prdiv, uint8_t *vdiv);
 915:../drivers/fsl_clock.h **** 
 916:../drivers/fsl_clock.h **** /*@}*/
 917:../drivers/fsl_clock.h **** 
 918:../drivers/fsl_clock.h **** /*! @name MCG clock lock monitor functions. */
 919:../drivers/fsl_clock.h **** /*@{*/
 920:../drivers/fsl_clock.h **** 
 921:../drivers/fsl_clock.h **** /*!
 922:../drivers/fsl_clock.h ****  * @brief Sets the OSC0 clock monitor mode.
 923:../drivers/fsl_clock.h ****  *
 924:../drivers/fsl_clock.h ****  * This function sets the OSC0 clock monitor mode. See @ref mcg_monitor_mode_t for details.
 925:../drivers/fsl_clock.h ****  *
 926:../drivers/fsl_clock.h ****  * @param mode Monitor mode to set.
 927:../drivers/fsl_clock.h ****  */
 928:../drivers/fsl_clock.h **** void CLOCK_SetOsc0MonitorMode(mcg_monitor_mode_t mode);
 929:../drivers/fsl_clock.h **** 
 930:../drivers/fsl_clock.h **** /*!
 931:../drivers/fsl_clock.h ****  * @brief Sets the PLL0 clock monitor mode.
 932:../drivers/fsl_clock.h ****  *
 933:../drivers/fsl_clock.h ****  * This function sets the PLL0 clock monitor mode. See @ref mcg_monitor_mode_t for details.
 934:../drivers/fsl_clock.h ****  *
 935:../drivers/fsl_clock.h ****  * @param mode Monitor mode to set.
 936:../drivers/fsl_clock.h ****  */
 937:../drivers/fsl_clock.h **** void CLOCK_SetPll0MonitorMode(mcg_monitor_mode_t mode);
 938:../drivers/fsl_clock.h **** 
 939:../drivers/fsl_clock.h **** /*!
 940:../drivers/fsl_clock.h ****  * @brief Gets the MCG status flags.
 941:../drivers/fsl_clock.h ****  *
 942:../drivers/fsl_clock.h ****  * This function gets the MCG clock status flags. All status flags are
 943:../drivers/fsl_clock.h ****  * returned as a logical OR of the enumeration @ref _mcg_status_flags_t. To
 944:../drivers/fsl_clock.h ****  * check a specific flag, compare the return value with the flag.
 945:../drivers/fsl_clock.h ****  *
 946:../drivers/fsl_clock.h ****  * Example:
 947:../drivers/fsl_clock.h ****  * @code
 948:../drivers/fsl_clock.h ****    // To check the clock lost lock status of OSC0 and PLL0.
 949:../drivers/fsl_clock.h ****    uint32_t mcgFlags;
 950:../drivers/fsl_clock.h **** 
 951:../drivers/fsl_clock.h ****    mcgFlags = CLOCK_GetStatusFlags();
 952:../drivers/fsl_clock.h **** 
 953:../drivers/fsl_clock.h ****    if (mcgFlags & kMCG_Osc0LostFlag)
 954:../drivers/fsl_clock.h ****    {
 955:../drivers/fsl_clock.h ****        // OSC0 clock lock lost. Do something.
 956:../drivers/fsl_clock.h ****    }
 957:../drivers/fsl_clock.h ****    if (mcgFlags & kMCG_Pll0LostFlag)
 958:../drivers/fsl_clock.h ****    {
 959:../drivers/fsl_clock.h ****        // PLL0 clock lock lost. Do something.
 960:../drivers/fsl_clock.h ****    }
 961:../drivers/fsl_clock.h ****    @endcode
 962:../drivers/fsl_clock.h ****  *
 963:../drivers/fsl_clock.h ****  * @return  Logical OR value of the @ref _mcg_status_flags_t.
 964:../drivers/fsl_clock.h ****  */
 965:../drivers/fsl_clock.h **** uint32_t CLOCK_GetStatusFlags(void);
 966:../drivers/fsl_clock.h **** 
 967:../drivers/fsl_clock.h **** /*!
 968:../drivers/fsl_clock.h ****  * @brief Clears the MCG status flags.
 969:../drivers/fsl_clock.h ****  *
 970:../drivers/fsl_clock.h ****  * This function clears the MCG clock lock lost status. The parameter is a logical
 971:../drivers/fsl_clock.h ****  * OR value of the flags to clear. See @ref _mcg_status_flags_t.
 972:../drivers/fsl_clock.h ****  *
 973:../drivers/fsl_clock.h ****  * Example:
 974:../drivers/fsl_clock.h ****  * @code
 975:../drivers/fsl_clock.h ****    // To clear the clock lost lock status flags of OSC0 and PLL0.
 976:../drivers/fsl_clock.h **** 
 977:../drivers/fsl_clock.h ****    CLOCK_ClearStatusFlags(kMCG_Osc0LostFlag | kMCG_Pll0LostFlag);
 978:../drivers/fsl_clock.h ****    @endcode
 979:../drivers/fsl_clock.h ****  *
 980:../drivers/fsl_clock.h ****  * @param mask The status flags to clear. This is a logical OR of members of the
 981:../drivers/fsl_clock.h ****  *             enumeration @ref _mcg_status_flags_t.
 982:../drivers/fsl_clock.h ****  */
 983:../drivers/fsl_clock.h **** void CLOCK_ClearStatusFlags(uint32_t mask);
 984:../drivers/fsl_clock.h **** 
 985:../drivers/fsl_clock.h **** /*@}*/
 986:../drivers/fsl_clock.h **** 
 987:../drivers/fsl_clock.h **** /*!
 988:../drivers/fsl_clock.h ****  * @name OSC configuration
 989:../drivers/fsl_clock.h ****  * @{
 990:../drivers/fsl_clock.h ****  */
 991:../drivers/fsl_clock.h **** 
 992:../drivers/fsl_clock.h **** /*!
 993:../drivers/fsl_clock.h ****  * @brief Configures the OSC external reference clock (OSCERCLK).
 994:../drivers/fsl_clock.h ****  *
 995:../drivers/fsl_clock.h ****  * This function configures the OSC external reference clock (OSCERCLK).
 996:../drivers/fsl_clock.h ****  * This is an example to enable the OSCERCLK in normal and stop modes and also set
 997:../drivers/fsl_clock.h ****  * the output divider to 1:
 998:../drivers/fsl_clock.h ****  *
 999:../drivers/fsl_clock.h ****    @code
1000:../drivers/fsl_clock.h ****    oscer_config_t config =
1001:../drivers/fsl_clock.h ****    {
1002:../drivers/fsl_clock.h ****        .enableMode = kOSC_ErClkEnable | kOSC_ErClkEnableInStop,
1003:../drivers/fsl_clock.h ****        .erclkDiv   = 1U,
1004:../drivers/fsl_clock.h ****    };
1005:../drivers/fsl_clock.h **** 
1006:../drivers/fsl_clock.h ****    OSC_SetExtRefClkConfig(OSC, &config);
1007:../drivers/fsl_clock.h ****    @endcode
1008:../drivers/fsl_clock.h ****  *
1009:../drivers/fsl_clock.h ****  * @param base   OSC peripheral address.
1010:../drivers/fsl_clock.h ****  * @param config Pointer to the configuration structure.
1011:../drivers/fsl_clock.h ****  */
1012:../drivers/fsl_clock.h **** static inline void OSC_SetExtRefClkConfig(OSC_Type *base, oscer_config_t const *config)
1013:../drivers/fsl_clock.h **** {
 255              		.loc 1 1013 1
 256              		.cfi_startproc
 257              		@ args = 0, pretend = 0, frame = 16
 258              		@ frame_needed = 1, uses_anonymous_args = 0
 259 0000 80B5     		push	{r7, lr}
 260              		.cfi_def_cfa_offset 8
 261              		.cfi_offset 7, -8
 262              		.cfi_offset 14, -4
 263 0002 84B0     		sub	sp, sp, #16
 264              		.cfi_def_cfa_offset 24
 265 0004 00AF     		add	r7, sp, #0
 266              		.cfi_def_cfa_register 7
 267 0006 7860     		str	r0, [r7, #4]
 268 0008 3960     		str	r1, [r7]
1014:../drivers/fsl_clock.h ****     uint8_t reg = base->CR;
 269              		.loc 1 1014 13
 270 000a 0F20     		movs	r0, #15
 271 000c 3B18     		adds	r3, r7, r0
 272 000e 7A68     		ldr	r2, [r7, #4]
 273 0010 1278     		ldrb	r2, [r2]
 274 0012 1A70     		strb	r2, [r3]
1015:../drivers/fsl_clock.h **** 
1016:../drivers/fsl_clock.h ****     reg &= ~(OSC_CR_ERCLKEN_MASK | OSC_CR_EREFSTEN_MASK);
 275              		.loc 1 1016 9
 276 0014 3B18     		adds	r3, r7, r0
 277 0016 3A18     		adds	r2, r7, r0
 278 0018 1278     		ldrb	r2, [r2]
 279 001a 5F21     		movs	r1, #95
 280 001c 0A40     		ands	r2, r1
 281 001e 1A70     		strb	r2, [r3]
1017:../drivers/fsl_clock.h ****     reg |= config->enableMode;
 282              		.loc 1 1017 18
 283 0020 3B68     		ldr	r3, [r7]
 284 0022 1978     		ldrb	r1, [r3]
 285              		.loc 1 1017 9
 286 0024 3B18     		adds	r3, r7, r0
 287 0026 3A18     		adds	r2, r7, r0
 288 0028 1278     		ldrb	r2, [r2]
 289 002a 0A43     		orrs	r2, r1
 290 002c 1A70     		strb	r2, [r3]
1018:../drivers/fsl_clock.h **** 
1019:../drivers/fsl_clock.h ****     base->CR = reg;
 291              		.loc 1 1019 14
 292 002e 7B68     		ldr	r3, [r7, #4]
 293 0030 3A18     		adds	r2, r7, r0
 294 0032 1278     		ldrb	r2, [r2]
 295 0034 1A70     		strb	r2, [r3]
1020:../drivers/fsl_clock.h **** }
 296              		.loc 1 1020 1
 297 0036 C046     		nop
 298 0038 BD46     		mov	sp, r7
 299 003a 04B0     		add	sp, sp, #16
 300              		@ sp needed
 301 003c 80BD     		pop	{r7, pc}
 302              		.cfi_endproc
 303              	.LFE52:
 305              		.section	.text.OSC_SetCapLoad,"ax",%progbits
 306              		.align	1
 307              		.syntax unified
 308              		.code	16
 309              		.thumb_func
 310              		.fpu softvfp
 312              	OSC_SetCapLoad:
 313              	.LFB53:
1021:../drivers/fsl_clock.h **** 
1022:../drivers/fsl_clock.h **** /*!
1023:../drivers/fsl_clock.h ****  * @brief Sets the capacitor load configuration for the oscillator.
1024:../drivers/fsl_clock.h ****  *
1025:../drivers/fsl_clock.h ****  * This function sets the specified capacitors configuration for the oscillator.
1026:../drivers/fsl_clock.h ****  * This should be done in the early system level initialization function call
1027:../drivers/fsl_clock.h ****  * based on the system configuration.
1028:../drivers/fsl_clock.h ****  *
1029:../drivers/fsl_clock.h ****  * @param base   OSC peripheral address.
1030:../drivers/fsl_clock.h ****  * @param capLoad OR'ed value for the capacitor load option, see \ref _osc_cap_load.
1031:../drivers/fsl_clock.h ****  *
1032:../drivers/fsl_clock.h ****  * Example:
1033:../drivers/fsl_clock.h ****    @code
1034:../drivers/fsl_clock.h ****    // To enable only 2 pF and 8 pF capacitor load, please use like this.
1035:../drivers/fsl_clock.h ****    OSC_SetCapLoad(OSC, kOSC_Cap2P | kOSC_Cap8P);
1036:../drivers/fsl_clock.h ****    @endcode
1037:../drivers/fsl_clock.h ****  */
1038:../drivers/fsl_clock.h **** static inline void OSC_SetCapLoad(OSC_Type *base, uint8_t capLoad)
1039:../drivers/fsl_clock.h **** {
 314              		.loc 1 1039 1
 315              		.cfi_startproc
 316              		@ args = 0, pretend = 0, frame = 16
 317              		@ frame_needed = 1, uses_anonymous_args = 0
 318 0000 80B5     		push	{r7, lr}
 319              		.cfi_def_cfa_offset 8
 320              		.cfi_offset 7, -8
 321              		.cfi_offset 14, -4
 322 0002 84B0     		sub	sp, sp, #16
 323              		.cfi_def_cfa_offset 24
 324 0004 00AF     		add	r7, sp, #0
 325              		.cfi_def_cfa_register 7
 326 0006 7860     		str	r0, [r7, #4]
 327 0008 0A00     		movs	r2, r1
 328 000a FB1C     		adds	r3, r7, #3
 329 000c 1A70     		strb	r2, [r3]
1040:../drivers/fsl_clock.h ****     uint8_t reg = base->CR;
 330              		.loc 1 1040 13
 331 000e 0F20     		movs	r0, #15
 332 0010 3B18     		adds	r3, r7, r0
 333 0012 7A68     		ldr	r2, [r7, #4]
 334 0014 1278     		ldrb	r2, [r2]
 335 0016 1A70     		strb	r2, [r3]
1041:../drivers/fsl_clock.h **** 
1042:../drivers/fsl_clock.h ****     reg &= ~(OSC_CR_SC2P_MASK | OSC_CR_SC4P_MASK | OSC_CR_SC8P_MASK | OSC_CR_SC16P_MASK);
 336              		.loc 1 1042 9
 337 0018 3B18     		adds	r3, r7, r0
 338 001a 3A18     		adds	r2, r7, r0
 339 001c 1278     		ldrb	r2, [r2]
 340 001e 0F21     		movs	r1, #15
 341 0020 8A43     		bics	r2, r1
 342 0022 1A70     		strb	r2, [r3]
1043:../drivers/fsl_clock.h ****     reg |= capLoad;
 343              		.loc 1 1043 9
 344 0024 3B18     		adds	r3, r7, r0
 345 0026 3918     		adds	r1, r7, r0
 346 0028 FA1C     		adds	r2, r7, #3
 347 002a 0978     		ldrb	r1, [r1]
 348 002c 1278     		ldrb	r2, [r2]
 349 002e 0A43     		orrs	r2, r1
 350 0030 1A70     		strb	r2, [r3]
1044:../drivers/fsl_clock.h **** 
1045:../drivers/fsl_clock.h ****     base->CR = reg;
 351              		.loc 1 1045 14
 352 0032 7B68     		ldr	r3, [r7, #4]
 353 0034 3A18     		adds	r2, r7, r0
 354 0036 1278     		ldrb	r2, [r2]
 355 0038 1A70     		strb	r2, [r3]
1046:../drivers/fsl_clock.h **** }
 356              		.loc 1 1046 1
 357 003a C046     		nop
 358 003c BD46     		mov	sp, r7
 359 003e 04B0     		add	sp, sp, #16
 360              		@ sp needed
 361 0040 80BD     		pop	{r7, pc}
 362              		.cfi_endproc
 363              	.LFE53:
 365              		.section	.data.s_slowIrcFreq,"aw"
 366              		.align	2
 369              	s_slowIrcFreq:
 370 0000 00800000 		.word	32768
 371              		.section	.data.s_fastIrcFreq,"aw"
 372              		.align	2
 375              	s_fastIrcFreq:
 376 0000 00093D00 		.word	4000000
 377              		.global	g_xtal0Freq
 378              		.section	.bss.g_xtal0Freq,"aw",%nobits
 379              		.align	2
 382              	g_xtal0Freq:
 383 0000 00000000 		.space	4
 384              		.global	g_xtal32Freq
 385              		.section	.bss.g_xtal32Freq,"aw",%nobits
 386              		.align	2
 389              	g_xtal32Freq:
 390 0000 00000000 		.space	4
 391              		.section	.text.CLOCK_FllStableDelay,"ax",%progbits
 392              		.align	1
 393              		.global	CLOCK_FllStableDelay
 394              		.syntax unified
 395              		.code	16
 396              		.thumb_func
 397              		.fpu softvfp
 399              	CLOCK_FllStableDelay:
 400              	.LFB56:
 401              		.file 2 "../drivers/fsl_clock.c"
   1:../drivers/fsl_clock.c **** /*
   2:../drivers/fsl_clock.c ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   3:../drivers/fsl_clock.c ****  * Copyright (c) 2016 - 2017 , NXP
   4:../drivers/fsl_clock.c ****  * All rights reserved.
   5:../drivers/fsl_clock.c ****  *
   6:../drivers/fsl_clock.c ****  * Redistribution and use in source and binary forms, with or without modification,
   7:../drivers/fsl_clock.c ****  * are permitted provided that the following conditions are met:
   8:../drivers/fsl_clock.c ****  *
   9:../drivers/fsl_clock.c ****  * o Redistributions of source code must retain the above copyright notice, this list
  10:../drivers/fsl_clock.c ****  *   of conditions and the following disclaimer.
  11:../drivers/fsl_clock.c ****  *
  12:../drivers/fsl_clock.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  13:../drivers/fsl_clock.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  14:../drivers/fsl_clock.c ****  *   other materials provided with the distribution.
  15:../drivers/fsl_clock.c ****  *
  16:../drivers/fsl_clock.c ****  * o Neither the name of copyright holder nor the names of its
  17:../drivers/fsl_clock.c ****  *   contributors may be used to endorse or promote products derived from this
  18:../drivers/fsl_clock.c ****  *   software without specific prior written permission.
  19:../drivers/fsl_clock.c ****  *
  20:../drivers/fsl_clock.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  21:../drivers/fsl_clock.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  22:../drivers/fsl_clock.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  23:../drivers/fsl_clock.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  24:../drivers/fsl_clock.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  25:../drivers/fsl_clock.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  26:../drivers/fsl_clock.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  27:../drivers/fsl_clock.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  28:../drivers/fsl_clock.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  29:../drivers/fsl_clock.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  30:../drivers/fsl_clock.c ****  */
  31:../drivers/fsl_clock.c **** 
  32:../drivers/fsl_clock.c **** #include "fsl_clock.h"
  33:../drivers/fsl_clock.c **** 
  34:../drivers/fsl_clock.c **** /*******************************************************************************
  35:../drivers/fsl_clock.c ****  * Definitions
  36:../drivers/fsl_clock.c ****  ******************************************************************************/
  37:../drivers/fsl_clock.c **** 
  38:../drivers/fsl_clock.c **** /* Macro definition remap workaround. */
  39:../drivers/fsl_clock.c **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
  40:../drivers/fsl_clock.c **** #define MCG_C2_EREFS0_MASK MCG_C2_EREFS_MASK
  41:../drivers/fsl_clock.c **** #endif
  42:../drivers/fsl_clock.c **** #if (defined(MCG_C2_HGO_MASK) && !(defined(MCG_C2_HGO0_MASK)))
  43:../drivers/fsl_clock.c **** #define MCG_C2_HGO0_MASK MCG_C2_HGO_MASK
  44:../drivers/fsl_clock.c **** #endif
  45:../drivers/fsl_clock.c **** #if (defined(MCG_C2_RANGE_MASK) && !(defined(MCG_C2_RANGE0_MASK)))
  46:../drivers/fsl_clock.c **** #define MCG_C2_RANGE0_MASK MCG_C2_RANGE_MASK
  47:../drivers/fsl_clock.c **** #endif
  48:../drivers/fsl_clock.c **** #if (defined(MCG_C6_CME_MASK) && !(defined(MCG_C6_CME0_MASK)))
  49:../drivers/fsl_clock.c **** #define MCG_C6_CME0_MASK MCG_C6_CME_MASK
  50:../drivers/fsl_clock.c **** #endif
  51:../drivers/fsl_clock.c **** 
  52:../drivers/fsl_clock.c **** /* PLL fixed multiplier when there is not PRDIV and VDIV. */
  53:../drivers/fsl_clock.c **** #define PLL_FIXED_MULT (375U)
  54:../drivers/fsl_clock.c **** /* Max frequency of the reference clock used for internal clock trim. */
  55:../drivers/fsl_clock.c **** #define TRIM_REF_CLK_MIN (8000000U)
  56:../drivers/fsl_clock.c **** /* Min frequency of the reference clock used for internal clock trim. */
  57:../drivers/fsl_clock.c **** #define TRIM_REF_CLK_MAX (16000000U)
  58:../drivers/fsl_clock.c **** /* Max trim value of fast internal reference clock. */
  59:../drivers/fsl_clock.c **** #define TRIM_FIRC_MAX (5000000U)
  60:../drivers/fsl_clock.c **** /* Min trim value of fast internal reference clock. */
  61:../drivers/fsl_clock.c **** #define TRIM_FIRC_MIN (3000000U)
  62:../drivers/fsl_clock.c **** /* Max trim value of fast internal reference clock. */
  63:../drivers/fsl_clock.c **** #define TRIM_SIRC_MAX (39063U)
  64:../drivers/fsl_clock.c **** /* Min trim value of fast internal reference clock. */
  65:../drivers/fsl_clock.c **** #define TRIM_SIRC_MIN (31250U)
  66:../drivers/fsl_clock.c **** 
  67:../drivers/fsl_clock.c **** #define MCG_S_IRCST_VAL ((MCG->S & MCG_S_IRCST_MASK) >> MCG_S_IRCST_SHIFT)
  68:../drivers/fsl_clock.c **** #define MCG_S_CLKST_VAL ((MCG->S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT)
  69:../drivers/fsl_clock.c **** #define MCG_S_IREFST_VAL ((MCG->S & MCG_S_IREFST_MASK) >> MCG_S_IREFST_SHIFT)
  70:../drivers/fsl_clock.c **** #define MCG_S_PLLST_VAL ((MCG->S & MCG_S_PLLST_MASK) >> MCG_S_PLLST_SHIFT)
  71:../drivers/fsl_clock.c **** #define MCG_C1_FRDIV_VAL ((MCG->C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT)
  72:../drivers/fsl_clock.c **** #define MCG_C2_LP_VAL ((MCG->C2 & MCG_C2_LP_MASK) >> MCG_C2_LP_SHIFT)
  73:../drivers/fsl_clock.c **** #define MCG_C2_RANGE_VAL ((MCG->C2 & MCG_C2_RANGE_MASK) >> MCG_C2_RANGE_SHIFT)
  74:../drivers/fsl_clock.c **** #define MCG_SC_FCRDIV_VAL ((MCG->SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)
  75:../drivers/fsl_clock.c **** #define MCG_S2_PLLCST_VAL ((MCG->S2 & MCG_S2_PLLCST_MASK) >> MCG_S2_PLLCST_SHIFT)
  76:../drivers/fsl_clock.c **** #define MCG_C7_OSCSEL_VAL ((MCG->C7 & MCG_C7_OSCSEL_MASK) >> MCG_C7_OSCSEL_SHIFT)
  77:../drivers/fsl_clock.c **** #define MCG_C4_DMX32_VAL ((MCG->C4 & MCG_C4_DMX32_MASK) >> MCG_C4_DMX32_SHIFT)
  78:../drivers/fsl_clock.c **** #define MCG_C4_DRST_DRS_VAL ((MCG->C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT)
  79:../drivers/fsl_clock.c **** #define MCG_C7_PLL32KREFSEL_VAL ((MCG->C7 & MCG_C7_PLL32KREFSEL_MASK) >> MCG_C7_PLL32KREFSEL_SHIFT)
  80:../drivers/fsl_clock.c **** #define MCG_C5_PLLREFSEL0_VAL ((MCG->C5 & MCG_C5_PLLREFSEL0_MASK) >> MCG_C5_PLLREFSEL0_SHIFT)
  81:../drivers/fsl_clock.c **** #define MCG_C11_PLLREFSEL1_VAL ((MCG->C11 & MCG_C11_PLLREFSEL1_MASK) >> MCG_C11_PLLREFSEL1_SHIFT)
  82:../drivers/fsl_clock.c **** #define MCG_C11_PRDIV1_VAL ((MCG->C11 & MCG_C11_PRDIV1_MASK) >> MCG_C11_PRDIV1_SHIFT)
  83:../drivers/fsl_clock.c **** #define MCG_C12_VDIV1_VAL ((MCG->C12 & MCG_C12_VDIV1_MASK) >> MCG_C12_VDIV1_SHIFT)
  84:../drivers/fsl_clock.c **** #define MCG_C5_PRDIV0_VAL ((MCG->C5 & MCG_C5_PRDIV0_MASK) >> MCG_C5_PRDIV0_SHIFT)
  85:../drivers/fsl_clock.c **** #define MCG_C6_VDIV0_VAL ((MCG->C6 & MCG_C6_VDIV0_MASK) >> MCG_C6_VDIV0_SHIFT)
  86:../drivers/fsl_clock.c **** 
  87:../drivers/fsl_clock.c **** #define OSC_MODE_MASK (MCG_C2_EREFS0_MASK | MCG_C2_HGO0_MASK | MCG_C2_RANGE0_MASK)
  88:../drivers/fsl_clock.c **** 
  89:../drivers/fsl_clock.c **** #define SIM_CLKDIV1_OUTDIV1_VAL ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV1_MASK) >> SIM_CLKDIV1_OUTDIV1_S
  90:../drivers/fsl_clock.c **** #define SIM_CLKDIV1_OUTDIV4_VAL ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV4_MASK) >> SIM_CLKDIV1_OUTDIV4_S
  91:../drivers/fsl_clock.c **** #define SIM_SOPT1_OSC32KSEL_VAL ((SIM->SOPT1 & SIM_SOPT1_OSC32KSEL_MASK) >> SIM_SOPT1_OSC32KSEL_SHI
  92:../drivers/fsl_clock.c **** #define SIM_SOPT2_PLLFLLSEL_VAL ((SIM->SOPT2 & SIM_SOPT2_PLLFLLSEL_MASK) >> SIM_SOPT2_PLLFLLSEL_SHI
  93:../drivers/fsl_clock.c **** 
  94:../drivers/fsl_clock.c **** /* MCG_S_CLKST definition. */
  95:../drivers/fsl_clock.c **** enum _mcg_clkout_stat
  96:../drivers/fsl_clock.c **** {
  97:../drivers/fsl_clock.c ****     kMCG_ClkOutStatFll, /* FLL.            */
  98:../drivers/fsl_clock.c ****     kMCG_ClkOutStatInt, /* Internal clock. */
  99:../drivers/fsl_clock.c ****     kMCG_ClkOutStatExt, /* External clock. */
 100:../drivers/fsl_clock.c ****     kMCG_ClkOutStatPll  /* PLL.            */
 101:../drivers/fsl_clock.c **** };
 102:../drivers/fsl_clock.c **** 
 103:../drivers/fsl_clock.c **** /* MCG_S_PLLST definition. */
 104:../drivers/fsl_clock.c **** enum _mcg_pllst
 105:../drivers/fsl_clock.c **** {
 106:../drivers/fsl_clock.c ****     kMCG_PllstFll, /* FLL is used. */
 107:../drivers/fsl_clock.c ****     kMCG_PllstPll  /* PLL is used. */
 108:../drivers/fsl_clock.c **** };
 109:../drivers/fsl_clock.c **** 
 110:../drivers/fsl_clock.c **** /*******************************************************************************
 111:../drivers/fsl_clock.c ****  * Variables
 112:../drivers/fsl_clock.c ****  ******************************************************************************/
 113:../drivers/fsl_clock.c **** 
 114:../drivers/fsl_clock.c **** /* Slow internal reference clock frequency. */
 115:../drivers/fsl_clock.c **** static uint32_t s_slowIrcFreq = 32768U;
 116:../drivers/fsl_clock.c **** /* Fast internal reference clock frequency. */
 117:../drivers/fsl_clock.c **** static uint32_t s_fastIrcFreq = 4000000U;
 118:../drivers/fsl_clock.c **** 
 119:../drivers/fsl_clock.c **** /* External XTAL0 (OSC0) clock frequency. */
 120:../drivers/fsl_clock.c **** uint32_t g_xtal0Freq;
 121:../drivers/fsl_clock.c **** /* External XTAL32K clock frequency. */
 122:../drivers/fsl_clock.c **** uint32_t g_xtal32Freq;
 123:../drivers/fsl_clock.c **** 
 124:../drivers/fsl_clock.c **** /*******************************************************************************
 125:../drivers/fsl_clock.c ****  * Prototypes
 126:../drivers/fsl_clock.c ****  ******************************************************************************/
 127:../drivers/fsl_clock.c **** 
 128:../drivers/fsl_clock.c **** /*!
 129:../drivers/fsl_clock.c ****  * @brief Get the MCG external reference clock frequency.
 130:../drivers/fsl_clock.c ****  *
 131:../drivers/fsl_clock.c ****  * Get the current MCG external reference clock frequency in Hz. It is
 132:../drivers/fsl_clock.c ****  * the frequency select by MCG_C7[OSCSEL]. This is an internal function.
 133:../drivers/fsl_clock.c ****  *
 134:../drivers/fsl_clock.c ****  * @return MCG external reference clock frequency in Hz.
 135:../drivers/fsl_clock.c ****  */
 136:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetMcgExtClkFreq(void);
 137:../drivers/fsl_clock.c **** 
 138:../drivers/fsl_clock.c **** /*!
 139:../drivers/fsl_clock.c ****  * @brief Get the MCG FLL external reference clock frequency.
 140:../drivers/fsl_clock.c ****  *
 141:../drivers/fsl_clock.c ****  * Get the current MCG FLL external reference clock frequency in Hz. It is
 142:../drivers/fsl_clock.c ****  * the frequency after by MCG_C1[FRDIV]. This is an internal function.
 143:../drivers/fsl_clock.c ****  *
 144:../drivers/fsl_clock.c ****  * @return MCG FLL external reference clock frequency in Hz.
 145:../drivers/fsl_clock.c ****  */
 146:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetFllExtRefClkFreq(void);
 147:../drivers/fsl_clock.c **** 
 148:../drivers/fsl_clock.c **** /*!
 149:../drivers/fsl_clock.c ****  * @brief Get the MCG FLL reference clock frequency.
 150:../drivers/fsl_clock.c ****  *
 151:../drivers/fsl_clock.c ****  * Get the current MCG FLL reference clock frequency in Hz. It is
 152:../drivers/fsl_clock.c ****  * the frequency select by MCG_C1[IREFS]. This is an internal function.
 153:../drivers/fsl_clock.c ****  *
 154:../drivers/fsl_clock.c ****  * @return MCG FLL reference clock frequency in Hz.
 155:../drivers/fsl_clock.c ****  */
 156:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetFllRefClkFreq(void);
 157:../drivers/fsl_clock.c **** 
 158:../drivers/fsl_clock.c **** /*!
 159:../drivers/fsl_clock.c ****  * @brief Get the frequency of clock selected by MCG_C2[IRCS].
 160:../drivers/fsl_clock.c ****  *
 161:../drivers/fsl_clock.c ****  * This clock's two output:
 162:../drivers/fsl_clock.c ****  *  1. MCGOUTCLK when MCG_S[CLKST]=0.
 163:../drivers/fsl_clock.c ****  *  2. MCGIRCLK when MCG_C1[IRCLKEN]=1.
 164:../drivers/fsl_clock.c ****  *
 165:../drivers/fsl_clock.c ****  * @return The frequency in Hz.
 166:../drivers/fsl_clock.c ****  */
 167:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetInternalRefClkSelectFreq(void);
 168:../drivers/fsl_clock.c **** 
 169:../drivers/fsl_clock.c **** /*!
 170:../drivers/fsl_clock.c ****  * @brief Get the MCG PLL/PLL0 reference clock frequency.
 171:../drivers/fsl_clock.c ****  *
 172:../drivers/fsl_clock.c ****  * Get the current MCG PLL/PLL0 reference clock frequency in Hz.
 173:../drivers/fsl_clock.c ****  * This is an internal function.
 174:../drivers/fsl_clock.c ****  *
 175:../drivers/fsl_clock.c ****  * @return MCG PLL/PLL0 reference clock frequency in Hz.
 176:../drivers/fsl_clock.c ****  */
 177:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetPll0RefFreq(void);
 178:../drivers/fsl_clock.c **** 
 179:../drivers/fsl_clock.c **** /*!
 180:../drivers/fsl_clock.c ****  * @brief Calculate the RANGE value base on crystal frequency.
 181:../drivers/fsl_clock.c ****  *
 182:../drivers/fsl_clock.c ****  * To setup external crystal oscillator, must set the register bits RANGE
 183:../drivers/fsl_clock.c ****  * base on the crystal frequency. This function returns the RANGE base on the
 184:../drivers/fsl_clock.c ****  * input frequency. This is an internal function.
 185:../drivers/fsl_clock.c ****  *
 186:../drivers/fsl_clock.c ****  * @param freq Crystal frequency in Hz.
 187:../drivers/fsl_clock.c ****  * @return The RANGE value.
 188:../drivers/fsl_clock.c ****  */
 189:../drivers/fsl_clock.c **** static uint8_t CLOCK_GetOscRangeFromFreq(uint32_t freq);
 190:../drivers/fsl_clock.c **** 
 191:../drivers/fsl_clock.c **** /*******************************************************************************
 192:../drivers/fsl_clock.c ****  * Code
 193:../drivers/fsl_clock.c ****  ******************************************************************************/
 194:../drivers/fsl_clock.c **** 
 195:../drivers/fsl_clock.c **** #ifndef MCG_USER_CONFIG_FLL_STABLE_DELAY_EN
 196:../drivers/fsl_clock.c **** /*!
 197:../drivers/fsl_clock.c ****  * @brief Delay function to wait FLL stable.
 198:../drivers/fsl_clock.c ****  *
 199:../drivers/fsl_clock.c ****  * Delay function to wait FLL stable in FEI mode or FEE mode, should wait at least
 200:../drivers/fsl_clock.c ****  * 1ms. Every time changes FLL setting, should wait this time for FLL stable.
 201:../drivers/fsl_clock.c ****  */
 202:../drivers/fsl_clock.c **** void CLOCK_FllStableDelay(void)
 203:../drivers/fsl_clock.c **** {
 402              		.loc 2 203 1
 403              		.cfi_startproc
 404              		@ args = 0, pretend = 0, frame = 8
 405              		@ frame_needed = 1, uses_anonymous_args = 0
 406 0000 80B5     		push	{r7, lr}
 407              		.cfi_def_cfa_offset 8
 408              		.cfi_offset 7, -8
 409              		.cfi_offset 14, -4
 410 0002 82B0     		sub	sp, sp, #8
 411              		.cfi_def_cfa_offset 16
 412 0004 00AF     		add	r7, sp, #0
 413              		.cfi_def_cfa_register 7
 204:../drivers/fsl_clock.c ****     /*
 205:../drivers/fsl_clock.c ****        Should wait at least 1ms. Because in these modes, the core clock is 100MHz
 206:../drivers/fsl_clock.c ****        at most, so this function could obtain the 1ms delay.
 207:../drivers/fsl_clock.c ****      */
 208:../drivers/fsl_clock.c ****     volatile uint32_t i = 30000U;
 414              		.loc 2 208 23
 415 0006 074B     		ldr	r3, .L18
 416 0008 7B60     		str	r3, [r7, #4]
 209:../drivers/fsl_clock.c ****     while (i--)
 417              		.loc 2 209 11
 418 000a 01E0     		b	.L16
 419              	.L17:
 420              	.LBB4:
 421              	.LBB5:
 422              		.file 3 "/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h"
   1:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /**************************************************************************//**
   2:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  * @brief    CMSIS Cortex-M Core Function/Instruction Header File
   4:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  * @version  V4.30
   5:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  * @date     20. October 2015
   6:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  ******************************************************************************/
   7:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /* Copyright (c) 2009 - 2015 ARM LIMITED
   8:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
   9:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****    All rights reserved.
  10:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****    Redistribution and use in source and binary forms, with or without
  11:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****    modification, are permitted provided that the following conditions are met:
  12:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****    - Redistributions of source code must retain the above copyright
  13:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****      notice, this list of conditions and the following disclaimer.
  14:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****    - Redistributions in binary form must reproduce the above copyright
  15:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****      notice, this list of conditions and the following disclaimer in the
  16:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****      documentation and/or other materials provided with the distribution.
  17:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****    - Neither the name of ARM nor the names of its contributors may be used
  18:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****      to endorse or promote products derived from this software without
  19:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****      specific prior written permission.
  20:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****    *
  21:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  25:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****    POSSIBILITY OF SUCH DAMAGE.
  32:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****    ---------------------------------------------------------------------------*/
  33:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
  34:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
  35:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  36:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_H
  37:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
  38:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /* ignore some GCC warnings */
  39:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** #if defined ( __GNUC__ )
  40:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic push
  41:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  42:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  43:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  44:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** #endif
  45:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
  46:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
  47:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
  48:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
  49:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
  50:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   @{
  51:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  */
  52:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
  53:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /**
  54:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
  55:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
  56:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
  57:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  */
  58:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
  59:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** {
  60:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
  61:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** }
  62:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
  63:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
  64:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /**
  65:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
  66:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  67:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   Can only be executed in Privileged modes.
  68:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  */
  69:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
  70:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** {
  71:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
  72:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** }
  73:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
  74:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
  75:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /**
  76:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \brief   Get Control Register
  77:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \details Returns the content of the Control Register.
  78:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \return               Control Register value
  79:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  */
  80:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
  81:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** {
  82:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   uint32_t result;
  83:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
  84:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
  85:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   return(result);
  86:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** }
  87:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
  88:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
  89:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /**
  90:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \brief   Set Control Register
  91:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
  92:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
  93:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  */
  94:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
  95:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** {
  96:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
  97:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** }
  98:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
  99:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 100:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /**
 101:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \brief   Get IPSR Register
 102:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 103:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \return               IPSR Register value
 104:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  */
 105:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
 106:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** {
 107:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   uint32_t result;
 108:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 109:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 110:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   return(result);
 111:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** }
 112:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 113:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 114:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /**
 115:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \brief   Get APSR Register
 116:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 117:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \return               APSR Register value
 118:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  */
 119:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
 120:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** {
 121:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   uint32_t result;
 122:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 123:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 124:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   return(result);
 125:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** }
 126:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 127:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 128:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /**
 129:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \brief   Get xPSR Register
 130:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 131:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 132:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****     \return               xPSR Register value
 133:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  */
 134:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
 135:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** {
 136:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   uint32_t result;
 137:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 138:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 139:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   return(result);
 140:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** }
 141:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 142:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 143:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /**
 144:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 145:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 146:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \return               PSP Register value
 147:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  */
 148:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
 149:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** {
 150:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   register uint32_t result;
 151:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 152:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 153:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   return(result);
 154:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** }
 155:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 156:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 157:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /**
 158:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 159:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 160:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 161:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  */
 162:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
 163:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** {
 164:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 165:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** }
 166:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 167:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 168:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /**
 169:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 170:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 171:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \return               MSP Register value
 172:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  */
 173:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
 174:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** {
 175:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   register uint32_t result;
 176:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 177:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
 178:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   return(result);
 179:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** }
 180:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 181:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 182:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /**
 183:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 184:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 185:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 186:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****     \param [in]    topOfMainStack  Main Stack Pointer value to set
 187:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  */
 188:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
 189:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** {
 190:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
 191:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** }
 192:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 193:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 194:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /**
 195:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \brief   Get Priority Mask
 196:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 197:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \return               Priority Mask value
 198:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  */
 199:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
 200:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** {
 201:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   uint32_t result;
 202:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 203:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) );
 204:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   return(result);
 205:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** }
 206:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 207:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 208:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /**
 209:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \brief   Set Priority Mask
 210:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 211:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 212:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  */
 213:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
 214:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** {
 215:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 216:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** }
 217:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 218:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 219:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** #if       (__CORTEX_M >= 0x03U)
 220:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 221:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /**
 222:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \brief   Enable FIQ
 223:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 224:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 225:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  */
 226:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
 227:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** {
 228:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 229:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** }
 230:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 231:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 232:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /**
 233:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \brief   Disable FIQ
 234:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 235:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 236:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  */
 237:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
 238:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** {
 239:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 240:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** }
 241:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 242:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 243:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /**
 244:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \brief   Get Base Priority
 245:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 246:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \return               Base Priority register value
 247:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  */
 248:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
 249:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** {
 250:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   uint32_t result;
 251:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 252:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 253:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   return(result);
 254:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** }
 255:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 256:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 257:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /**
 258:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \brief   Set Base Priority
 259:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 260:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 261:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  */
 262:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
 263:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** {
 264:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 265:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** }
 266:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 267:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 268:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /**
 269:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 270:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 271:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 272:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 273:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  */
 274:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI_MAX(uint32_t value)
 275:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** {
 276:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (value) : "memory");
 277:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** }
 278:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 279:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 280:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /**
 281:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \brief   Get Fault Mask
 282:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 283:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \return               Fault Mask register value
 284:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  */
 285:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
 286:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** {
 287:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   uint32_t result;
 288:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 289:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 290:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   return(result);
 291:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** }
 292:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 293:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 294:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /**
 295:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \brief   Set Fault Mask
 296:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 297:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 298:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  */
 299:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
 300:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** {
 301:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 302:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** }
 303:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 304:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** #endif /* (__CORTEX_M >= 0x03U) */
 305:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 306:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 307:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** #if       (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U)
 308:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 309:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /**
 310:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \brief   Get FPSCR
 311:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 312:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 313:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  */
 314:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
 315:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** {
 316:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** #if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
 317:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   uint32_t result;
 318:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 319:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   /* Empty asm statement works as a scheduling barrier */
 320:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("");
 321:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 322:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("");
 323:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   return(result);
 324:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** #else
 325:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****    return(0);
 326:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** #endif
 327:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** }
 328:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 329:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 330:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /**
 331:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \brief   Set FPSCR
 332:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 333:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 334:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  */
 335:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
 336:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** {
 337:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** #if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
 338:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   /* Empty asm statement works as a scheduling barrier */
 339:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("");
 340:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
 341:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("");
 342:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** #endif
 343:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** }
 344:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 345:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** #endif /* (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U) */
 346:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 347:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 348:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 349:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 350:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 351:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 352:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 353:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 354:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   Access to dedicated instructions
 355:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   @{
 356:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** */
 357:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 358:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 359:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 360:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 361:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 362:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 363:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 364:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** #else
 365:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 366:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 367:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** #endif
 368:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** 
 369:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** /**
 370:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \brief   No Operation
 371:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 372:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****  */
 373:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
 374:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** {
 375:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h ****   __ASM volatile ("nop");
 423              		.loc 3 375 3
 424              		.syntax divided
 425              	@ 375 "/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h" 1
 426 000c C046     		nop
 427              	@ 0 "" 2
 376:/home/arpit/studies/pes/Blinkenlights/CMSIS/cmsis_gcc.h **** }
 428              		.loc 3 376 1
 429              		.thumb
 430              		.syntax unified
 431 000e C046     		nop
 432              	.L16:
 433              	.LBE5:
 434              	.LBE4:
 435              		.loc 2 209 13
 436 0010 7B68     		ldr	r3, [r7, #4]
 437 0012 5A1E     		subs	r2, r3, #1
 438 0014 7A60     		str	r2, [r7, #4]
 439              		.loc 2 209 11
 440 0016 002B     		cmp	r3, #0
 441 0018 F8D1     		bne	.L17
 210:../drivers/fsl_clock.c ****     {
 211:../drivers/fsl_clock.c ****         __NOP();
 212:../drivers/fsl_clock.c ****     }
 213:../drivers/fsl_clock.c **** }
 442              		.loc 2 213 1
 443 001a C046     		nop
 444 001c C046     		nop
 445 001e BD46     		mov	sp, r7
 446 0020 02B0     		add	sp, sp, #8
 447              		@ sp needed
 448 0022 80BD     		pop	{r7, pc}
 449              	.L19:
 450              		.align	2
 451              	.L18:
 452 0024 30750000 		.word	30000
 453              		.cfi_endproc
 454              	.LFE56:
 456              		.section	.rodata.CLOCK_GetMcgExtClkFreq.str1.4,"aMS",%progbits,1
 457              		.align	2
 458              	.LC1:
 459 0000 2E66736C 		.ascii	".fsl_clock.c:225 : g_xtal0Freq\000"
 459      5F636C6F 
 459      636B2E63 
 459      3A323235 
 459      203A2067 
 460              		.section	.text.CLOCK_GetMcgExtClkFreq,"ax",%progbits
 461              		.align	1
 462              		.syntax unified
 463              		.code	16
 464              		.thumb_func
 465              		.fpu softvfp
 467              	CLOCK_GetMcgExtClkFreq:
 468              	.LFB57:
 214:../drivers/fsl_clock.c **** #else  /* With MCG_USER_CONFIG_FLL_STABLE_DELAY_EN defined. */
 215:../drivers/fsl_clock.c **** /* Once user defines the MCG_USER_CONFIG_FLL_STABLE_DELAY_EN to use their own delay function, he ha
 216:../drivers/fsl_clock.c ****  * create his own CLOCK_FllStableDelay() function in application code. Since the clock functions in
 217:../drivers/fsl_clock.c ****  * file would call the CLOCK_FllStableDelay() regardness how it is defined.
 218:../drivers/fsl_clock.c ****  */
 219:../drivers/fsl_clock.c **** extern void CLOCK_FllStableDelay(void);
 220:../drivers/fsl_clock.c **** #endif /* MCG_USER_CONFIG_FLL_STABLE_DELAY_EN */
 221:../drivers/fsl_clock.c **** 
 222:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetMcgExtClkFreq(void)
 223:../drivers/fsl_clock.c **** {
 469              		.loc 2 223 1
 470              		.cfi_startproc
 471              		@ args = 0, pretend = 0, frame = 0
 472              		@ frame_needed = 1, uses_anonymous_args = 0
 473 0000 80B5     		push	{r7, lr}
 474              		.cfi_def_cfa_offset 8
 475              		.cfi_offset 7, -8
 476              		.cfi_offset 14, -4
 477 0002 00AF     		add	r7, sp, #0
 478              		.cfi_def_cfa_register 7
 224:../drivers/fsl_clock.c ****     /* Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock. */
 225:../drivers/fsl_clock.c ****     assert(g_xtal0Freq);
 479              		.loc 2 225 5
 480 0004 064B     		ldr	r3, .L23
 481 0006 1B68     		ldr	r3, [r3]
 482 0008 002B     		cmp	r3, #0
 483 000a 03D1     		bne	.L21
 484              		.loc 2 225 5 is_stmt 0 discriminator 1
 485 000c 054B     		ldr	r3, .L23+4
 486 000e 1800     		movs	r0, r3
 487 0010 FFF7FEFF 		bl	__assertion_failed
 488              	.L21:
 226:../drivers/fsl_clock.c ****     return g_xtal0Freq;
 489              		.loc 2 226 12 is_stmt 1
 490 0014 024B     		ldr	r3, .L23
 491 0016 1B68     		ldr	r3, [r3]
 227:../drivers/fsl_clock.c **** }
 492              		.loc 2 227 1
 493 0018 1800     		movs	r0, r3
 494 001a BD46     		mov	sp, r7
 495              		@ sp needed
 496 001c 80BD     		pop	{r7, pc}
 497              	.L24:
 498 001e C046     		.align	2
 499              	.L23:
 500 0020 00000000 		.word	g_xtal0Freq
 501 0024 00000000 		.word	.LC1
 502              		.cfi_endproc
 503              	.LFE57:
 505              		.global	__aeabi_uidiv
 506              		.section	.text.CLOCK_GetFllExtRefClkFreq,"ax",%progbits
 507              		.align	1
 508              		.syntax unified
 509              		.code	16
 510              		.thumb_func
 511              		.fpu softvfp
 513              	CLOCK_GetFllExtRefClkFreq:
 514              	.LFB58:
 228:../drivers/fsl_clock.c **** 
 229:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetFllExtRefClkFreq(void)
 230:../drivers/fsl_clock.c **** {
 515              		.loc 2 230 1
 516              		.cfi_startproc
 517              		@ args = 0, pretend = 0, frame = 8
 518              		@ frame_needed = 1, uses_anonymous_args = 0
 519 0000 80B5     		push	{r7, lr}
 520              		.cfi_def_cfa_offset 8
 521              		.cfi_offset 7, -8
 522              		.cfi_offset 14, -4
 523 0002 82B0     		sub	sp, sp, #8
 524              		.cfi_def_cfa_offset 16
 525 0004 00AF     		add	r7, sp, #0
 526              		.cfi_def_cfa_register 7
 231:../drivers/fsl_clock.c ****     /* FllExtRef = McgExtRef / FllExtRefDiv */
 232:../drivers/fsl_clock.c ****     uint8_t frdiv;
 233:../drivers/fsl_clock.c ****     uint8_t range;
 234:../drivers/fsl_clock.c **** 
 235:../drivers/fsl_clock.c ****     uint32_t freq = CLOCK_GetMcgExtClkFreq();
 527              		.loc 2 235 21
 528 0006 FFF7FEFF 		bl	CLOCK_GetMcgExtClkFreq
 529 000a 0300     		movs	r3, r0
 530 000c 7B60     		str	r3, [r7, #4]
 236:../drivers/fsl_clock.c **** 
 237:../drivers/fsl_clock.c ****     if (!freq)
 531              		.loc 2 237 8
 532 000e 7B68     		ldr	r3, [r7, #4]
 533 0010 002B     		cmp	r3, #0
 534 0012 01D1     		bne	.L26
 238:../drivers/fsl_clock.c ****     {
 239:../drivers/fsl_clock.c ****         return freq;
 535              		.loc 2 239 16
 536 0014 7B68     		ldr	r3, [r7, #4]
 537 0016 41E0     		b	.L27
 538              	.L26:
 240:../drivers/fsl_clock.c ****     }
 241:../drivers/fsl_clock.c **** 
 242:../drivers/fsl_clock.c ****     frdiv = MCG_C1_FRDIV_VAL;
 539              		.loc 2 242 13
 540 0018 224B     		ldr	r3, .L35
 541 001a 1B78     		ldrb	r3, [r3]
 542 001c DBB2     		uxtb	r3, r3
 543 001e DB08     		lsrs	r3, r3, #3
 544 0020 DAB2     		uxtb	r2, r3
 545              		.loc 2 242 11
 546 0022 FB1C     		adds	r3, r7, #3
 547 0024 0721     		movs	r1, #7
 548 0026 0A40     		ands	r2, r1
 549 0028 1A70     		strb	r2, [r3]
 243:../drivers/fsl_clock.c ****     freq >>= frdiv;
 550              		.loc 2 243 10
 551 002a FB1C     		adds	r3, r7, #3
 552 002c 1B78     		ldrb	r3, [r3]
 553 002e 7A68     		ldr	r2, [r7, #4]
 554 0030 DA40     		lsrs	r2, r2, r3
 555 0032 1300     		movs	r3, r2
 556 0034 7B60     		str	r3, [r7, #4]
 244:../drivers/fsl_clock.c **** 
 245:../drivers/fsl_clock.c ****     range = MCG_C2_RANGE_VAL;
 557              		.loc 2 245 13
 558 0036 1B4B     		ldr	r3, .L35
 559 0038 5B78     		ldrb	r3, [r3, #1]
 560 003a DBB2     		uxtb	r3, r3
 561 003c 1B09     		lsrs	r3, r3, #4
 562 003e DAB2     		uxtb	r2, r3
 563              		.loc 2 245 11
 564 0040 BB1C     		adds	r3, r7, #2
 565 0042 0321     		movs	r1, #3
 566 0044 0A40     		ands	r2, r1
 567 0046 1A70     		strb	r2, [r3]
 246:../drivers/fsl_clock.c **** 
 247:../drivers/fsl_clock.c ****     /*
 248:../drivers/fsl_clock.c ****        When should use divider 32, 64, 128, 256, 512, 1024, 1280, 1536.
 249:../drivers/fsl_clock.c ****        1. MCG_C7[OSCSEL] selects IRC48M.
 250:../drivers/fsl_clock.c ****        2. MCG_C7[OSCSEL] selects OSC0 and MCG_C2[RANGE] is not 0.
 251:../drivers/fsl_clock.c ****     */
 252:../drivers/fsl_clock.c ****     if (((0U != range)))
 568              		.loc 2 252 8
 569 0048 BB1C     		adds	r3, r7, #2
 570 004a 1B78     		ldrb	r3, [r3]
 571 004c 002B     		cmp	r3, #0
 572 004e 23D0     		beq	.L34
 253:../drivers/fsl_clock.c ****     {
 254:../drivers/fsl_clock.c ****         switch (frdiv)
 573              		.loc 2 254 9
 574 0050 FB1C     		adds	r3, r7, #3
 575 0052 1B78     		ldrb	r3, [r3]
 576 0054 072B     		cmp	r3, #7
 577 0056 14D0     		beq	.L29
 578 0058 1BDC     		bgt	.L30
 579 005a 052B     		cmp	r3, #5
 580 005c 02DC     		bgt	.L31
 581 005e 002B     		cmp	r3, #0
 582 0060 03DA     		bge	.L32
 583 0062 16E0     		b	.L30
 584              	.L31:
 585 0064 062B     		cmp	r3, #6
 586 0066 04D0     		beq	.L33
 587 0068 13E0     		b	.L30
 588              	.L32:
 255:../drivers/fsl_clock.c ****         {
 256:../drivers/fsl_clock.c ****             case 0:
 257:../drivers/fsl_clock.c ****             case 1:
 258:../drivers/fsl_clock.c ****             case 2:
 259:../drivers/fsl_clock.c ****             case 3:
 260:../drivers/fsl_clock.c ****             case 4:
 261:../drivers/fsl_clock.c ****             case 5:
 262:../drivers/fsl_clock.c ****                 freq >>= 5u;
 589              		.loc 2 262 22
 590 006a 7B68     		ldr	r3, [r7, #4]
 591 006c 5B09     		lsrs	r3, r3, #5
 592 006e 7B60     		str	r3, [r7, #4]
 263:../drivers/fsl_clock.c ****                 break;
 593              		.loc 2 263 17
 594 0070 13E0     		b	.L28
 595              	.L33:
 264:../drivers/fsl_clock.c ****             case 6:
 265:../drivers/fsl_clock.c ****                 /* 64*20=1280 */
 266:../drivers/fsl_clock.c ****                 freq /= 20u;
 596              		.loc 2 266 22
 597 0072 7B68     		ldr	r3, [r7, #4]
 598 0074 1421     		movs	r1, #20
 599 0076 1800     		movs	r0, r3
 600 0078 FFF7FEFF 		bl	__aeabi_uidiv
 601              	.LVL0:
 602 007c 0300     		movs	r3, r0
 603 007e 7B60     		str	r3, [r7, #4]
 267:../drivers/fsl_clock.c ****                 break;
 604              		.loc 2 267 17
 605 0080 0BE0     		b	.L28
 606              	.L29:
 268:../drivers/fsl_clock.c ****             case 7:
 269:../drivers/fsl_clock.c ****                 /* 128*12=1536 */
 270:../drivers/fsl_clock.c ****                 freq /= 12u;
 607              		.loc 2 270 22
 608 0082 7B68     		ldr	r3, [r7, #4]
 609 0084 0C21     		movs	r1, #12
 610 0086 1800     		movs	r0, r3
 611 0088 FFF7FEFF 		bl	__aeabi_uidiv
 612              	.LVL1:
 613 008c 0300     		movs	r3, r0
 614 008e 7B60     		str	r3, [r7, #4]
 271:../drivers/fsl_clock.c ****                 break;
 615              		.loc 2 271 17
 616 0090 03E0     		b	.L28
 617              	.L30:
 272:../drivers/fsl_clock.c ****             default:
 273:../drivers/fsl_clock.c ****                 freq = 0u;
 618              		.loc 2 273 22
 619 0092 0023     		movs	r3, #0
 620 0094 7B60     		str	r3, [r7, #4]
 274:../drivers/fsl_clock.c ****                 break;
 621              		.loc 2 274 17
 622 0096 00E0     		b	.L28
 623              	.L34:
 275:../drivers/fsl_clock.c ****         }
 276:../drivers/fsl_clock.c ****     }
 624              		.loc 2 276 5
 625 0098 C046     		nop
 626              	.L28:
 277:../drivers/fsl_clock.c **** 
 278:../drivers/fsl_clock.c ****     return freq;
 627              		.loc 2 278 12
 628 009a 7B68     		ldr	r3, [r7, #4]
 629              	.L27:
 279:../drivers/fsl_clock.c **** }
 630              		.loc 2 279 1
 631 009c 1800     		movs	r0, r3
 632 009e BD46     		mov	sp, r7
 633 00a0 02B0     		add	sp, sp, #8
 634              		@ sp needed
 635 00a2 80BD     		pop	{r7, pc}
 636              	.L36:
 637              		.align	2
 638              	.L35:
 639 00a4 00400640 		.word	1074151424
 640              		.cfi_endproc
 641              	.LFE58:
 643              		.section	.text.CLOCK_GetInternalRefClkSelectFreq,"ax",%progbits
 644              		.align	1
 645              		.syntax unified
 646              		.code	16
 647              		.thumb_func
 648              		.fpu softvfp
 650              	CLOCK_GetInternalRefClkSelectFreq:
 651              	.LFB59:
 280:../drivers/fsl_clock.c **** 
 281:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetInternalRefClkSelectFreq(void)
 282:../drivers/fsl_clock.c **** {
 652              		.loc 2 282 1
 653              		.cfi_startproc
 654              		@ args = 0, pretend = 0, frame = 0
 655              		@ frame_needed = 1, uses_anonymous_args = 0
 656 0000 80B5     		push	{r7, lr}
 657              		.cfi_def_cfa_offset 8
 658              		.cfi_offset 7, -8
 659              		.cfi_offset 14, -4
 660 0002 00AF     		add	r7, sp, #0
 661              		.cfi_def_cfa_register 7
 283:../drivers/fsl_clock.c ****     if (kMCG_IrcSlow == MCG_S_IRCST_VAL)
 662              		.loc 2 283 25
 663 0004 0B4B     		ldr	r3, .L40
 664 0006 9B79     		ldrb	r3, [r3, #6]
 665 0008 DBB2     		uxtb	r3, r3
 666 000a 1A00     		movs	r2, r3
 667 000c 0123     		movs	r3, #1
 668 000e 1340     		ands	r3, r2
 669              		.loc 2 283 8
 670 0010 02D1     		bne	.L38
 284:../drivers/fsl_clock.c ****     {
 285:../drivers/fsl_clock.c ****         /* Slow internal reference clock selected*/
 286:../drivers/fsl_clock.c ****         return s_slowIrcFreq;
 671              		.loc 2 286 16
 672 0012 094B     		ldr	r3, .L40+4
 673 0014 1B68     		ldr	r3, [r3]
 674 0016 09E0     		b	.L39
 675              	.L38:
 287:../drivers/fsl_clock.c ****     }
 288:../drivers/fsl_clock.c ****     else
 289:../drivers/fsl_clock.c ****     {
 290:../drivers/fsl_clock.c ****         /* Fast internal reference clock selected*/
 291:../drivers/fsl_clock.c ****         return s_fastIrcFreq >> MCG_SC_FCRDIV_VAL;
 676              		.loc 2 291 30
 677 0018 084B     		ldr	r3, .L40+8
 678 001a 1A68     		ldr	r2, [r3]
 679              		.loc 2 291 33
 680 001c 054B     		ldr	r3, .L40
 681 001e 1B7A     		ldrb	r3, [r3, #8]
 682 0020 DBB2     		uxtb	r3, r3
 683 0022 5B08     		lsrs	r3, r3, #1
 684 0024 0721     		movs	r1, #7
 685 0026 0B40     		ands	r3, r1
 686              		.loc 2 291 30
 687 0028 DA40     		lsrs	r2, r2, r3
 688 002a 1300     		movs	r3, r2
 689              	.L39:
 292:../drivers/fsl_clock.c ****     }
 293:../drivers/fsl_clock.c **** }
 690              		.loc 2 293 1
 691 002c 1800     		movs	r0, r3
 692 002e BD46     		mov	sp, r7
 693              		@ sp needed
 694 0030 80BD     		pop	{r7, pc}
 695              	.L41:
 696 0032 C046     		.align	2
 697              	.L40:
 698 0034 00400640 		.word	1074151424
 699 0038 00000000 		.word	s_slowIrcFreq
 700 003c 00000000 		.word	s_fastIrcFreq
 701              		.cfi_endproc
 702              	.LFE59:
 704              		.section	.text.CLOCK_GetFllRefClkFreq,"ax",%progbits
 705              		.align	1
 706              		.syntax unified
 707              		.code	16
 708              		.thumb_func
 709              		.fpu softvfp
 711              	CLOCK_GetFllRefClkFreq:
 712              	.LFB60:
 294:../drivers/fsl_clock.c **** 
 295:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetFllRefClkFreq(void)
 296:../drivers/fsl_clock.c **** {
 713              		.loc 2 296 1
 714              		.cfi_startproc
 715              		@ args = 0, pretend = 0, frame = 0
 716              		@ frame_needed = 1, uses_anonymous_args = 0
 717 0000 80B5     		push	{r7, lr}
 718              		.cfi_def_cfa_offset 8
 719              		.cfi_offset 7, -8
 720              		.cfi_offset 14, -4
 721 0002 00AF     		add	r7, sp, #0
 722              		.cfi_def_cfa_register 7
 297:../drivers/fsl_clock.c ****     /* If use external reference clock. */
 298:../drivers/fsl_clock.c ****     if (kMCG_FllSrcExternal == MCG_S_IREFST_VAL)
 723              		.loc 2 298 32
 724 0004 074B     		ldr	r3, .L45
 725 0006 9B79     		ldrb	r3, [r3, #6]
 726 0008 DBB2     		uxtb	r3, r3
 727              		.loc 2 298 29
 728 000a 1A00     		movs	r2, r3
 729 000c 1023     		movs	r3, #16
 730 000e 1340     		ands	r3, r2
 731              		.loc 2 298 8
 732 0010 03D1     		bne	.L43
 299:../drivers/fsl_clock.c ****     {
 300:../drivers/fsl_clock.c ****         return CLOCK_GetFllExtRefClkFreq();
 733              		.loc 2 300 16
 734 0012 FFF7FEFF 		bl	CLOCK_GetFllExtRefClkFreq
 735 0016 0300     		movs	r3, r0
 736 0018 01E0     		b	.L44
 737              	.L43:
 301:../drivers/fsl_clock.c ****     }
 302:../drivers/fsl_clock.c ****     /* If use internal reference clock. */
 303:../drivers/fsl_clock.c ****     else
 304:../drivers/fsl_clock.c ****     {
 305:../drivers/fsl_clock.c ****         return s_slowIrcFreq;
 738              		.loc 2 305 16
 739 001a 034B     		ldr	r3, .L45+4
 740 001c 1B68     		ldr	r3, [r3]
 741              	.L44:
 306:../drivers/fsl_clock.c ****     }
 307:../drivers/fsl_clock.c **** }
 742              		.loc 2 307 1
 743 001e 1800     		movs	r0, r3
 744 0020 BD46     		mov	sp, r7
 745              		@ sp needed
 746 0022 80BD     		pop	{r7, pc}
 747              	.L46:
 748              		.align	2
 749              	.L45:
 750 0024 00400640 		.word	1074151424
 751 0028 00000000 		.word	s_slowIrcFreq
 752              		.cfi_endproc
 753              	.LFE60:
 755              		.section	.text.CLOCK_GetPll0RefFreq,"ax",%progbits
 756              		.align	1
 757              		.syntax unified
 758              		.code	16
 759              		.thumb_func
 760              		.fpu softvfp
 762              	CLOCK_GetPll0RefFreq:
 763              	.LFB61:
 308:../drivers/fsl_clock.c **** 
 309:../drivers/fsl_clock.c **** static uint32_t CLOCK_GetPll0RefFreq(void)
 310:../drivers/fsl_clock.c **** {
 764              		.loc 2 310 1
 765              		.cfi_startproc
 766              		@ args = 0, pretend = 0, frame = 0
 767              		@ frame_needed = 1, uses_anonymous_args = 0
 768 0000 80B5     		push	{r7, lr}
 769              		.cfi_def_cfa_offset 8
 770              		.cfi_offset 7, -8
 771              		.cfi_offset 14, -4
 772 0002 00AF     		add	r7, sp, #0
 773              		.cfi_def_cfa_register 7
 311:../drivers/fsl_clock.c ****     /* MCG external reference clock. */
 312:../drivers/fsl_clock.c ****     return CLOCK_GetMcgExtClkFreq();
 774              		.loc 2 312 12
 775 0004 FFF7FEFF 		bl	CLOCK_GetMcgExtClkFreq
 776 0008 0300     		movs	r3, r0
 313:../drivers/fsl_clock.c **** }
 777              		.loc 2 313 1
 778 000a 1800     		movs	r0, r3
 779 000c BD46     		mov	sp, r7
 780              		@ sp needed
 781 000e 80BD     		pop	{r7, pc}
 782              		.cfi_endproc
 783              	.LFE61:
 785              		.section	.text.CLOCK_GetOscRangeFromFreq,"ax",%progbits
 786              		.align	1
 787              		.syntax unified
 788              		.code	16
 789              		.thumb_func
 790              		.fpu softvfp
 792              	CLOCK_GetOscRangeFromFreq:
 793              	.LFB62:
 314:../drivers/fsl_clock.c **** 
 315:../drivers/fsl_clock.c **** static uint8_t CLOCK_GetOscRangeFromFreq(uint32_t freq)
 316:../drivers/fsl_clock.c **** {
 794              		.loc 2 316 1
 795              		.cfi_startproc
 796              		@ args = 0, pretend = 0, frame = 16
 797              		@ frame_needed = 1, uses_anonymous_args = 0
 798 0000 80B5     		push	{r7, lr}
 799              		.cfi_def_cfa_offset 8
 800              		.cfi_offset 7, -8
 801              		.cfi_offset 14, -4
 802 0002 84B0     		sub	sp, sp, #16
 803              		.cfi_def_cfa_offset 24
 804 0004 00AF     		add	r7, sp, #0
 805              		.cfi_def_cfa_register 7
 806 0006 7860     		str	r0, [r7, #4]
 317:../drivers/fsl_clock.c ****     uint8_t range;
 318:../drivers/fsl_clock.c **** 
 319:../drivers/fsl_clock.c ****     if (freq <= 39063U)
 807              		.loc 2 319 8
 808 0008 7B68     		ldr	r3, [r7, #4]
 809 000a 0E4A     		ldr	r2, .L54
 810 000c 9342     		cmp	r3, r2
 811 000e 04D8     		bhi	.L50
 320:../drivers/fsl_clock.c ****     {
 321:../drivers/fsl_clock.c ****         range = 0U;
 812              		.loc 2 321 15
 813 0010 0F23     		movs	r3, #15
 814 0012 FB18     		adds	r3, r7, r3
 815 0014 0022     		movs	r2, #0
 816 0016 1A70     		strb	r2, [r3]
 817 0018 0CE0     		b	.L51
 818              	.L50:
 322:../drivers/fsl_clock.c ****     }
 323:../drivers/fsl_clock.c ****     else if (freq <= 8000000U)
 819              		.loc 2 323 13
 820 001a 7B68     		ldr	r3, [r7, #4]
 821 001c 0A4A     		ldr	r2, .L54+4
 822 001e 9342     		cmp	r3, r2
 823 0020 04D8     		bhi	.L52
 324:../drivers/fsl_clock.c ****     {
 325:../drivers/fsl_clock.c ****         range = 1U;
 824              		.loc 2 325 15
 825 0022 0F23     		movs	r3, #15
 826 0024 FB18     		adds	r3, r7, r3
 827 0026 0122     		movs	r2, #1
 828 0028 1A70     		strb	r2, [r3]
 829 002a 03E0     		b	.L51
 830              	.L52:
 326:../drivers/fsl_clock.c ****     }
 327:../drivers/fsl_clock.c ****     else
 328:../drivers/fsl_clock.c ****     {
 329:../drivers/fsl_clock.c ****         range = 2U;
 831              		.loc 2 329 15
 832 002c 0F23     		movs	r3, #15
 833 002e FB18     		adds	r3, r7, r3
 834 0030 0222     		movs	r2, #2
 835 0032 1A70     		strb	r2, [r3]
 836              	.L51:
 330:../drivers/fsl_clock.c ****     }
 331:../drivers/fsl_clock.c **** 
 332:../drivers/fsl_clock.c ****     return range;
 837              		.loc 2 332 12
 838 0034 0F23     		movs	r3, #15
 839 0036 FB18     		adds	r3, r7, r3
 840 0038 1B78     		ldrb	r3, [r3]
 333:../drivers/fsl_clock.c **** }
 841              		.loc 2 333 1
 842 003a 1800     		movs	r0, r3
 843 003c BD46     		mov	sp, r7
 844 003e 04B0     		add	sp, sp, #16
 845              		@ sp needed
 846 0040 80BD     		pop	{r7, pc}
 847              	.L55:
 848 0042 C046     		.align	2
 849              	.L54:
 850 0044 97980000 		.word	39063
 851 0048 00127A00 		.word	8000000
 852              		.cfi_endproc
 853              	.LFE62:
 855              		.section	.rodata.CLOCK_GetOsc0ErClkFreq.str1.4,"aMS",%progbits,1
 856              		.align	2
 857              	.LC7:
 858 0000 2E66736C 		.ascii	".fsl_clock.c:340 : g_xtal0Freq\000"
 858      5F636C6F 
 858      636B2E63 
 858      3A333430 
 858      203A2067 
 859              		.section	.text.CLOCK_GetOsc0ErClkFreq,"ax",%progbits
 860              		.align	1
 861              		.global	CLOCK_GetOsc0ErClkFreq
 862              		.syntax unified
 863              		.code	16
 864              		.thumb_func
 865              		.fpu softvfp
 867              	CLOCK_GetOsc0ErClkFreq:
 868              	.LFB63:
 334:../drivers/fsl_clock.c **** 
 335:../drivers/fsl_clock.c **** uint32_t CLOCK_GetOsc0ErClkFreq(void)
 336:../drivers/fsl_clock.c **** {
 869              		.loc 2 336 1
 870              		.cfi_startproc
 871              		@ args = 0, pretend = 0, frame = 0
 872              		@ frame_needed = 1, uses_anonymous_args = 0
 873 0000 80B5     		push	{r7, lr}
 874              		.cfi_def_cfa_offset 8
 875              		.cfi_offset 7, -8
 876              		.cfi_offset 14, -4
 877 0002 00AF     		add	r7, sp, #0
 878              		.cfi_def_cfa_register 7
 337:../drivers/fsl_clock.c ****     if (OSC0->CR & OSC_CR_ERCLKEN_MASK)
 879              		.loc 2 337 13
 880 0004 0A4B     		ldr	r3, .L60
 881 0006 1B78     		ldrb	r3, [r3]
 882 0008 DBB2     		uxtb	r3, r3
 883              		.loc 2 337 9
 884 000a 5BB2     		sxtb	r3, r3
 885              		.loc 2 337 8
 886 000c 002B     		cmp	r3, #0
 887 000e 0ADA     		bge	.L57
 338:../drivers/fsl_clock.c ****     {
 339:../drivers/fsl_clock.c ****         /* Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock. */
 340:../drivers/fsl_clock.c ****         assert(g_xtal0Freq);
 888              		.loc 2 340 9
 889 0010 084B     		ldr	r3, .L60+4
 890 0012 1B68     		ldr	r3, [r3]
 891 0014 002B     		cmp	r3, #0
 892 0016 03D1     		bne	.L58
 893              		.loc 2 340 9 is_stmt 0 discriminator 1
 894 0018 074B     		ldr	r3, .L60+8
 895 001a 1800     		movs	r0, r3
 896 001c FFF7FEFF 		bl	__assertion_failed
 897              	.L58:
 341:../drivers/fsl_clock.c ****         return g_xtal0Freq;
 898              		.loc 2 341 16 is_stmt 1
 899 0020 044B     		ldr	r3, .L60+4
 900 0022 1B68     		ldr	r3, [r3]
 901 0024 00E0     		b	.L59
 902              	.L57:
 342:../drivers/fsl_clock.c ****     }
 343:../drivers/fsl_clock.c ****     else
 344:../drivers/fsl_clock.c ****     {
 345:../drivers/fsl_clock.c ****         return 0U;
 903              		.loc 2 345 16
 904 0026 0023     		movs	r3, #0
 905              	.L59:
 346:../drivers/fsl_clock.c ****     }
 347:../drivers/fsl_clock.c **** }
 906              		.loc 2 347 1
 907 0028 1800     		movs	r0, r3
 908 002a BD46     		mov	sp, r7
 909              		@ sp needed
 910 002c 80BD     		pop	{r7, pc}
 911              	.L61:
 912 002e C046     		.align	2
 913              	.L60:
 914 0030 00500640 		.word	1074155520
 915 0034 00000000 		.word	g_xtal0Freq
 916 0038 00000000 		.word	.LC7
 917              		.cfi_endproc
 918              	.LFE63:
 920              		.section	.rodata.CLOCK_GetEr32kClkFreq.str1.4,"aMS",%progbits,1
 921              		.align	2
 922              	.LC10:
 923 0000 2E66736C 		.ascii	".fsl_clock.c:360 : g_xtal32Freq\000"
 923      5F636C6F 
 923      636B2E63 
 923      3A333630 
 923      203A2067 
 924              		.section	.text.CLOCK_GetEr32kClkFreq,"ax",%progbits
 925              		.align	1
 926              		.global	CLOCK_GetEr32kClkFreq
 927              		.syntax unified
 928              		.code	16
 929              		.thumb_func
 930              		.fpu softvfp
 932              	CLOCK_GetEr32kClkFreq:
 933              	.LFB64:
 348:../drivers/fsl_clock.c **** 
 349:../drivers/fsl_clock.c **** uint32_t CLOCK_GetEr32kClkFreq(void)
 350:../drivers/fsl_clock.c **** {
 934              		.loc 2 350 1
 935              		.cfi_startproc
 936              		@ args = 0, pretend = 0, frame = 8
 937              		@ frame_needed = 1, uses_anonymous_args = 0
 938 0000 80B5     		push	{r7, lr}
 939              		.cfi_def_cfa_offset 8
 940              		.cfi_offset 7, -8
 941              		.cfi_offset 14, -4
 942 0002 82B0     		sub	sp, sp, #8
 943              		.cfi_def_cfa_offset 16
 944 0004 00AF     		add	r7, sp, #0
 945              		.cfi_def_cfa_register 7
 351:../drivers/fsl_clock.c ****     uint32_t freq;
 352:../drivers/fsl_clock.c **** 
 353:../drivers/fsl_clock.c ****     switch (SIM_SOPT1_OSC32KSEL_VAL)
 946              		.loc 2 353 13
 947 0006 194B     		ldr	r3, .L72
 948 0008 1B68     		ldr	r3, [r3]
 949 000a 9B0C     		lsrs	r3, r3, #18
 950 000c 0322     		movs	r2, #3
 951 000e 1340     		ands	r3, r2
 952              		.loc 2 353 5
 953 0010 032B     		cmp	r3, #3
 954 0012 1ED0     		beq	.L63
 955 0014 21D8     		bhi	.L64
 956 0016 002B     		cmp	r3, #0
 957 0018 02D0     		beq	.L65
 958 001a 022B     		cmp	r3, #2
 959 001c 0DD0     		beq	.L66
 960 001e 1CE0     		b	.L64
 961              	.L65:
 354:../drivers/fsl_clock.c ****     {
 355:../drivers/fsl_clock.c ****         case 0U: /* OSC 32k clock  */
 356:../drivers/fsl_clock.c ****             freq = (CLOCK_GetOsc0ErClkFreq() == 32768U) ? 32768U : 0U;
 962              		.loc 2 356 21
 963 0020 FFF7FEFF 		bl	CLOCK_GetOsc0ErClkFreq
 964 0024 0200     		movs	r2, r0
 965              		.loc 2 356 66
 966 0026 8023     		movs	r3, #128
 967 0028 1B02     		lsls	r3, r3, #8
 968 002a 9A42     		cmp	r2, r3
 969 002c 02D1     		bne	.L67
 970              		.loc 2 356 66 is_stmt 0 discriminator 1
 971 002e 8023     		movs	r3, #128
 972 0030 1B02     		lsls	r3, r3, #8
 973 0032 00E0     		b	.L68
 974              	.L67:
 975              		.loc 2 356 66 discriminator 2
 976 0034 0023     		movs	r3, #0
 977              	.L68:
 978              		.loc 2 356 18 is_stmt 1 discriminator 4
 979 0036 7B60     		str	r3, [r7, #4]
 357:../drivers/fsl_clock.c ****             break;
 980              		.loc 2 357 13 discriminator 4
 981 0038 12E0     		b	.L69
 982              	.L66:
 358:../drivers/fsl_clock.c ****         case 2U: /* RTC 32k clock  */
 359:../drivers/fsl_clock.c ****             /* Please call CLOCK_SetXtal32Freq base on board setting before using XTAL32K/RTC_CLKIN
 360:../drivers/fsl_clock.c ****             assert(g_xtal32Freq);
 983              		.loc 2 360 13
 984 003a 0D4B     		ldr	r3, .L72+4
 985 003c 1B68     		ldr	r3, [r3]
 986 003e 002B     		cmp	r3, #0
 987 0040 03D1     		bne	.L70
 988              		.loc 2 360 13 is_stmt 0 discriminator 1
 989 0042 0C4B     		ldr	r3, .L72+8
 990 0044 1800     		movs	r0, r3
 991 0046 FFF7FEFF 		bl	__assertion_failed
 992              	.L70:
 361:../drivers/fsl_clock.c ****             freq = g_xtal32Freq;
 993              		.loc 2 361 18 is_stmt 1
 994 004a 094B     		ldr	r3, .L72+4
 995 004c 1B68     		ldr	r3, [r3]
 996 004e 7B60     		str	r3, [r7, #4]
 362:../drivers/fsl_clock.c ****             break;
 997              		.loc 2 362 13
 998 0050 06E0     		b	.L69
 999              	.L63:
 363:../drivers/fsl_clock.c ****         case 3U: /* LPO clock      */
 364:../drivers/fsl_clock.c ****             freq = LPO_CLK_FREQ;
 1000              		.loc 2 364 18
 1001 0052 FA23     		movs	r3, #250
 1002 0054 9B00     		lsls	r3, r3, #2
 1003 0056 7B60     		str	r3, [r7, #4]
 365:../drivers/fsl_clock.c ****             break;
 1004              		.loc 2 365 13
 1005 0058 02E0     		b	.L69
 1006              	.L64:
 366:../drivers/fsl_clock.c ****         default:
 367:../drivers/fsl_clock.c ****             freq = 0U;
 1007              		.loc 2 367 18
 1008 005a 0023     		movs	r3, #0
 1009 005c 7B60     		str	r3, [r7, #4]
 368:../drivers/fsl_clock.c ****             break;
 1010              		.loc 2 368 13
 1011 005e C046     		nop
 1012              	.L69:
 369:../drivers/fsl_clock.c ****     }
 370:../drivers/fsl_clock.c ****     return freq;
 1013              		.loc 2 370 12
 1014 0060 7B68     		ldr	r3, [r7, #4]
 371:../drivers/fsl_clock.c **** }
 1015              		.loc 2 371 1
 1016 0062 1800     		movs	r0, r3
 1017 0064 BD46     		mov	sp, r7
 1018 0066 02B0     		add	sp, sp, #8
 1019              		@ sp needed
 1020 0068 80BD     		pop	{r7, pc}
 1021              	.L73:
 1022 006a C046     		.align	2
 1023              	.L72:
 1024 006c 00700440 		.word	1074032640
 1025 0070 00000000 		.word	g_xtal32Freq
 1026 0074 00000000 		.word	.LC10
 1027              		.cfi_endproc
 1028              	.LFE64:
 1030              		.section	.text.CLOCK_GetPllFllSelClkFreq,"ax",%progbits
 1031              		.align	1
 1032              		.global	CLOCK_GetPllFllSelClkFreq
 1033              		.syntax unified
 1034              		.code	16
 1035              		.thumb_func
 1036              		.fpu softvfp
 1038              	CLOCK_GetPllFllSelClkFreq:
 1039              	.LFB65:
 372:../drivers/fsl_clock.c **** 
 373:../drivers/fsl_clock.c **** uint32_t CLOCK_GetPllFllSelClkFreq(void)
 374:../drivers/fsl_clock.c **** {
 1040              		.loc 2 374 1
 1041              		.cfi_startproc
 1042              		@ args = 0, pretend = 0, frame = 8
 1043              		@ frame_needed = 1, uses_anonymous_args = 0
 1044 0000 80B5     		push	{r7, lr}
 1045              		.cfi_def_cfa_offset 8
 1046              		.cfi_offset 7, -8
 1047              		.cfi_offset 14, -4
 1048 0002 82B0     		sub	sp, sp, #8
 1049              		.cfi_def_cfa_offset 16
 1050 0004 00AF     		add	r7, sp, #0
 1051              		.cfi_def_cfa_register 7
 375:../drivers/fsl_clock.c ****     uint32_t freq;
 376:../drivers/fsl_clock.c **** 
 377:../drivers/fsl_clock.c ****     switch (SIM_SOPT2_PLLFLLSEL_VAL)
 1052              		.loc 2 377 13
 1053 0006 0F4A     		ldr	r2, .L81
 1054 0008 0F4B     		ldr	r3, .L81+4
 1055 000a D358     		ldr	r3, [r2, r3]
 1056 000c 1B0C     		lsrs	r3, r3, #16
 1057 000e 0122     		movs	r2, #1
 1058 0010 1340     		ands	r3, r2
 1059              		.loc 2 377 5
 1060 0012 02D0     		beq	.L75
 1061 0014 012B     		cmp	r3, #1
 1062 0016 05D0     		beq	.L76
 1063 0018 0CE0     		b	.L80
 1064              	.L75:
 378:../drivers/fsl_clock.c ****     {
 379:../drivers/fsl_clock.c ****         case 0U: /* FLL. */
 380:../drivers/fsl_clock.c ****             freq = CLOCK_GetFllFreq();
 1065              		.loc 2 380 20
 1066 001a FFF7FEFF 		bl	CLOCK_GetFllFreq
 1067 001e 0300     		movs	r3, r0
 1068 0020 7B60     		str	r3, [r7, #4]
 381:../drivers/fsl_clock.c ****             break;
 1069              		.loc 2 381 13
 1070 0022 0AE0     		b	.L78
 1071              	.L76:
 382:../drivers/fsl_clock.c ****         case 1U: /* PLL. */
 383:../drivers/fsl_clock.c ****             freq = CLOCK_GetPll0Freq();
 1072              		.loc 2 383 20
 1073 0024 FFF7FEFF 		bl	CLOCK_GetPll0Freq
 1074 0028 0300     		movs	r3, r0
 1075 002a 7B60     		str	r3, [r7, #4]
 384:../drivers/fsl_clock.c ****             freq >>= 1U;
 1076              		.loc 2 384 18
 1077 002c 7B68     		ldr	r3, [r7, #4]
 1078 002e 5B08     		lsrs	r3, r3, #1
 1079 0030 7B60     		str	r3, [r7, #4]
 385:../drivers/fsl_clock.c ****             break;
 1080              		.loc 2 385 13
 1081 0032 02E0     		b	.L78
 1082              	.L80:
 386:../drivers/fsl_clock.c ****         default:
 387:../drivers/fsl_clock.c ****             freq = 0U;
 1083              		.loc 2 387 18
 1084 0034 0023     		movs	r3, #0
 1085 0036 7B60     		str	r3, [r7, #4]
 388:../drivers/fsl_clock.c ****             break;
 1086              		.loc 2 388 13
 1087 0038 C046     		nop
 1088              	.L78:
 389:../drivers/fsl_clock.c ****     }
 390:../drivers/fsl_clock.c **** 
 391:../drivers/fsl_clock.c ****     return freq;
 1089              		.loc 2 391 12
 1090 003a 7B68     		ldr	r3, [r7, #4]
 392:../drivers/fsl_clock.c **** }
 1091              		.loc 2 392 1
 1092 003c 1800     		movs	r0, r3
 1093 003e BD46     		mov	sp, r7
 1094 0040 02B0     		add	sp, sp, #8
 1095              		@ sp needed
 1096 0042 80BD     		pop	{r7, pc}
 1097              	.L82:
 1098              		.align	2
 1099              	.L81:
 1100 0044 00700440 		.word	1074032640
 1101 0048 04100000 		.word	4100
 1102              		.cfi_endproc
 1103              	.LFE65:
 1105              		.section	.text.CLOCK_GetPlatClkFreq,"ax",%progbits
 1106              		.align	1
 1107              		.global	CLOCK_GetPlatClkFreq
 1108              		.syntax unified
 1109              		.code	16
 1110              		.thumb_func
 1111              		.fpu softvfp
 1113              	CLOCK_GetPlatClkFreq:
 1114              	.LFB66:
 393:../drivers/fsl_clock.c **** 
 394:../drivers/fsl_clock.c **** uint32_t CLOCK_GetPlatClkFreq(void)
 395:../drivers/fsl_clock.c **** {
 1115              		.loc 2 395 1
 1116              		.cfi_startproc
 1117              		@ args = 0, pretend = 0, frame = 0
 1118              		@ frame_needed = 1, uses_anonymous_args = 0
 1119 0000 80B5     		push	{r7, lr}
 1120              		.cfi_def_cfa_offset 8
 1121              		.cfi_offset 7, -8
 1122              		.cfi_offset 14, -4
 1123 0002 00AF     		add	r7, sp, #0
 1124              		.cfi_def_cfa_register 7
 396:../drivers/fsl_clock.c ****     return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
 1125              		.loc 2 396 12
 1126 0004 FFF7FEFF 		bl	CLOCK_GetOutClkFreq
 1127              		.loc 2 396 37
 1128 0008 064A     		ldr	r2, .L85
 1129 000a 074B     		ldr	r3, .L85+4
 1130 000c D358     		ldr	r3, [r2, r3]
 1131 000e 1B0F     		lsrs	r3, r3, #28
 1132 0010 0F22     		movs	r2, #15
 1133 0012 1340     		ands	r3, r2
 1134              		.loc 2 396 61
 1135 0014 0133     		adds	r3, r3, #1
 1136              		.loc 2 396 34
 1137 0016 1900     		movs	r1, r3
 1138 0018 FFF7FEFF 		bl	__aeabi_uidiv
 1139              	.LVL2:
 1140 001c 0300     		movs	r3, r0
 397:../drivers/fsl_clock.c **** }
 1141              		.loc 2 397 1
 1142 001e 1800     		movs	r0, r3
 1143 0020 BD46     		mov	sp, r7
 1144              		@ sp needed
 1145 0022 80BD     		pop	{r7, pc}
 1146              	.L86:
 1147              		.align	2
 1148              	.L85:
 1149 0024 00700440 		.word	1074032640
 1150 0028 44100000 		.word	4164
 1151              		.cfi_endproc
 1152              	.LFE66:
 1154              		.section	.text.CLOCK_GetFlashClkFreq,"ax",%progbits
 1155              		.align	1
 1156              		.global	CLOCK_GetFlashClkFreq
 1157              		.syntax unified
 1158              		.code	16
 1159              		.thumb_func
 1160              		.fpu softvfp
 1162              	CLOCK_GetFlashClkFreq:
 1163              	.LFB67:
 398:../drivers/fsl_clock.c **** 
 399:../drivers/fsl_clock.c **** uint32_t CLOCK_GetFlashClkFreq(void)
 400:../drivers/fsl_clock.c **** {
 1164              		.loc 2 400 1
 1165              		.cfi_startproc
 1166              		@ args = 0, pretend = 0, frame = 8
 1167              		@ frame_needed = 1, uses_anonymous_args = 0
 1168 0000 80B5     		push	{r7, lr}
 1169              		.cfi_def_cfa_offset 8
 1170              		.cfi_offset 7, -8
 1171              		.cfi_offset 14, -4
 1172 0002 82B0     		sub	sp, sp, #8
 1173              		.cfi_def_cfa_offset 16
 1174 0004 00AF     		add	r7, sp, #0
 1175              		.cfi_def_cfa_register 7
 401:../drivers/fsl_clock.c ****     uint32_t freq;
 402:../drivers/fsl_clock.c **** 
 403:../drivers/fsl_clock.c ****     freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
 1176              		.loc 2 403 12
 1177 0006 FFF7FEFF 		bl	CLOCK_GetOutClkFreq
 1178              		.loc 2 403 37
 1179 000a 0F4A     		ldr	r2, .L89
 1180 000c 0F4B     		ldr	r3, .L89+4
 1181 000e D358     		ldr	r3, [r2, r3]
 1182 0010 1B0F     		lsrs	r3, r3, #28
 1183 0012 0F22     		movs	r2, #15
 1184 0014 1340     		ands	r3, r2
 1185              		.loc 2 403 61
 1186 0016 0133     		adds	r3, r3, #1
 1187              		.loc 2 403 10
 1188 0018 1900     		movs	r1, r3
 1189 001a FFF7FEFF 		bl	__aeabi_uidiv
 1190              	.LVL3:
 1191 001e 0300     		movs	r3, r0
 1192 0020 7B60     		str	r3, [r7, #4]
 404:../drivers/fsl_clock.c ****     freq /= (SIM_CLKDIV1_OUTDIV4_VAL + 1);
 1193              		.loc 2 404 14
 1194 0022 094A     		ldr	r2, .L89
 1195 0024 094B     		ldr	r3, .L89+4
 1196 0026 D358     		ldr	r3, [r2, r3]
 1197 0028 1B0C     		lsrs	r3, r3, #16
 1198 002a 0722     		movs	r2, #7
 1199 002c 1340     		ands	r3, r2
 1200              		.loc 2 404 38
 1201 002e 0133     		adds	r3, r3, #1
 1202              		.loc 2 404 10
 1203 0030 1900     		movs	r1, r3
 1204 0032 7868     		ldr	r0, [r7, #4]
 1205 0034 FFF7FEFF 		bl	__aeabi_uidiv
 1206              	.LVL4:
 1207 0038 0300     		movs	r3, r0
 1208 003a 7B60     		str	r3, [r7, #4]
 405:../drivers/fsl_clock.c **** 
 406:../drivers/fsl_clock.c ****     return freq;
 1209              		.loc 2 406 12
 1210 003c 7B68     		ldr	r3, [r7, #4]
 407:../drivers/fsl_clock.c **** }
 1211              		.loc 2 407 1
 1212 003e 1800     		movs	r0, r3
 1213 0040 BD46     		mov	sp, r7
 1214 0042 02B0     		add	sp, sp, #8
 1215              		@ sp needed
 1216 0044 80BD     		pop	{r7, pc}
 1217              	.L90:
 1218 0046 C046     		.align	2
 1219              	.L89:
 1220 0048 00700440 		.word	1074032640
 1221 004c 44100000 		.word	4164
 1222              		.cfi_endproc
 1223              	.LFE67:
 1225              		.section	.text.CLOCK_GetBusClkFreq,"ax",%progbits
 1226              		.align	1
 1227              		.global	CLOCK_GetBusClkFreq
 1228              		.syntax unified
 1229              		.code	16
 1230              		.thumb_func
 1231              		.fpu softvfp
 1233              	CLOCK_GetBusClkFreq:
 1234              	.LFB68:
 408:../drivers/fsl_clock.c **** 
 409:../drivers/fsl_clock.c **** uint32_t CLOCK_GetBusClkFreq(void)
 410:../drivers/fsl_clock.c **** {
 1235              		.loc 2 410 1
 1236              		.cfi_startproc
 1237              		@ args = 0, pretend = 0, frame = 8
 1238              		@ frame_needed = 1, uses_anonymous_args = 0
 1239 0000 80B5     		push	{r7, lr}
 1240              		.cfi_def_cfa_offset 8
 1241              		.cfi_offset 7, -8
 1242              		.cfi_offset 14, -4
 1243 0002 82B0     		sub	sp, sp, #8
 1244              		.cfi_def_cfa_offset 16
 1245 0004 00AF     		add	r7, sp, #0
 1246              		.cfi_def_cfa_register 7
 411:../drivers/fsl_clock.c ****     uint32_t freq;
 412:../drivers/fsl_clock.c **** 
 413:../drivers/fsl_clock.c ****     freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
 1247              		.loc 2 413 12
 1248 0006 FFF7FEFF 		bl	CLOCK_GetOutClkFreq
 1249              		.loc 2 413 37
 1250 000a 0F4A     		ldr	r2, .L93
 1251 000c 0F4B     		ldr	r3, .L93+4
 1252 000e D358     		ldr	r3, [r2, r3]
 1253 0010 1B0F     		lsrs	r3, r3, #28
 1254 0012 0F22     		movs	r2, #15
 1255 0014 1340     		ands	r3, r2
 1256              		.loc 2 413 61
 1257 0016 0133     		adds	r3, r3, #1
 1258              		.loc 2 413 10
 1259 0018 1900     		movs	r1, r3
 1260 001a FFF7FEFF 		bl	__aeabi_uidiv
 1261              	.LVL5:
 1262 001e 0300     		movs	r3, r0
 1263 0020 7B60     		str	r3, [r7, #4]
 414:../drivers/fsl_clock.c ****     freq /= (SIM_CLKDIV1_OUTDIV4_VAL + 1);
 1264              		.loc 2 414 14
 1265 0022 094A     		ldr	r2, .L93
 1266 0024 094B     		ldr	r3, .L93+4
 1267 0026 D358     		ldr	r3, [r2, r3]
 1268 0028 1B0C     		lsrs	r3, r3, #16
 1269 002a 0722     		movs	r2, #7
 1270 002c 1340     		ands	r3, r2
 1271              		.loc 2 414 38
 1272 002e 0133     		adds	r3, r3, #1
 1273              		.loc 2 414 10
 1274 0030 1900     		movs	r1, r3
 1275 0032 7868     		ldr	r0, [r7, #4]
 1276 0034 FFF7FEFF 		bl	__aeabi_uidiv
 1277              	.LVL6:
 1278 0038 0300     		movs	r3, r0
 1279 003a 7B60     		str	r3, [r7, #4]
 415:../drivers/fsl_clock.c **** 
 416:../drivers/fsl_clock.c ****     return freq;
 1280              		.loc 2 416 12
 1281 003c 7B68     		ldr	r3, [r7, #4]
 417:../drivers/fsl_clock.c **** }
 1282              		.loc 2 417 1
 1283 003e 1800     		movs	r0, r3
 1284 0040 BD46     		mov	sp, r7
 1285 0042 02B0     		add	sp, sp, #8
 1286              		@ sp needed
 1287 0044 80BD     		pop	{r7, pc}
 1288              	.L94:
 1289 0046 C046     		.align	2
 1290              	.L93:
 1291 0048 00700440 		.word	1074032640
 1292 004c 44100000 		.word	4164
 1293              		.cfi_endproc
 1294              	.LFE68:
 1296              		.section	.text.CLOCK_GetCoreSysClkFreq,"ax",%progbits
 1297              		.align	1
 1298              		.global	CLOCK_GetCoreSysClkFreq
 1299              		.syntax unified
 1300              		.code	16
 1301              		.thumb_func
 1302              		.fpu softvfp
 1304              	CLOCK_GetCoreSysClkFreq:
 1305              	.LFB69:
 418:../drivers/fsl_clock.c **** 
 419:../drivers/fsl_clock.c **** uint32_t CLOCK_GetCoreSysClkFreq(void)
 420:../drivers/fsl_clock.c **** {
 1306              		.loc 2 420 1
 1307              		.cfi_startproc
 1308              		@ args = 0, pretend = 0, frame = 0
 1309              		@ frame_needed = 1, uses_anonymous_args = 0
 1310 0000 80B5     		push	{r7, lr}
 1311              		.cfi_def_cfa_offset 8
 1312              		.cfi_offset 7, -8
 1313              		.cfi_offset 14, -4
 1314 0002 00AF     		add	r7, sp, #0
 1315              		.cfi_def_cfa_register 7
 421:../drivers/fsl_clock.c ****     return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
 1316              		.loc 2 421 12
 1317 0004 FFF7FEFF 		bl	CLOCK_GetOutClkFreq
 1318              		.loc 2 421 37
 1319 0008 064A     		ldr	r2, .L97
 1320 000a 074B     		ldr	r3, .L97+4
 1321 000c D358     		ldr	r3, [r2, r3]
 1322 000e 1B0F     		lsrs	r3, r3, #28
 1323 0010 0F22     		movs	r2, #15
 1324 0012 1340     		ands	r3, r2
 1325              		.loc 2 421 61
 1326 0014 0133     		adds	r3, r3, #1
 1327              		.loc 2 421 34
 1328 0016 1900     		movs	r1, r3
 1329 0018 FFF7FEFF 		bl	__aeabi_uidiv
 1330              	.LVL7:
 1331 001c 0300     		movs	r3, r0
 422:../drivers/fsl_clock.c **** }
 1332              		.loc 2 422 1
 1333 001e 1800     		movs	r0, r3
 1334 0020 BD46     		mov	sp, r7
 1335              		@ sp needed
 1336 0022 80BD     		pop	{r7, pc}
 1337              	.L98:
 1338              		.align	2
 1339              	.L97:
 1340 0024 00700440 		.word	1074032640
 1341 0028 44100000 		.word	4164
 1342              		.cfi_endproc
 1343              	.LFE69:
 1345              		.section	.text.CLOCK_GetFreq,"ax",%progbits
 1346              		.align	1
 1347              		.global	CLOCK_GetFreq
 1348              		.syntax unified
 1349              		.code	16
 1350              		.thumb_func
 1351              		.fpu softvfp
 1353              	CLOCK_GetFreq:
 1354              	.LFB70:
 423:../drivers/fsl_clock.c **** 
 424:../drivers/fsl_clock.c **** uint32_t CLOCK_GetFreq(clock_name_t clockName)
 425:../drivers/fsl_clock.c **** {
 1355              		.loc 2 425 1
 1356              		.cfi_startproc
 1357              		@ args = 0, pretend = 0, frame = 16
 1358              		@ frame_needed = 1, uses_anonymous_args = 0
 1359 0000 80B5     		push	{r7, lr}
 1360              		.cfi_def_cfa_offset 8
 1361              		.cfi_offset 7, -8
 1362              		.cfi_offset 14, -4
 1363 0002 84B0     		sub	sp, sp, #16
 1364              		.cfi_def_cfa_offset 24
 1365 0004 00AF     		add	r7, sp, #0
 1366              		.cfi_def_cfa_register 7
 1367 0006 0200     		movs	r2, r0
 1368 0008 FB1D     		adds	r3, r7, #7
 1369 000a 1A70     		strb	r2, [r3]
 426:../drivers/fsl_clock.c ****     uint32_t freq;
 427:../drivers/fsl_clock.c **** 
 428:../drivers/fsl_clock.c ****     switch (clockName)
 1370              		.loc 2 428 5
 1371 000c FB1D     		adds	r3, r7, #7
 1372 000e 1B78     		ldrb	r3, [r3]
 1373 0010 0D2B     		cmp	r3, #13
 1374 0012 56D8     		bhi	.L100
 1375 0014 9A00     		lsls	r2, r3, #2
 1376 0016 2F4B     		ldr	r3, .L114
 1377 0018 D318     		adds	r3, r2, r3
 1378 001a 1B68     		ldr	r3, [r3]
 1379 001c 9F46     		mov	pc, r3
 1380              		.section	.rodata.CLOCK_GetFreq,"a",%progbits
 1381              		.align	2
 1382              	.L102:
 1383 0000 1E000000 		.word	.L111
 1384 0004 1E000000 		.word	.L111
 1385 0008 3C000000 		.word	.L110
 1386 000c C2000000 		.word	.L100
 1387 0010 3C000000 		.word	.L110
 1388 0014 74000000 		.word	.L109
 1389 0018 7E000000 		.word	.L108
 1390 001c B8000000 		.word	.L107
 1391 0020 88000000 		.word	.L106
 1392 0024 92000000 		.word	.L105
 1393 0028 9C000000 		.word	.L104
 1394 002c A6000000 		.word	.L103
 1395 0030 C2000000 		.word	.L100
 1396 0034 B0000000 		.word	.L101
 1397              		.section	.text.CLOCK_GetFreq
 1398              	.L111:
 429:../drivers/fsl_clock.c ****     {
 430:../drivers/fsl_clock.c ****         case kCLOCK_CoreSysClk:
 431:../drivers/fsl_clock.c ****         case kCLOCK_PlatClk:
 432:../drivers/fsl_clock.c ****             freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
 1399              		.loc 2 432 20
 1400 001e FFF7FEFF 		bl	CLOCK_GetOutClkFreq
 1401              		.loc 2 432 45
 1402 0022 2D4A     		ldr	r2, .L114+4
 1403 0024 2D4B     		ldr	r3, .L114+8
 1404 0026 D358     		ldr	r3, [r2, r3]
 1405 0028 1B0F     		lsrs	r3, r3, #28
 1406 002a 0F22     		movs	r2, #15
 1407 002c 1340     		ands	r3, r2
 1408              		.loc 2 432 69
 1409 002e 0133     		adds	r3, r3, #1
 1410              		.loc 2 432 18
 1411 0030 1900     		movs	r1, r3
 1412 0032 FFF7FEFF 		bl	__aeabi_uidiv
 1413              	.LVL8:
 1414 0036 0300     		movs	r3, r0
 1415 0038 FB60     		str	r3, [r7, #12]
 433:../drivers/fsl_clock.c ****             break;
 1416              		.loc 2 433 13
 1417 003a 45E0     		b	.L112
 1418              	.L110:
 434:../drivers/fsl_clock.c ****         case kCLOCK_BusClk:
 435:../drivers/fsl_clock.c ****         case kCLOCK_FlashClk:
 436:../drivers/fsl_clock.c ****             freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
 1419              		.loc 2 436 20
 1420 003c FFF7FEFF 		bl	CLOCK_GetOutClkFreq
 1421              		.loc 2 436 45
 1422 0040 254A     		ldr	r2, .L114+4
 1423 0042 264B     		ldr	r3, .L114+8
 1424 0044 D358     		ldr	r3, [r2, r3]
 1425 0046 1B0F     		lsrs	r3, r3, #28
 1426 0048 0F22     		movs	r2, #15
 1427 004a 1340     		ands	r3, r2
 1428              		.loc 2 436 69
 1429 004c 0133     		adds	r3, r3, #1
 1430              		.loc 2 436 18
 1431 004e 1900     		movs	r1, r3
 1432 0050 FFF7FEFF 		bl	__aeabi_uidiv
 1433              	.LVL9:
 1434 0054 0300     		movs	r3, r0
 1435 0056 FB60     		str	r3, [r7, #12]
 437:../drivers/fsl_clock.c ****             freq /= (SIM_CLKDIV1_OUTDIV4_VAL + 1);
 1436              		.loc 2 437 22
 1437 0058 1F4A     		ldr	r2, .L114+4
 1438 005a 204B     		ldr	r3, .L114+8
 1439 005c D358     		ldr	r3, [r2, r3]
 1440 005e 1B0C     		lsrs	r3, r3, #16
 1441 0060 0722     		movs	r2, #7
 1442 0062 1340     		ands	r3, r2
 1443              		.loc 2 437 46
 1444 0064 0133     		adds	r3, r3, #1
 1445              		.loc 2 437 18
 1446 0066 1900     		movs	r1, r3
 1447 0068 F868     		ldr	r0, [r7, #12]
 1448 006a FFF7FEFF 		bl	__aeabi_uidiv
 1449              	.LVL10:
 1450 006e 0300     		movs	r3, r0
 1451 0070 FB60     		str	r3, [r7, #12]
 438:../drivers/fsl_clock.c ****             break;
 1452              		.loc 2 438 13
 1453 0072 29E0     		b	.L112
 1454              	.L109:
 439:../drivers/fsl_clock.c ****         case kCLOCK_PllFllSelClk:
 440:../drivers/fsl_clock.c ****             freq = CLOCK_GetPllFllSelClkFreq();
 1455              		.loc 2 440 20
 1456 0074 FFF7FEFF 		bl	CLOCK_GetPllFllSelClkFreq
 1457 0078 0300     		movs	r3, r0
 1458 007a FB60     		str	r3, [r7, #12]
 441:../drivers/fsl_clock.c ****             break;
 1459              		.loc 2 441 13
 1460 007c 24E0     		b	.L112
 1461              	.L108:
 442:../drivers/fsl_clock.c ****         case kCLOCK_Er32kClk:
 443:../drivers/fsl_clock.c ****             freq = CLOCK_GetEr32kClkFreq();
 1462              		.loc 2 443 20
 1463 007e FFF7FEFF 		bl	CLOCK_GetEr32kClkFreq
 1464 0082 0300     		movs	r3, r0
 1465 0084 FB60     		str	r3, [r7, #12]
 444:../drivers/fsl_clock.c ****             break;
 1466              		.loc 2 444 13
 1467 0086 1FE0     		b	.L112
 1468              	.L106:
 445:../drivers/fsl_clock.c ****         case kCLOCK_McgFixedFreqClk:
 446:../drivers/fsl_clock.c ****             freq = CLOCK_GetFixedFreqClkFreq();
 1469              		.loc 2 446 20
 1470 0088 FFF7FEFF 		bl	CLOCK_GetFixedFreqClkFreq
 1471 008c 0300     		movs	r3, r0
 1472 008e FB60     		str	r3, [r7, #12]
 447:../drivers/fsl_clock.c ****             break;
 1473              		.loc 2 447 13
 1474 0090 1AE0     		b	.L112
 1475              	.L105:
 448:../drivers/fsl_clock.c ****         case kCLOCK_McgInternalRefClk:
 449:../drivers/fsl_clock.c ****             freq = CLOCK_GetInternalRefClkFreq();
 1476              		.loc 2 449 20
 1477 0092 FFF7FEFF 		bl	CLOCK_GetInternalRefClkFreq
 1478 0096 0300     		movs	r3, r0
 1479 0098 FB60     		str	r3, [r7, #12]
 450:../drivers/fsl_clock.c ****             break;
 1480              		.loc 2 450 13
 1481 009a 15E0     		b	.L112
 1482              	.L104:
 451:../drivers/fsl_clock.c ****         case kCLOCK_McgFllClk:
 452:../drivers/fsl_clock.c ****             freq = CLOCK_GetFllFreq();
 1483              		.loc 2 452 20
 1484 009c FFF7FEFF 		bl	CLOCK_GetFllFreq
 1485 00a0 0300     		movs	r3, r0
 1486 00a2 FB60     		str	r3, [r7, #12]
 453:../drivers/fsl_clock.c ****             break;
 1487              		.loc 2 453 13
 1488 00a4 10E0     		b	.L112
 1489              	.L103:
 454:../drivers/fsl_clock.c ****         case kCLOCK_McgPll0Clk:
 455:../drivers/fsl_clock.c ****             freq = CLOCK_GetPll0Freq();
 1490              		.loc 2 455 20
 1491 00a6 FFF7FEFF 		bl	CLOCK_GetPll0Freq
 1492 00aa 0300     		movs	r3, r0
 1493 00ac FB60     		str	r3, [r7, #12]
 456:../drivers/fsl_clock.c ****             break;
 1494              		.loc 2 456 13
 1495 00ae 0BE0     		b	.L112
 1496              	.L101:
 457:../drivers/fsl_clock.c ****         case kCLOCK_LpoClk:
 458:../drivers/fsl_clock.c ****             freq = LPO_CLK_FREQ;
 1497              		.loc 2 458 18
 1498 00b0 FA23     		movs	r3, #250
 1499 00b2 9B00     		lsls	r3, r3, #2
 1500 00b4 FB60     		str	r3, [r7, #12]
 459:../drivers/fsl_clock.c ****             break;
 1501              		.loc 2 459 13
 1502 00b6 07E0     		b	.L112
 1503              	.L107:
 460:../drivers/fsl_clock.c ****         case kCLOCK_Osc0ErClk:
 461:../drivers/fsl_clock.c ****             freq = CLOCK_GetOsc0ErClkFreq();
 1504              		.loc 2 461 20
 1505 00b8 FFF7FEFF 		bl	CLOCK_GetOsc0ErClkFreq
 1506 00bc 0300     		movs	r3, r0
 1507 00be FB60     		str	r3, [r7, #12]
 462:../drivers/fsl_clock.c ****             break;
 1508              		.loc 2 462 13
 1509 00c0 02E0     		b	.L112
 1510              	.L100:
 463:../drivers/fsl_clock.c ****         default:
 464:../drivers/fsl_clock.c ****             freq = 0U;
 1511              		.loc 2 464 18
 1512 00c2 0023     		movs	r3, #0
 1513 00c4 FB60     		str	r3, [r7, #12]
 465:../drivers/fsl_clock.c ****             break;
 1514              		.loc 2 465 13
 1515 00c6 C046     		nop
 1516              	.L112:
 466:../drivers/fsl_clock.c ****     }
 467:../drivers/fsl_clock.c **** 
 468:../drivers/fsl_clock.c ****     return freq;
 1517              		.loc 2 468 12
 1518 00c8 FB68     		ldr	r3, [r7, #12]
 469:../drivers/fsl_clock.c **** }
 1519              		.loc 2 469 1
 1520 00ca 1800     		movs	r0, r3
 1521 00cc BD46     		mov	sp, r7
 1522 00ce 04B0     		add	sp, sp, #16
 1523              		@ sp needed
 1524 00d0 80BD     		pop	{r7, pc}
 1525              	.L115:
 1526 00d2 C046     		.align	2
 1527              	.L114:
 1528 00d4 00000000 		.word	.L102
 1529 00d8 00700440 		.word	1074032640
 1530 00dc 44100000 		.word	4164
 1531              		.cfi_endproc
 1532              	.LFE70:
 1534              		.section	.text.CLOCK_SetSimConfig,"ax",%progbits
 1535              		.align	1
 1536              		.global	CLOCK_SetSimConfig
 1537              		.syntax unified
 1538              		.code	16
 1539              		.thumb_func
 1540              		.fpu softvfp
 1542              	CLOCK_SetSimConfig:
 1543              	.LFB71:
 470:../drivers/fsl_clock.c **** 
 471:../drivers/fsl_clock.c **** void CLOCK_SetSimConfig(sim_clock_config_t const *config)
 472:../drivers/fsl_clock.c **** {
 1544              		.loc 2 472 1
 1545              		.cfi_startproc
 1546              		@ args = 0, pretend = 0, frame = 8
 1547              		@ frame_needed = 1, uses_anonymous_args = 0
 1548 0000 80B5     		push	{r7, lr}
 1549              		.cfi_def_cfa_offset 8
 1550              		.cfi_offset 7, -8
 1551              		.cfi_offset 14, -4
 1552 0002 82B0     		sub	sp, sp, #8
 1553              		.cfi_def_cfa_offset 16
 1554 0004 00AF     		add	r7, sp, #0
 1555              		.cfi_def_cfa_register 7
 1556 0006 7860     		str	r0, [r7, #4]
 473:../drivers/fsl_clock.c ****     SIM->CLKDIV1 = config->clkdiv1;
 1557              		.loc 2 473 8
 1558 0008 0949     		ldr	r1, .L117
 1559              		.loc 2 473 26
 1560 000a 7B68     		ldr	r3, [r7, #4]
 1561 000c 5B68     		ldr	r3, [r3, #4]
 1562              		.loc 2 473 18
 1563 000e 094A     		ldr	r2, .L117+4
 1564 0010 8B50     		str	r3, [r1, r2]
 474:../drivers/fsl_clock.c ****     CLOCK_SetPllFllSelClock(config->pllFllSel);
 1565              		.loc 2 474 35
 1566 0012 7B68     		ldr	r3, [r7, #4]
 1567 0014 1B78     		ldrb	r3, [r3]
 1568              		.loc 2 474 5
 1569 0016 1800     		movs	r0, r3
 1570 0018 FFF7FEFF 		bl	CLOCK_SetPllFllSelClock
 475:../drivers/fsl_clock.c ****     CLOCK_SetEr32kClock(config->er32kSrc);
 1571              		.loc 2 475 31
 1572 001c 7B68     		ldr	r3, [r7, #4]
 1573 001e 5B78     		ldrb	r3, [r3, #1]
 1574              		.loc 2 475 5
 1575 0020 1800     		movs	r0, r3
 1576 0022 FFF7FEFF 		bl	CLOCK_SetEr32kClock
 476:../drivers/fsl_clock.c **** }
 1577              		.loc 2 476 1
 1578 0026 C046     		nop
 1579 0028 BD46     		mov	sp, r7
 1580 002a 02B0     		add	sp, sp, #8
 1581              		@ sp needed
 1582 002c 80BD     		pop	{r7, pc}
 1583              	.L118:
 1584 002e C046     		.align	2
 1585              	.L117:
 1586 0030 00700440 		.word	1074032640
 1587 0034 44100000 		.word	4164
 1588              		.cfi_endproc
 1589              	.LFE71:
 1591              		.section	.text.CLOCK_EnableUsbfs0Clock,"ax",%progbits
 1592              		.align	1
 1593              		.global	CLOCK_EnableUsbfs0Clock
 1594              		.syntax unified
 1595              		.code	16
 1596              		.thumb_func
 1597              		.fpu softvfp
 1599              	CLOCK_EnableUsbfs0Clock:
 1600              	.LFB72:
 477:../drivers/fsl_clock.c **** 
 478:../drivers/fsl_clock.c **** bool CLOCK_EnableUsbfs0Clock(clock_usb_src_t src, uint32_t freq)
 479:../drivers/fsl_clock.c **** {
 1601              		.loc 2 479 1
 1602              		.cfi_startproc
 1603              		@ args = 0, pretend = 0, frame = 16
 1604              		@ frame_needed = 1, uses_anonymous_args = 0
 1605 0000 80B5     		push	{r7, lr}
 1606              		.cfi_def_cfa_offset 8
 1607              		.cfi_offset 7, -8
 1608              		.cfi_offset 14, -4
 1609 0002 84B0     		sub	sp, sp, #16
 1610              		.cfi_def_cfa_offset 24
 1611 0004 00AF     		add	r7, sp, #0
 1612              		.cfi_def_cfa_register 7
 1613 0006 7860     		str	r0, [r7, #4]
 1614 0008 3960     		str	r1, [r7]
 480:../drivers/fsl_clock.c ****     bool ret = true;
 1615              		.loc 2 480 10
 1616 000a 0F23     		movs	r3, #15
 1617 000c FB18     		adds	r3, r7, r3
 1618 000e 0122     		movs	r2, #1
 1619 0010 1A70     		strb	r2, [r3]
 481:../drivers/fsl_clock.c **** 
 482:../drivers/fsl_clock.c ****     CLOCK_DisableClock(kCLOCK_Usbfs0);
 1620              		.loc 2 482 5
 1621 0012 164B     		ldr	r3, .L124
 1622 0014 1800     		movs	r0, r3
 1623 0016 FFF7FEFF 		bl	CLOCK_DisableClock
 483:../drivers/fsl_clock.c **** 
 484:../drivers/fsl_clock.c ****     if (kCLOCK_UsbSrcExt == src)
 1624              		.loc 2 484 8
 1625 001a 7B68     		ldr	r3, [r7, #4]
 1626 001c 002B     		cmp	r3, #0
 1627 001e 08D1     		bne	.L120
 485:../drivers/fsl_clock.c ****     {
 486:../drivers/fsl_clock.c ****         SIM->SOPT2 &= ~SIM_SOPT2_USBSRC_MASK;
 1628              		.loc 2 486 20
 1629 0020 134A     		ldr	r2, .L124+4
 1630 0022 144B     		ldr	r3, .L124+8
 1631 0024 D358     		ldr	r3, [r2, r3]
 1632 0026 1249     		ldr	r1, .L124+4
 1633 0028 134A     		ldr	r2, .L124+12
 1634 002a 1340     		ands	r3, r2
 1635 002c 114A     		ldr	r2, .L124+8
 1636 002e 8B50     		str	r3, [r1, r2]
 1637 0030 11E0     		b	.L121
 1638              	.L120:
 487:../drivers/fsl_clock.c ****     }
 488:../drivers/fsl_clock.c ****     else
 489:../drivers/fsl_clock.c ****     {
 490:../drivers/fsl_clock.c ****         if (48000000U != freq)
 1639              		.loc 2 490 12
 1640 0032 3B68     		ldr	r3, [r7]
 1641 0034 114A     		ldr	r2, .L124+16
 1642 0036 9342     		cmp	r3, r2
 1643 0038 03D0     		beq	.L122
 491:../drivers/fsl_clock.c ****         {
 492:../drivers/fsl_clock.c ****             ret = false;
 1644              		.loc 2 492 17
 1645 003a 0F23     		movs	r3, #15
 1646 003c FB18     		adds	r3, r7, r3
 1647 003e 0022     		movs	r2, #0
 1648 0040 1A70     		strb	r2, [r3]
 1649              	.L122:
 493:../drivers/fsl_clock.c ****         }
 494:../drivers/fsl_clock.c **** 
 495:../drivers/fsl_clock.c ****         SIM->SOPT2 = ((SIM->SOPT2 & ~(SIM_SOPT2_PLLFLLSEL_MASK | SIM_SOPT2_USBSRC_MASK)) | (uint32_
 1650              		.loc 2 495 27
 1651 0042 0B4A     		ldr	r2, .L124+4
 1652 0044 0B4B     		ldr	r3, .L124+8
 1653 0046 D358     		ldr	r3, [r2, r3]
 1654              		.loc 2 495 35
 1655 0048 0D4A     		ldr	r2, .L124+20
 1656 004a 1A40     		ands	r2, r3
 1657              		.loc 2 495 12
 1658 004c 0849     		ldr	r1, .L124+4
 1659              		.loc 2 495 90
 1660 004e 7B68     		ldr	r3, [r7, #4]
 1661 0050 1343     		orrs	r3, r2
 1662              		.loc 2 495 20
 1663 0052 084A     		ldr	r2, .L124+8
 1664 0054 8B50     		str	r3, [r1, r2]
 1665              	.L121:
 496:../drivers/fsl_clock.c ****     }
 497:../drivers/fsl_clock.c **** 
 498:../drivers/fsl_clock.c ****     CLOCK_EnableClock(kCLOCK_Usbfs0);
 1666              		.loc 2 498 5
 1667 0056 054B     		ldr	r3, .L124
 1668 0058 1800     		movs	r0, r3
 1669 005a FFF7FEFF 		bl	CLOCK_EnableClock
 499:../drivers/fsl_clock.c **** 
 500:../drivers/fsl_clock.c ****     return ret;
 1670              		.loc 2 500 12
 1671 005e 0F23     		movs	r3, #15
 1672 0060 FB18     		adds	r3, r7, r3
 1673 0062 1B78     		ldrb	r3, [r3]
 501:../drivers/fsl_clock.c **** }
 1674              		.loc 2 501 1
 1675 0064 1800     		movs	r0, r3
 1676 0066 BD46     		mov	sp, r7
 1677 0068 04B0     		add	sp, sp, #16
 1678              		@ sp needed
 1679 006a 80BD     		pop	{r7, pc}
 1680              	.L125:
 1681              		.align	2
 1682              	.L124:
 1683 006c 12003410 		.word	271843346
 1684 0070 00700440 		.word	1074032640
 1685 0074 04100000 		.word	4100
 1686 0078 FFFFFBFF 		.word	-262145
 1687 007c 006CDC02 		.word	48000000
 1688 0080 FFFFFAFF 		.word	-327681
 1689              		.cfi_endproc
 1690              	.LFE72:
 1692              		.section	.text.CLOCK_GetOutClkFreq,"ax",%progbits
 1693              		.align	1
 1694              		.global	CLOCK_GetOutClkFreq
 1695              		.syntax unified
 1696              		.code	16
 1697              		.thumb_func
 1698              		.fpu softvfp
 1700              	CLOCK_GetOutClkFreq:
 1701              	.LFB73:
 502:../drivers/fsl_clock.c **** 
 503:../drivers/fsl_clock.c **** uint32_t CLOCK_GetOutClkFreq(void)
 504:../drivers/fsl_clock.c **** {
 1702              		.loc 2 504 1
 1703              		.cfi_startproc
 1704              		@ args = 0, pretend = 0, frame = 8
 1705              		@ frame_needed = 1, uses_anonymous_args = 0
 1706 0000 80B5     		push	{r7, lr}
 1707              		.cfi_def_cfa_offset 8
 1708              		.cfi_offset 7, -8
 1709              		.cfi_offset 14, -4
 1710 0002 82B0     		sub	sp, sp, #8
 1711              		.cfi_def_cfa_offset 16
 1712 0004 00AF     		add	r7, sp, #0
 1713              		.cfi_def_cfa_register 7
 505:../drivers/fsl_clock.c ****     uint32_t mcgoutclk;
 506:../drivers/fsl_clock.c ****     uint32_t clkst = MCG_S_CLKST_VAL;
 1714              		.loc 2 506 22
 1715 0006 1B4B     		ldr	r3, .L134
 1716 0008 9B79     		ldrb	r3, [r3, #6]
 1717 000a DBB2     		uxtb	r3, r3
 1718 000c 9B08     		lsrs	r3, r3, #2
 1719              		.loc 2 506 14
 1720 000e 0322     		movs	r2, #3
 1721 0010 1340     		ands	r3, r2
 1722 0012 3B60     		str	r3, [r7]
 507:../drivers/fsl_clock.c **** 
 508:../drivers/fsl_clock.c ****     switch (clkst)
 1723              		.loc 2 508 5
 1724 0014 3B68     		ldr	r3, [r7]
 1725 0016 032B     		cmp	r3, #3
 1726 0018 0FD0     		beq	.L127
 1727 001a 3B68     		ldr	r3, [r7]
 1728 001c 032B     		cmp	r3, #3
 1729 001e 20D8     		bhi	.L128
 1730 0020 3B68     		ldr	r3, [r7]
 1731 0022 022B     		cmp	r3, #2
 1732 0024 18D0     		beq	.L129
 1733 0026 3B68     		ldr	r3, [r7]
 1734 0028 022B     		cmp	r3, #2
 1735 002a 1AD8     		bhi	.L128
 1736 002c 3B68     		ldr	r3, [r7]
 1737 002e 002B     		cmp	r3, #0
 1738 0030 08D0     		beq	.L130
 1739 0032 3B68     		ldr	r3, [r7]
 1740 0034 012B     		cmp	r3, #1
 1741 0036 0AD0     		beq	.L131
 1742 0038 13E0     		b	.L128
 1743              	.L127:
 509:../drivers/fsl_clock.c ****     {
 510:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatPll:
 511:../drivers/fsl_clock.c ****             mcgoutclk = CLOCK_GetPll0Freq();
 1744              		.loc 2 511 25
 1745 003a FFF7FEFF 		bl	CLOCK_GetPll0Freq
 1746 003e 0300     		movs	r3, r0
 1747 0040 7B60     		str	r3, [r7, #4]
 512:../drivers/fsl_clock.c ****             break;
 1748              		.loc 2 512 13
 1749 0042 11E0     		b	.L132
 1750              	.L130:
 513:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatFll:
 514:../drivers/fsl_clock.c ****             mcgoutclk = CLOCK_GetFllFreq();
 1751              		.loc 2 514 25
 1752 0044 FFF7FEFF 		bl	CLOCK_GetFllFreq
 1753 0048 0300     		movs	r3, r0
 1754 004a 7B60     		str	r3, [r7, #4]
 515:../drivers/fsl_clock.c ****             break;
 1755              		.loc 2 515 13
 1756 004c 0CE0     		b	.L132
 1757              	.L131:
 516:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatInt:
 517:../drivers/fsl_clock.c ****             mcgoutclk = CLOCK_GetInternalRefClkSelectFreq();
 1758              		.loc 2 517 25
 1759 004e FFF7FEFF 		bl	CLOCK_GetInternalRefClkSelectFreq
 1760 0052 0300     		movs	r3, r0
 1761 0054 7B60     		str	r3, [r7, #4]
 518:../drivers/fsl_clock.c ****             break;
 1762              		.loc 2 518 13
 1763 0056 07E0     		b	.L132
 1764              	.L129:
 519:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatExt:
 520:../drivers/fsl_clock.c ****             mcgoutclk = CLOCK_GetMcgExtClkFreq();
 1765              		.loc 2 520 25
 1766 0058 FFF7FEFF 		bl	CLOCK_GetMcgExtClkFreq
 1767 005c 0300     		movs	r3, r0
 1768 005e 7B60     		str	r3, [r7, #4]
 521:../drivers/fsl_clock.c ****             break;
 1769              		.loc 2 521 13
 1770 0060 02E0     		b	.L132
 1771              	.L128:
 522:../drivers/fsl_clock.c ****         default:
 523:../drivers/fsl_clock.c ****             mcgoutclk = 0U;
 1772              		.loc 2 523 23
 1773 0062 0023     		movs	r3, #0
 1774 0064 7B60     		str	r3, [r7, #4]
 524:../drivers/fsl_clock.c ****             break;
 1775              		.loc 2 524 13
 1776 0066 C046     		nop
 1777              	.L132:
 525:../drivers/fsl_clock.c ****     }
 526:../drivers/fsl_clock.c ****     return mcgoutclk;
 1778              		.loc 2 526 12
 1779 0068 7B68     		ldr	r3, [r7, #4]
 527:../drivers/fsl_clock.c **** }
 1780              		.loc 2 527 1
 1781 006a 1800     		movs	r0, r3
 1782 006c BD46     		mov	sp, r7
 1783 006e 02B0     		add	sp, sp, #8
 1784              		@ sp needed
 1785 0070 80BD     		pop	{r7, pc}
 1786              	.L135:
 1787 0072 C046     		.align	2
 1788              	.L134:
 1789 0074 00400640 		.word	1074151424
 1790              		.cfi_endproc
 1791              	.LFE73:
 1793              		.section	.text.CLOCK_GetFllFreq,"ax",%progbits
 1794              		.align	1
 1795              		.global	CLOCK_GetFllFreq
 1796              		.syntax unified
 1797              		.code	16
 1798              		.thumb_func
 1799              		.fpu softvfp
 1801              	CLOCK_GetFllFreq:
 1802              	.LFB74:
 528:../drivers/fsl_clock.c **** 
 529:../drivers/fsl_clock.c **** uint32_t CLOCK_GetFllFreq(void)
 530:../drivers/fsl_clock.c **** {
 1803              		.loc 2 530 1
 1804              		.cfi_startproc
 1805              		@ args = 0, pretend = 0, frame = 8
 1806              		@ frame_needed = 1, uses_anonymous_args = 0
 1807 0000 80B5     		push	{r7, lr}
 1808              		.cfi_def_cfa_offset 8
 1809              		.cfi_offset 7, -8
 1810              		.cfi_offset 14, -4
 1811 0002 82B0     		sub	sp, sp, #8
 1812              		.cfi_def_cfa_offset 16
 1813 0004 00AF     		add	r7, sp, #0
 1814              		.cfi_def_cfa_register 7
 531:../drivers/fsl_clock.c ****     static const uint16_t fllFactorTable[4][2] = {{640, 732}, {1280, 1464}, {1920, 2197}, {2560, 29
 532:../drivers/fsl_clock.c **** 
 533:../drivers/fsl_clock.c ****     uint8_t drs, dmx32;
 534:../drivers/fsl_clock.c ****     uint32_t freq;
 535:../drivers/fsl_clock.c **** 
 536:../drivers/fsl_clock.c ****     /* If FLL is not enabled currently, then return 0U. */
 537:../drivers/fsl_clock.c ****     if ((MCG->C2 & MCG_C2_LP_MASK) || (MCG->S & MCG_S_PLLST_MASK))
 1815              		.loc 2 537 13
 1816 0006 1D4B     		ldr	r3, .L141
 1817 0008 5B78     		ldrb	r3, [r3, #1]
 1818 000a DBB2     		uxtb	r3, r3
 1819              		.loc 2 537 18
 1820 000c 1A00     		movs	r2, r3
 1821 000e 0223     		movs	r3, #2
 1822 0010 1340     		ands	r3, r2
 1823              		.loc 2 537 8
 1824 0012 06D1     		bne	.L137
 1825              		.loc 2 537 43 discriminator 1
 1826 0014 194B     		ldr	r3, .L141
 1827 0016 9B79     		ldrb	r3, [r3, #6]
 1828 0018 DBB2     		uxtb	r3, r3
 1829              		.loc 2 537 47 discriminator 1
 1830 001a 1A00     		movs	r2, r3
 1831 001c 2023     		movs	r3, #32
 1832 001e 1340     		ands	r3, r2
 1833              		.loc 2 537 36 discriminator 1
 1834 0020 01D0     		beq	.L138
 1835              	.L137:
 538:../drivers/fsl_clock.c ****     {
 539:../drivers/fsl_clock.c ****         return 0U;
 1836              		.loc 2 539 16
 1837 0022 0023     		movs	r3, #0
 1838 0024 26E0     		b	.L139
 1839              	.L138:
 540:../drivers/fsl_clock.c ****     }
 541:../drivers/fsl_clock.c **** 
 542:../drivers/fsl_clock.c ****     /* Get FLL reference clock frequency. */
 543:../drivers/fsl_clock.c ****     freq = CLOCK_GetFllRefClkFreq();
 1840              		.loc 2 543 12
 1841 0026 FFF7FEFF 		bl	CLOCK_GetFllRefClkFreq
 1842 002a 0300     		movs	r3, r0
 1843 002c 7B60     		str	r3, [r7, #4]
 544:../drivers/fsl_clock.c ****     if (!freq)
 1844              		.loc 2 544 8
 1845 002e 7B68     		ldr	r3, [r7, #4]
 1846 0030 002B     		cmp	r3, #0
 1847 0032 01D1     		bne	.L140
 545:../drivers/fsl_clock.c ****     {
 546:../drivers/fsl_clock.c ****         return freq;
 1848              		.loc 2 546 16
 1849 0034 7B68     		ldr	r3, [r7, #4]
 1850 0036 1DE0     		b	.L139
 1851              	.L140:
 547:../drivers/fsl_clock.c ****     }
 548:../drivers/fsl_clock.c **** 
 549:../drivers/fsl_clock.c ****     drs = MCG_C4_DRST_DRS_VAL;
 1852              		.loc 2 549 11
 1853 0038 104B     		ldr	r3, .L141
 1854 003a DB78     		ldrb	r3, [r3, #3]
 1855 003c DBB2     		uxtb	r3, r3
 1856 003e 5B09     		lsrs	r3, r3, #5
 1857 0040 DAB2     		uxtb	r2, r3
 1858              		.loc 2 549 9
 1859 0042 FB1C     		adds	r3, r7, #3
 1860 0044 0321     		movs	r1, #3
 1861 0046 0A40     		ands	r2, r1
 1862 0048 1A70     		strb	r2, [r3]
 550:../drivers/fsl_clock.c ****     dmx32 = MCG_C4_DMX32_VAL;
 1863              		.loc 2 550 13
 1864 004a 0C4B     		ldr	r3, .L141
 1865 004c DB78     		ldrb	r3, [r3, #3]
 1866 004e DBB2     		uxtb	r3, r3
 1867 0050 DB09     		lsrs	r3, r3, #7
 1868 0052 DAB2     		uxtb	r2, r3
 1869              		.loc 2 550 11
 1870 0054 BB1C     		adds	r3, r7, #2
 1871 0056 0121     		movs	r1, #1
 1872 0058 0A40     		ands	r2, r1
 1873 005a 1A70     		strb	r2, [r3]
 551:../drivers/fsl_clock.c **** 
 552:../drivers/fsl_clock.c ****     return freq * fllFactorTable[drs][dmx32];
 1874              		.loc 2 552 38
 1875 005c FB1C     		adds	r3, r7, #3
 1876 005e 1978     		ldrb	r1, [r3]
 1877 0060 BB1C     		adds	r3, r7, #2
 1878 0062 1A78     		ldrb	r2, [r3]
 1879 0064 064B     		ldr	r3, .L141+4
 1880 0066 4900     		lsls	r1, r1, #1
 1881 0068 8A18     		adds	r2, r1, r2
 1882 006a 5200     		lsls	r2, r2, #1
 1883 006c D35A     		ldrh	r3, [r2, r3]
 1884 006e 1A00     		movs	r2, r3
 1885              		.loc 2 552 17
 1886 0070 7B68     		ldr	r3, [r7, #4]
 1887 0072 5343     		muls	r3, r2
 1888              	.L139:
 553:../drivers/fsl_clock.c **** }
 1889              		.loc 2 553 1
 1890 0074 1800     		movs	r0, r3
 1891 0076 BD46     		mov	sp, r7
 1892 0078 02B0     		add	sp, sp, #8
 1893              		@ sp needed
 1894 007a 80BD     		pop	{r7, pc}
 1895              	.L142:
 1896              		.align	2
 1897              	.L141:
 1898 007c 00400640 		.word	1074151424
 1899 0080 00000000 		.word	fllFactorTable.5210
 1900              		.cfi_endproc
 1901              	.LFE74:
 1903              		.section	.text.CLOCK_GetInternalRefClkFreq,"ax",%progbits
 1904              		.align	1
 1905              		.global	CLOCK_GetInternalRefClkFreq
 1906              		.syntax unified
 1907              		.code	16
 1908              		.thumb_func
 1909              		.fpu softvfp
 1911              	CLOCK_GetInternalRefClkFreq:
 1912              	.LFB75:
 554:../drivers/fsl_clock.c **** 
 555:../drivers/fsl_clock.c **** uint32_t CLOCK_GetInternalRefClkFreq(void)
 556:../drivers/fsl_clock.c **** {
 1913              		.loc 2 556 1
 1914              		.cfi_startproc
 1915              		@ args = 0, pretend = 0, frame = 0
 1916              		@ frame_needed = 1, uses_anonymous_args = 0
 1917 0000 80B5     		push	{r7, lr}
 1918              		.cfi_def_cfa_offset 8
 1919              		.cfi_offset 7, -8
 1920              		.cfi_offset 14, -4
 1921 0002 00AF     		add	r7, sp, #0
 1922              		.cfi_def_cfa_register 7
 557:../drivers/fsl_clock.c ****     /* If MCGIRCLK is gated. */
 558:../drivers/fsl_clock.c ****     if (!(MCG->C1 & MCG_C1_IRCLKEN_MASK))
 1923              		.loc 2 558 14
 1924 0004 074B     		ldr	r3, .L146
 1925 0006 1B78     		ldrb	r3, [r3]
 1926 0008 DBB2     		uxtb	r3, r3
 1927              		.loc 2 558 19
 1928 000a 1A00     		movs	r2, r3
 1929 000c 0223     		movs	r3, #2
 1930 000e 1340     		ands	r3, r2
 1931              		.loc 2 558 8
 1932 0010 01D1     		bne	.L144
 559:../drivers/fsl_clock.c ****     {
 560:../drivers/fsl_clock.c ****         return 0U;
 1933              		.loc 2 560 16
 1934 0012 0023     		movs	r3, #0
 1935 0014 02E0     		b	.L145
 1936              	.L144:
 561:../drivers/fsl_clock.c ****     }
 562:../drivers/fsl_clock.c **** 
 563:../drivers/fsl_clock.c ****     return CLOCK_GetInternalRefClkSelectFreq();
 1937              		.loc 2 563 12
 1938 0016 FFF7FEFF 		bl	CLOCK_GetInternalRefClkSelectFreq
 1939 001a 0300     		movs	r3, r0
 1940              	.L145:
 564:../drivers/fsl_clock.c **** }
 1941              		.loc 2 564 1
 1942 001c 1800     		movs	r0, r3
 1943 001e BD46     		mov	sp, r7
 1944              		@ sp needed
 1945 0020 80BD     		pop	{r7, pc}
 1946              	.L147:
 1947 0022 C046     		.align	2
 1948              	.L146:
 1949 0024 00400640 		.word	1074151424
 1950              		.cfi_endproc
 1951              	.LFE75:
 1953              		.section	.text.CLOCK_GetFixedFreqClkFreq,"ax",%progbits
 1954              		.align	1
 1955              		.global	CLOCK_GetFixedFreqClkFreq
 1956              		.syntax unified
 1957              		.code	16
 1958              		.thumb_func
 1959              		.fpu softvfp
 1961              	CLOCK_GetFixedFreqClkFreq:
 1962              	.LFB76:
 565:../drivers/fsl_clock.c **** 
 566:../drivers/fsl_clock.c **** uint32_t CLOCK_GetFixedFreqClkFreq(void)
 567:../drivers/fsl_clock.c **** {
 1963              		.loc 2 567 1
 1964              		.cfi_startproc
 1965              		@ args = 0, pretend = 0, frame = 8
 1966              		@ frame_needed = 1, uses_anonymous_args = 0
 1967 0000 80B5     		push	{r7, lr}
 1968              		.cfi_def_cfa_offset 8
 1969              		.cfi_offset 7, -8
 1970              		.cfi_offset 14, -4
 1971 0002 82B0     		sub	sp, sp, #8
 1972              		.cfi_def_cfa_offset 16
 1973 0004 00AF     		add	r7, sp, #0
 1974              		.cfi_def_cfa_register 7
 568:../drivers/fsl_clock.c ****     uint32_t freq = CLOCK_GetFllRefClkFreq();
 1975              		.loc 2 568 21
 1976 0006 FFF7FEFF 		bl	CLOCK_GetFllRefClkFreq
 1977 000a 0300     		movs	r3, r0
 1978 000c 7B60     		str	r3, [r7, #4]
 569:../drivers/fsl_clock.c **** 
 570:../drivers/fsl_clock.c ****     /* MCGFFCLK must be no more than MCGOUTCLK/8. */
 571:../drivers/fsl_clock.c ****     if ((freq) && (freq <= (CLOCK_GetOutClkFreq() / 8U)))
 1979              		.loc 2 571 8
 1980 000e 7B68     		ldr	r3, [r7, #4]
 1981 0010 002B     		cmp	r3, #0
 1982 0012 08D0     		beq	.L149
 1983              		.loc 2 571 29 discriminator 1
 1984 0014 FFF7FEFF 		bl	CLOCK_GetOutClkFreq
 1985 0018 0300     		movs	r3, r0
 1986              		.loc 2 571 51 discriminator 1
 1987 001a DB08     		lsrs	r3, r3, #3
 1988              		.loc 2 571 16 discriminator 1
 1989 001c 7A68     		ldr	r2, [r7, #4]
 1990 001e 9A42     		cmp	r2, r3
 1991 0020 01D8     		bhi	.L149
 572:../drivers/fsl_clock.c ****     {
 573:../drivers/fsl_clock.c ****         return freq;
 1992              		.loc 2 573 16
 1993 0022 7B68     		ldr	r3, [r7, #4]
 1994 0024 00E0     		b	.L150
 1995              	.L149:
 574:../drivers/fsl_clock.c ****     }
 575:../drivers/fsl_clock.c ****     else
 576:../drivers/fsl_clock.c ****     {
 577:../drivers/fsl_clock.c ****         return 0U;
 1996              		.loc 2 577 16
 1997 0026 0023     		movs	r3, #0
 1998              	.L150:
 578:../drivers/fsl_clock.c ****     }
 579:../drivers/fsl_clock.c **** }
 1999              		.loc 2 579 1
 2000 0028 1800     		movs	r0, r3
 2001 002a BD46     		mov	sp, r7
 2002 002c 02B0     		add	sp, sp, #8
 2003              		@ sp needed
 2004 002e 80BD     		pop	{r7, pc}
 2005              		.cfi_endproc
 2006              	.LFE76:
 2008              		.section	.rodata.CLOCK_GetPll0Freq.str1.4,"aMS",%progbits,1
 2009              		.align	2
 2010              	.LC14:
 2011 0000 2E66736C 		.ascii	".fsl_clock.c:597 : mcgpll0clk\000"
 2011      5F636C6F 
 2011      636B2E63 
 2011      3A353937 
 2011      203A206D 
 2012              		.section	.text.CLOCK_GetPll0Freq,"ax",%progbits
 2013              		.align	1
 2014              		.global	CLOCK_GetPll0Freq
 2015              		.syntax unified
 2016              		.code	16
 2017              		.thumb_func
 2018              		.fpu softvfp
 2020              	CLOCK_GetPll0Freq:
 2021              	.LFB77:
 580:../drivers/fsl_clock.c **** 
 581:../drivers/fsl_clock.c **** uint32_t CLOCK_GetPll0Freq(void)
 582:../drivers/fsl_clock.c **** {
 2022              		.loc 2 582 1
 2023              		.cfi_startproc
 2024              		@ args = 0, pretend = 0, frame = 8
 2025              		@ frame_needed = 1, uses_anonymous_args = 0
 2026 0000 80B5     		push	{r7, lr}
 2027              		.cfi_def_cfa_offset 8
 2028              		.cfi_offset 7, -8
 2029              		.cfi_offset 14, -4
 2030 0002 82B0     		sub	sp, sp, #8
 2031              		.cfi_def_cfa_offset 16
 2032 0004 00AF     		add	r7, sp, #0
 2033              		.cfi_def_cfa_register 7
 583:../drivers/fsl_clock.c ****     uint32_t mcgpll0clk;
 584:../drivers/fsl_clock.c **** 
 585:../drivers/fsl_clock.c ****     /* If PLL0 is not enabled, return 0. */
 586:../drivers/fsl_clock.c ****     if (!(MCG->S & MCG_S_LOCK0_MASK))
 2034              		.loc 2 586 14
 2035 0006 184B     		ldr	r3, .L155
 2036 0008 9B79     		ldrb	r3, [r3, #6]
 2037 000a DBB2     		uxtb	r3, r3
 2038              		.loc 2 586 18
 2039 000c 1A00     		movs	r2, r3
 2040 000e 4023     		movs	r3, #64
 2041 0010 1340     		ands	r3, r2
 2042              		.loc 2 586 8
 2043 0012 01D1     		bne	.L152
 587:../drivers/fsl_clock.c ****     {
 588:../drivers/fsl_clock.c ****         return 0U;
 2044              		.loc 2 588 16
 2045 0014 0023     		movs	r3, #0
 2046 0016 23E0     		b	.L153
 2047              	.L152:
 589:../drivers/fsl_clock.c ****     }
 590:../drivers/fsl_clock.c **** 
 591:../drivers/fsl_clock.c ****     mcgpll0clk = CLOCK_GetPll0RefFreq();
 2048              		.loc 2 591 18
 2049 0018 FFF7FEFF 		bl	CLOCK_GetPll0RefFreq
 2050 001c 0300     		movs	r3, r0
 2051 001e 7B60     		str	r3, [r7, #4]
 592:../drivers/fsl_clock.c **** 
 593:../drivers/fsl_clock.c ****     /*
 594:../drivers/fsl_clock.c ****      * Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock.
 595:../drivers/fsl_clock.c ****      * Please call CLOCK_SetXtal1Freq base on board setting before using OSC1 clock.
 596:../drivers/fsl_clock.c ****      */
 597:../drivers/fsl_clock.c ****     assert(mcgpll0clk);
 2052              		.loc 2 597 5
 2053 0020 7B68     		ldr	r3, [r7, #4]
 2054 0022 002B     		cmp	r3, #0
 2055 0024 03D1     		bne	.L154
 2056              		.loc 2 597 5 is_stmt 0 discriminator 1
 2057 0026 114B     		ldr	r3, .L155+4
 2058 0028 1800     		movs	r0, r3
 2059 002a FFF7FEFF 		bl	__assertion_failed
 2060              	.L154:
 598:../drivers/fsl_clock.c **** 
 599:../drivers/fsl_clock.c ****     mcgpll0clk /= (FSL_FEATURE_MCG_PLL_PRDIV_BASE + MCG_C5_PRDIV0_VAL);
 2061              		.loc 2 599 53 is_stmt 1
 2062 002e 0E4B     		ldr	r3, .L155
 2063 0030 1B79     		ldrb	r3, [r3, #4]
 2064 0032 DBB2     		uxtb	r3, r3
 2065 0034 1A00     		movs	r2, r3
 2066 0036 1F23     		movs	r3, #31
 2067 0038 1340     		ands	r3, r2
 2068              		.loc 2 599 51
 2069 003a 0133     		adds	r3, r3, #1
 2070              		.loc 2 599 16
 2071 003c 1900     		movs	r1, r3
 2072 003e 7868     		ldr	r0, [r7, #4]
 2073 0040 FFF7FEFF 		bl	__aeabi_uidiv
 2074              	.LVL11:
 2075 0044 0300     		movs	r3, r0
 2076 0046 7B60     		str	r3, [r7, #4]
 600:../drivers/fsl_clock.c ****     mcgpll0clk *= (FSL_FEATURE_MCG_PLL_VDIV_BASE + MCG_C6_VDIV0_VAL);
 2077              		.loc 2 600 52
 2078 0048 074B     		ldr	r3, .L155
 2079 004a 5B79     		ldrb	r3, [r3, #5]
 2080 004c DBB2     		uxtb	r3, r3
 2081 004e 1A00     		movs	r2, r3
 2082 0050 1F23     		movs	r3, #31
 2083 0052 1340     		ands	r3, r2
 2084              		.loc 2 600 50
 2085 0054 1833     		adds	r3, r3, #24
 2086 0056 1A00     		movs	r2, r3
 2087              		.loc 2 600 16
 2088 0058 7B68     		ldr	r3, [r7, #4]
 2089 005a 5343     		muls	r3, r2
 2090 005c 7B60     		str	r3, [r7, #4]
 601:../drivers/fsl_clock.c **** 
 602:../drivers/fsl_clock.c ****     return mcgpll0clk;
 2091              		.loc 2 602 12
 2092 005e 7B68     		ldr	r3, [r7, #4]
 2093              	.L153:
 603:../drivers/fsl_clock.c **** }
 2094              		.loc 2 603 1
 2095 0060 1800     		movs	r0, r3
 2096 0062 BD46     		mov	sp, r7
 2097 0064 02B0     		add	sp, sp, #8
 2098              		@ sp needed
 2099 0066 80BD     		pop	{r7, pc}
 2100              	.L156:
 2101              		.align	2
 2102              	.L155:
 2103 0068 00400640 		.word	1074151424
 2104 006c 00000000 		.word	.LC14
 2105              		.cfi_endproc
 2106              	.LFE77:
 2108              		.section	.text.CLOCK_SetExternalRefClkConfig,"ax",%progbits
 2109              		.align	1
 2110              		.global	CLOCK_SetExternalRefClkConfig
 2111              		.syntax unified
 2112              		.code	16
 2113              		.thumb_func
 2114              		.fpu softvfp
 2116              	CLOCK_SetExternalRefClkConfig:
 2117              	.LFB78:
 604:../drivers/fsl_clock.c **** 
 605:../drivers/fsl_clock.c **** status_t CLOCK_SetExternalRefClkConfig(mcg_oscsel_t oscsel)
 606:../drivers/fsl_clock.c **** {
 2118              		.loc 2 606 1
 2119              		.cfi_startproc
 2120              		@ args = 0, pretend = 0, frame = 8
 2121              		@ frame_needed = 1, uses_anonymous_args = 0
 2122 0000 80B5     		push	{r7, lr}
 2123              		.cfi_def_cfa_offset 8
 2124              		.cfi_offset 7, -8
 2125              		.cfi_offset 14, -4
 2126 0002 82B0     		sub	sp, sp, #8
 2127              		.cfi_def_cfa_offset 16
 2128 0004 00AF     		add	r7, sp, #0
 2129              		.cfi_def_cfa_register 7
 2130 0006 0200     		movs	r2, r0
 2131 0008 FB1D     		adds	r3, r7, #7
 2132 000a 1A70     		strb	r2, [r3]
 607:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
 608:../drivers/fsl_clock.c **** #endif /* MCG_CONFIG_CHECK_PARAM */
 609:../drivers/fsl_clock.c **** 
 610:../drivers/fsl_clock.c ****     return kStatus_Success;
 2133              		.loc 2 610 12
 2134 000c 0023     		movs	r3, #0
 611:../drivers/fsl_clock.c **** }
 2135              		.loc 2 611 1
 2136 000e 1800     		movs	r0, r3
 2137 0010 BD46     		mov	sp, r7
 2138 0012 02B0     		add	sp, sp, #8
 2139              		@ sp needed
 2140 0014 80BD     		pop	{r7, pc}
 2141              		.cfi_endproc
 2142              	.LFE78:
 2144              		.section	.text.CLOCK_SetInternalRefClkConfig,"ax",%progbits
 2145              		.align	1
 2146              		.global	CLOCK_SetInternalRefClkConfig
 2147              		.syntax unified
 2148              		.code	16
 2149              		.thumb_func
 2150              		.fpu softvfp
 2152              	CLOCK_SetInternalRefClkConfig:
 2153              	.LFB79:
 612:../drivers/fsl_clock.c **** 
 613:../drivers/fsl_clock.c **** status_t CLOCK_SetInternalRefClkConfig(uint8_t enableMode, mcg_irc_mode_t ircs, uint8_t fcrdiv)
 614:../drivers/fsl_clock.c **** {
 2154              		.loc 2 614 1
 2155              		.cfi_startproc
 2156              		@ args = 0, pretend = 0, frame = 16
 2157              		@ frame_needed = 1, uses_anonymous_args = 0
 2158 0000 90B5     		push	{r4, r7, lr}
 2159              		.cfi_def_cfa_offset 12
 2160              		.cfi_offset 4, -12
 2161              		.cfi_offset 7, -8
 2162              		.cfi_offset 14, -4
 2163 0002 85B0     		sub	sp, sp, #20
 2164              		.cfi_def_cfa_offset 32
 2165 0004 00AF     		add	r7, sp, #0
 2166              		.cfi_def_cfa_register 7
 2167 0006 0400     		movs	r4, r0
 2168 0008 0800     		movs	r0, r1
 2169 000a 1100     		movs	r1, r2
 2170 000c FB1D     		adds	r3, r7, #7
 2171 000e 221C     		adds	r2, r4, #0
 2172 0010 1A70     		strb	r2, [r3]
 2173 0012 BB1D     		adds	r3, r7, #6
 2174 0014 021C     		adds	r2, r0, #0
 2175 0016 1A70     		strb	r2, [r3]
 2176 0018 7B1D     		adds	r3, r7, #5
 2177 001a 0A1C     		adds	r2, r1, #0
 2178 001c 1A70     		strb	r2, [r3]
 615:../drivers/fsl_clock.c ****     uint32_t mcgOutClkState = MCG_S_CLKST_VAL;
 2179              		.loc 2 615 31
 2180 001e 404B     		ldr	r3, .L169
 2181 0020 9B79     		ldrb	r3, [r3, #6]
 2182 0022 DBB2     		uxtb	r3, r3
 2183 0024 9B08     		lsrs	r3, r3, #2
 2184              		.loc 2 615 14
 2185 0026 0322     		movs	r2, #3
 2186 0028 1340     		ands	r3, r2
 2187 002a FB60     		str	r3, [r7, #12]
 616:../drivers/fsl_clock.c ****     mcg_irc_mode_t curIrcs = (mcg_irc_mode_t)MCG_S_IRCST_VAL;
 2188              		.loc 2 616 46
 2189 002c 3C4B     		ldr	r3, .L169
 2190 002e 9B79     		ldrb	r3, [r3, #6]
 2191 0030 DAB2     		uxtb	r2, r3
 2192              		.loc 2 616 20
 2193 0032 0B20     		movs	r0, #11
 2194 0034 3B18     		adds	r3, r7, r0
 2195 0036 0121     		movs	r1, #1
 2196 0038 0A40     		ands	r2, r1
 2197 003a 1A70     		strb	r2, [r3]
 617:../drivers/fsl_clock.c ****     uint8_t curFcrdiv = MCG_SC_FCRDIV_VAL;
 2198              		.loc 2 617 25
 2199 003c 384B     		ldr	r3, .L169
 2200 003e 1B7A     		ldrb	r3, [r3, #8]
 2201 0040 DBB2     		uxtb	r3, r3
 2202 0042 5B08     		lsrs	r3, r3, #1
 2203 0044 DAB2     		uxtb	r2, r3
 2204              		.loc 2 617 13
 2205 0046 0A24     		movs	r4, #10
 2206 0048 3B19     		adds	r3, r7, r4
 2207 004a 0721     		movs	r1, #7
 2208 004c 0A40     		ands	r2, r1
 2209 004e 1A70     		strb	r2, [r3]
 618:../drivers/fsl_clock.c **** 
 619:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
 620:../drivers/fsl_clock.c ****     /* If MCGIRCLK is used as system clock source. */
 621:../drivers/fsl_clock.c ****     if (kMCG_ClkOutStatInt == mcgOutClkState)
 622:../drivers/fsl_clock.c ****     {
 623:../drivers/fsl_clock.c ****         /* If need to change MCGIRCLK source or driver, return error. */
 624:../drivers/fsl_clock.c ****         if (((kMCG_IrcFast == curIrcs) && (fcrdiv != curFcrdiv)) || (ircs != curIrcs))
 625:../drivers/fsl_clock.c ****         {
 626:../drivers/fsl_clock.c ****             return kStatus_MCG_SourceUsed;
 627:../drivers/fsl_clock.c ****         }
 628:../drivers/fsl_clock.c ****     }
 629:../drivers/fsl_clock.c **** #endif
 630:../drivers/fsl_clock.c **** 
 631:../drivers/fsl_clock.c ****     /* If need to update the FCRDIV. */
 632:../drivers/fsl_clock.c ****     if (fcrdiv != curFcrdiv)
 2210              		.loc 2 632 8
 2211 0050 7A1D     		adds	r2, r7, #5
 2212 0052 3B19     		adds	r3, r7, r4
 2213 0054 1278     		ldrb	r2, [r2]
 2214 0056 1B78     		ldrb	r3, [r3]
 2215 0058 9A42     		cmp	r2, r3
 2216 005a 2ED0     		beq	.L160
 633:../drivers/fsl_clock.c ****     {
 634:../drivers/fsl_clock.c ****         /* If fast IRC is in use currently, change to slow IRC. */
 635:../drivers/fsl_clock.c ****         if ((kMCG_IrcFast == curIrcs) && ((mcgOutClkState == kMCG_ClkOutStatInt) || (MCG->C1 & MCG_
 2217              		.loc 2 635 12
 2218 005c 3B18     		adds	r3, r7, r0
 2219 005e 1B78     		ldrb	r3, [r3]
 2220 0060 012B     		cmp	r3, #1
 2221 0062 19D1     		bne	.L161
 2222              		.loc 2 635 39 discriminator 1
 2223 0064 FB68     		ldr	r3, [r7, #12]
 2224 0066 012B     		cmp	r3, #1
 2225 0068 06D0     		beq	.L162
 2226              		.loc 2 635 89 discriminator 2
 2227 006a 2D4B     		ldr	r3, .L169
 2228 006c 1B78     		ldrb	r3, [r3]
 2229 006e DBB2     		uxtb	r3, r3
 2230              		.loc 2 635 94 discriminator 2
 2231 0070 1A00     		movs	r2, r3
 2232 0072 0223     		movs	r3, #2
 2233 0074 1340     		ands	r3, r2
 2234              		.loc 2 635 82 discriminator 2
 2235 0076 0FD0     		beq	.L161
 2236              	.L162:
 636:../drivers/fsl_clock.c ****         {
 637:../drivers/fsl_clock.c ****             MCG->C2 = ((MCG->C2 & ~MCG_C2_IRCS_MASK) | (MCG_C2_IRCS(kMCG_IrcSlow)));
 2237              		.loc 2 637 28
 2238 0078 294B     		ldr	r3, .L169
 2239 007a 5B78     		ldrb	r3, [r3, #1]
 2240 007c DBB2     		uxtb	r3, r3
 2241              		.loc 2 637 16
 2242 007e 284A     		ldr	r2, .L169
 2243              		.loc 2 637 54
 2244 0080 0121     		movs	r1, #1
 2245 0082 8B43     		bics	r3, r1
 2246 0084 DBB2     		uxtb	r3, r3
 2247              		.loc 2 637 21
 2248 0086 5370     		strb	r3, [r2, #1]
 638:../drivers/fsl_clock.c ****             while (MCG_S_IRCST_VAL != kMCG_IrcSlow)
 2249              		.loc 2 638 19
 2250 0088 C046     		nop
 2251              	.L163:
 2252              		.loc 2 638 20 discriminator 1
 2253 008a 254B     		ldr	r3, .L169
 2254 008c 9B79     		ldrb	r3, [r3, #6]
 2255 008e DBB2     		uxtb	r3, r3
 2256 0090 1A00     		movs	r2, r3
 2257 0092 0123     		movs	r3, #1
 2258 0094 1340     		ands	r3, r2
 2259              		.loc 2 638 19 discriminator 1
 2260 0096 F8D1     		bne	.L163
 2261              	.L161:
 639:../drivers/fsl_clock.c ****             {
 640:../drivers/fsl_clock.c ****             }
 641:../drivers/fsl_clock.c ****         }
 642:../drivers/fsl_clock.c ****         /* Update FCRDIV. */
 643:../drivers/fsl_clock.c ****         MCG->SC = (MCG->SC & ~(MCG_SC_FCRDIV_MASK | MCG_SC_ATMF_MASK | MCG_SC_LOCS0_MASK)) | MCG_SC
 2262              		.loc 2 643 23
 2263 0098 214B     		ldr	r3, .L169
 2264 009a 1B7A     		ldrb	r3, [r3, #8]
 2265 009c DBB2     		uxtb	r3, r3
 2266              		.loc 2 643 28
 2267 009e 2F22     		movs	r2, #47
 2268 00a0 9343     		bics	r3, r2
 2269 00a2 DAB2     		uxtb	r2, r3
 2270              		.loc 2 643 94
 2271 00a4 7B1D     		adds	r3, r7, #5
 2272 00a6 1B78     		ldrb	r3, [r3]
 2273 00a8 DB18     		adds	r3, r3, r3
 2274 00aa DBB2     		uxtb	r3, r3
 2275 00ac 0E21     		movs	r1, #14
 2276 00ae 0B40     		ands	r3, r1
 2277 00b0 DBB2     		uxtb	r3, r3
 2278              		.loc 2 643 12
 2279 00b2 1B49     		ldr	r1, .L169
 2280              		.loc 2 643 92
 2281 00b4 1343     		orrs	r3, r2
 2282 00b6 DBB2     		uxtb	r3, r3
 2283              		.loc 2 643 17
 2284 00b8 0B72     		strb	r3, [r1, #8]
 2285              	.L160:
 644:../drivers/fsl_clock.c ****     }
 645:../drivers/fsl_clock.c **** 
 646:../drivers/fsl_clock.c ****     /* Set internal reference clock selection. */
 647:../drivers/fsl_clock.c ****     MCG->C2 = (MCG->C2 & ~MCG_C2_IRCS_MASK) | (MCG_C2_IRCS(ircs));
 2286              		.loc 2 647 19
 2287 00ba 194B     		ldr	r3, .L169
 2288 00bc 5B78     		ldrb	r3, [r3, #1]
 2289 00be DBB2     		uxtb	r3, r3
 2290              		.loc 2 647 24
 2291 00c0 0122     		movs	r2, #1
 2292 00c2 9343     		bics	r3, r2
 2293 00c4 DAB2     		uxtb	r2, r3
 2294              		.loc 2 647 48
 2295 00c6 BB1D     		adds	r3, r7, #6
 2296 00c8 1B78     		ldrb	r3, [r3]
 2297 00ca 0121     		movs	r1, #1
 2298 00cc 0B40     		ands	r3, r1
 2299 00ce DBB2     		uxtb	r3, r3
 2300              		.loc 2 647 8
 2301 00d0 1349     		ldr	r1, .L169
 2302              		.loc 2 647 45
 2303 00d2 1343     		orrs	r3, r2
 2304 00d4 DBB2     		uxtb	r3, r3
 2305              		.loc 2 647 13
 2306 00d6 4B70     		strb	r3, [r1, #1]
 648:../drivers/fsl_clock.c ****     MCG->C1 = (MCG->C1 & ~(MCG_C1_IRCLKEN_MASK | MCG_C1_IREFSTEN_MASK)) | (uint8_t)enableMode;
 2307              		.loc 2 648 19
 2308 00d8 114B     		ldr	r3, .L169
 2309 00da 1B78     		ldrb	r3, [r3]
 2310 00dc DBB2     		uxtb	r3, r3
 2311              		.loc 2 648 24
 2312 00de 0322     		movs	r2, #3
 2313 00e0 9343     		bics	r3, r2
 2314 00e2 DAB2     		uxtb	r2, r3
 2315              		.loc 2 648 8
 2316 00e4 0E49     		ldr	r1, .L169
 2317              		.loc 2 648 73
 2318 00e6 FB1D     		adds	r3, r7, #7
 2319 00e8 1B78     		ldrb	r3, [r3]
 2320 00ea 1343     		orrs	r3, r2
 2321 00ec DBB2     		uxtb	r3, r3
 2322              		.loc 2 648 13
 2323 00ee 0B70     		strb	r3, [r1]
 649:../drivers/fsl_clock.c **** 
 650:../drivers/fsl_clock.c ****     /* If MCGIRCLK is used, need to wait for MCG_S_IRCST. */
 651:../drivers/fsl_clock.c ****     if ((mcgOutClkState == kMCG_ClkOutStatInt) || (enableMode & kMCG_IrclkEnable))
 2324              		.loc 2 651 8
 2325 00f0 FB68     		ldr	r3, [r7, #12]
 2326 00f2 012B     		cmp	r3, #1
 2327 00f4 04D0     		beq	.L168
 2328              		.loc 2 651 63 discriminator 1
 2329 00f6 FB1D     		adds	r3, r7, #7
 2330 00f8 1B78     		ldrb	r3, [r3]
 2331 00fa 0222     		movs	r2, #2
 2332 00fc 1340     		ands	r3, r2
 2333              		.loc 2 651 48 discriminator 1
 2334 00fe 0AD0     		beq	.L165
 2335              	.L168:
 652:../drivers/fsl_clock.c ****     {
 653:../drivers/fsl_clock.c ****         while (MCG_S_IRCST_VAL != ircs)
 2336              		.loc 2 653 15
 2337 0100 C046     		nop
 2338              	.L166:
 2339              		.loc 2 653 16 discriminator 1
 2340 0102 074B     		ldr	r3, .L169
 2341 0104 9B79     		ldrb	r3, [r3, #6]
 2342 0106 DBB2     		uxtb	r3, r3
 2343 0108 1A00     		movs	r2, r3
 2344 010a 0123     		movs	r3, #1
 2345 010c 1A40     		ands	r2, r3
 2346              		.loc 2 653 32 discriminator 1
 2347 010e BB1D     		adds	r3, r7, #6
 2348 0110 1B78     		ldrb	r3, [r3]
 2349              		.loc 2 653 15 discriminator 1
 2350 0112 9A42     		cmp	r2, r3
 2351 0114 F5D1     		bne	.L166
 2352              	.L165:
 654:../drivers/fsl_clock.c ****         {
 655:../drivers/fsl_clock.c ****         }
 656:../drivers/fsl_clock.c ****     }
 657:../drivers/fsl_clock.c **** 
 658:../drivers/fsl_clock.c ****     return kStatus_Success;
 2353              		.loc 2 658 12
 2354 0116 0023     		movs	r3, #0
 659:../drivers/fsl_clock.c **** }
 2355              		.loc 2 659 1
 2356 0118 1800     		movs	r0, r3
 2357 011a BD46     		mov	sp, r7
 2358 011c 05B0     		add	sp, sp, #20
 2359              		@ sp needed
 2360 011e 90BD     		pop	{r4, r7, pc}
 2361              	.L170:
 2362              		.align	2
 2363              	.L169:
 2364 0120 00400640 		.word	1074151424
 2365              		.cfi_endproc
 2366              	.LFE79:
 2368              		.section	.text.CLOCK_CalcPllDiv,"ax",%progbits
 2369              		.align	1
 2370              		.global	CLOCK_CalcPllDiv
 2371              		.syntax unified
 2372              		.code	16
 2373              		.thumb_func
 2374              		.fpu softvfp
 2376              	CLOCK_CalcPllDiv:
 2377              	.LFB80:
 660:../drivers/fsl_clock.c **** 
 661:../drivers/fsl_clock.c **** uint32_t CLOCK_CalcPllDiv(uint32_t refFreq, uint32_t desireFreq, uint8_t *prdiv, uint8_t *vdiv)
 662:../drivers/fsl_clock.c **** {
 2378              		.loc 2 662 1
 2379              		.cfi_startproc
 2380              		@ args = 0, pretend = 0, frame = 40
 2381              		@ frame_needed = 1, uses_anonymous_args = 0
 2382 0000 90B5     		push	{r4, r7, lr}
 2383              		.cfi_def_cfa_offset 12
 2384              		.cfi_offset 4, -12
 2385              		.cfi_offset 7, -8
 2386              		.cfi_offset 14, -4
 2387 0002 8BB0     		sub	sp, sp, #44
 2388              		.cfi_def_cfa_offset 56
 2389 0004 00AF     		add	r7, sp, #0
 2390              		.cfi_def_cfa_register 7
 2391 0006 F860     		str	r0, [r7, #12]
 2392 0008 B960     		str	r1, [r7, #8]
 2393 000a 7A60     		str	r2, [r7, #4]
 2394 000c 3B60     		str	r3, [r7]
 663:../drivers/fsl_clock.c ****     uint8_t ret_prdiv;           /* PRDIV to return. */
 664:../drivers/fsl_clock.c ****     uint8_t ret_vdiv;            /* VDIV to return.  */
 665:../drivers/fsl_clock.c ****     uint8_t prdiv_min;           /* Min PRDIV value to make reference clock in allowed range. */
 666:../drivers/fsl_clock.c ****     uint8_t prdiv_max;           /* Max PRDIV value to make reference clock in allowed range. */
 667:../drivers/fsl_clock.c ****     uint8_t prdiv_cur;           /* PRDIV value for iteration.    */
 668:../drivers/fsl_clock.c ****     uint8_t vdiv_cur;            /* VDIV value for iteration.     */
 669:../drivers/fsl_clock.c ****     uint32_t ret_freq = 0U;      /* PLL output fequency to return. */
 2395              		.loc 2 669 14
 2396 000e 0023     		movs	r3, #0
 2397 0010 FB61     		str	r3, [r7, #28]
 670:../drivers/fsl_clock.c ****     uint32_t diff = 0xFFFFFFFFU; /* Difference between desireFreq and return frequency. */
 2398              		.loc 2 670 14
 2399 0012 0123     		movs	r3, #1
 2400 0014 5B42     		rsbs	r3, r3, #0
 2401 0016 3B62     		str	r3, [r7, #32]
 671:../drivers/fsl_clock.c ****     uint32_t ref_div;            /* Reference frequency after PRDIV. */
 672:../drivers/fsl_clock.c **** 
 673:../drivers/fsl_clock.c ****     /*
 674:../drivers/fsl_clock.c ****        Steps:
 675:../drivers/fsl_clock.c ****        1. Get allowed prdiv with such rules:
 676:../drivers/fsl_clock.c ****           1). refFreq / prdiv >= FSL_FEATURE_MCG_PLL_REF_MIN.
 677:../drivers/fsl_clock.c ****           2). refFreq / prdiv <= FSL_FEATURE_MCG_PLL_REF_MAX.
 678:../drivers/fsl_clock.c ****        2. For each allowed prdiv, there are two candidate vdiv values:
 679:../drivers/fsl_clock.c ****           1). (desireFreq / (refFreq / prdiv)).
 680:../drivers/fsl_clock.c ****           2). (desireFreq / (refFreq / prdiv)) + 1.
 681:../drivers/fsl_clock.c ****           If could get the precise desired frequency, return current prdiv and
 682:../drivers/fsl_clock.c ****           vdiv directly. Otherwise choose the one which is closer to desired
 683:../drivers/fsl_clock.c ****           frequency.
 684:../drivers/fsl_clock.c ****      */
 685:../drivers/fsl_clock.c **** 
 686:../drivers/fsl_clock.c ****     /* Reference frequency is out of range. */
 687:../drivers/fsl_clock.c ****     if ((refFreq < FSL_FEATURE_MCG_PLL_REF_MIN) ||
 2402              		.loc 2 687 8
 2403 0018 FB68     		ldr	r3, [r7, #12]
 2404 001a 644A     		ldr	r2, .L184
 2405 001c 9342     		cmp	r3, r2
 2406 001e 03D9     		bls	.L172
 2407              		.loc 2 687 49 discriminator 1
 2408 0020 FB68     		ldr	r3, [r7, #12]
 2409 0022 634A     		ldr	r2, .L184+4
 2410 0024 9342     		cmp	r3, r2
 2411 0026 01D9     		bls	.L173
 2412              	.L172:
 688:../drivers/fsl_clock.c ****         (refFreq > (FSL_FEATURE_MCG_PLL_REF_MAX * (FSL_FEATURE_MCG_PLL_PRDIV_MAX + FSL_FEATURE_MCG_
 689:../drivers/fsl_clock.c ****     {
 690:../drivers/fsl_clock.c ****         return 0U;
 2413              		.loc 2 690 16
 2414 0028 0023     		movs	r3, #0
 2415 002a BAE0     		b	.L174
 2416              	.L173:
 691:../drivers/fsl_clock.c ****     }
 692:../drivers/fsl_clock.c **** 
 693:../drivers/fsl_clock.c ****     /* refFreq/PRDIV must in a range. First get the allowed PRDIV range. */
 694:../drivers/fsl_clock.c ****     prdiv_max = refFreq / FSL_FEATURE_MCG_PLL_REF_MIN;
 2417              		.loc 2 694 25
 2418 002c FB68     		ldr	r3, [r7, #12]
 2419 002e 6149     		ldr	r1, .L184+8
 2420 0030 1800     		movs	r0, r3
 2421 0032 FFF7FEFF 		bl	__aeabi_uidiv
 2422              	.LVL12:
 2423 0036 0300     		movs	r3, r0
 2424 0038 1A00     		movs	r2, r3
 2425              		.loc 2 694 15
 2426 003a 1B24     		movs	r4, #27
 2427 003c 3B19     		adds	r3, r7, r4
 2428 003e 1A70     		strb	r2, [r3]
 695:../drivers/fsl_clock.c ****     prdiv_min = (refFreq + FSL_FEATURE_MCG_PLL_REF_MAX - 1U) / FSL_FEATURE_MCG_PLL_REF_MAX;
 2429              		.loc 2 695 56
 2430 0040 FB68     		ldr	r3, [r7, #12]
 2431 0042 5D4A     		ldr	r2, .L184+12
 2432 0044 9446     		mov	ip, r2
 2433 0046 6344     		add	r3, r3, ip
 2434              		.loc 2 695 62
 2435 0048 5C49     		ldr	r1, .L184+16
 2436 004a 1800     		movs	r0, r3
 2437 004c FFF7FEFF 		bl	__aeabi_uidiv
 2438              	.LVL13:
 2439 0050 0300     		movs	r3, r0
 2440 0052 1A00     		movs	r2, r3
 2441              		.loc 2 695 15
 2442 0054 1A23     		movs	r3, #26
 2443 0056 FB18     		adds	r3, r7, r3
 2444 0058 1A70     		strb	r2, [r3]
 696:../drivers/fsl_clock.c **** 
 697:../drivers/fsl_clock.c ****     /* PRDIV traversal. */
 698:../drivers/fsl_clock.c ****     for (prdiv_cur = prdiv_max; prdiv_cur >= prdiv_min; prdiv_cur--)
 2445              		.loc 2 698 20
 2446 005a 2523     		movs	r3, #37
 2447 005c FB18     		adds	r3, r7, r3
 2448 005e 3A19     		adds	r2, r7, r4
 2449 0060 1278     		ldrb	r2, [r2]
 2450 0062 1A70     		strb	r2, [r3]
 2451              		.loc 2 698 5
 2452 0064 75E0     		b	.L175
 2453              	.L181:
 699:../drivers/fsl_clock.c ****     {
 700:../drivers/fsl_clock.c ****         /* Reference frequency after PRDIV. */
 701:../drivers/fsl_clock.c ****         ref_div = refFreq / prdiv_cur;
 2454              		.loc 2 701 27
 2455 0066 2524     		movs	r4, #37
 2456 0068 3B19     		adds	r3, r7, r4
 2457 006a 1B78     		ldrb	r3, [r3]
 2458              		.loc 2 701 17
 2459 006c 1900     		movs	r1, r3
 2460 006e F868     		ldr	r0, [r7, #12]
 2461 0070 FFF7FEFF 		bl	__aeabi_uidiv
 2462              	.LVL14:
 2463 0074 0300     		movs	r3, r0
 2464 0076 7B61     		str	r3, [r7, #20]
 702:../drivers/fsl_clock.c **** 
 703:../drivers/fsl_clock.c ****         vdiv_cur = desireFreq / ref_div;
 2465              		.loc 2 703 31
 2466 0078 7969     		ldr	r1, [r7, #20]
 2467 007a B868     		ldr	r0, [r7, #8]
 2468 007c FFF7FEFF 		bl	__aeabi_uidiv
 2469              	.LVL15:
 2470 0080 0300     		movs	r3, r0
 2471 0082 1A00     		movs	r2, r3
 2472              		.loc 2 703 18
 2473 0084 1321     		movs	r1, #19
 2474 0086 7B18     		adds	r3, r7, r1
 2475 0088 1A70     		strb	r2, [r3]
 704:../drivers/fsl_clock.c **** 
 705:../drivers/fsl_clock.c ****         if ((vdiv_cur < FSL_FEATURE_MCG_PLL_VDIV_BASE - 1U) || (vdiv_cur > FSL_FEATURE_MCG_PLL_VDIV
 2476              		.loc 2 705 12
 2477 008a 7B18     		adds	r3, r7, r1
 2478 008c 1B78     		ldrb	r3, [r3]
 2479 008e 162B     		cmp	r3, #22
 2480 0090 58D9     		bls	.L183
 2481              		.loc 2 705 61 discriminator 1
 2482 0092 7B18     		adds	r3, r7, r1
 2483 0094 1B78     		ldrb	r3, [r3]
 2484 0096 372B     		cmp	r3, #55
 2485 0098 54D8     		bhi	.L183
 706:../drivers/fsl_clock.c ****         {
 707:../drivers/fsl_clock.c ****             /* No VDIV is available with this PRDIV. */
 708:../drivers/fsl_clock.c ****             continue;
 709:../drivers/fsl_clock.c ****         }
 710:../drivers/fsl_clock.c **** 
 711:../drivers/fsl_clock.c ****         ret_freq = vdiv_cur * ref_div;
 2486              		.loc 2 711 29
 2487 009a 7B18     		adds	r3, r7, r1
 2488 009c 1A78     		ldrb	r2, [r3]
 2489              		.loc 2 711 18
 2490 009e 7B69     		ldr	r3, [r7, #20]
 2491 00a0 5343     		muls	r3, r2
 2492 00a2 FB61     		str	r3, [r7, #28]
 712:../drivers/fsl_clock.c **** 
 713:../drivers/fsl_clock.c ****         if (vdiv_cur >= FSL_FEATURE_MCG_PLL_VDIV_BASE)
 2493              		.loc 2 713 12
 2494 00a4 7B18     		adds	r3, r7, r1
 2495 00a6 1B78     		ldrb	r3, [r3]
 2496 00a8 172B     		cmp	r3, #23
 2497 00aa 27D9     		bls	.L179
 714:../drivers/fsl_clock.c ****         {
 715:../drivers/fsl_clock.c ****             if (ret_freq == desireFreq) /* If desire frequency is got. */
 2498              		.loc 2 715 16
 2499 00ac FA69     		ldr	r2, [r7, #28]
 2500 00ae BB68     		ldr	r3, [r7, #8]
 2501 00b0 9A42     		cmp	r2, r3
 2502 00b2 0DD1     		bne	.L180
 716:../drivers/fsl_clock.c ****             {
 717:../drivers/fsl_clock.c ****                 *prdiv = prdiv_cur - FSL_FEATURE_MCG_PLL_PRDIV_BASE;
 2503              		.loc 2 717 36
 2504 00b4 3B19     		adds	r3, r7, r4
 2505 00b6 1B78     		ldrb	r3, [r3]
 2506 00b8 013B     		subs	r3, r3, #1
 2507 00ba DAB2     		uxtb	r2, r3
 2508              		.loc 2 717 24
 2509 00bc 7B68     		ldr	r3, [r7, #4]
 2510 00be 1A70     		strb	r2, [r3]
 718:../drivers/fsl_clock.c ****                 *vdiv = vdiv_cur - FSL_FEATURE_MCG_PLL_VDIV_BASE;
 2511              		.loc 2 718 34
 2512 00c0 7B18     		adds	r3, r7, r1
 2513 00c2 1B78     		ldrb	r3, [r3]
 2514 00c4 183B     		subs	r3, r3, #24
 2515 00c6 DAB2     		uxtb	r2, r3
 2516              		.loc 2 718 23
 2517 00c8 3B68     		ldr	r3, [r7]
 2518 00ca 1A70     		strb	r2, [r3]
 719:../drivers/fsl_clock.c ****                 return ret_freq;
 2519              		.loc 2 719 24
 2520 00cc FB69     		ldr	r3, [r7, #28]
 2521 00ce 68E0     		b	.L174
 2522              	.L180:
 720:../drivers/fsl_clock.c ****             }
 721:../drivers/fsl_clock.c ****             /* New PRDIV/VDIV is closer. */
 722:../drivers/fsl_clock.c ****             if (diff > desireFreq - ret_freq)
 2523              		.loc 2 722 35
 2524 00d0 BA68     		ldr	r2, [r7, #8]
 2525 00d2 FB69     		ldr	r3, [r7, #28]
 2526 00d4 D31A     		subs	r3, r2, r3
 2527              		.loc 2 722 16
 2528 00d6 3A6A     		ldr	r2, [r7, #32]
 2529 00d8 9A42     		cmp	r2, r3
 2530 00da 0FD9     		bls	.L179
 723:../drivers/fsl_clock.c ****             {
 724:../drivers/fsl_clock.c ****                 diff = desireFreq - ret_freq;
 2531              		.loc 2 724 22
 2532 00dc BA68     		ldr	r2, [r7, #8]
 2533 00de FB69     		ldr	r3, [r7, #28]
 2534 00e0 D31A     		subs	r3, r2, r3
 2535 00e2 3B62     		str	r3, [r7, #32]
 725:../drivers/fsl_clock.c ****                 ret_prdiv = prdiv_cur;
 2536              		.loc 2 725 27
 2537 00e4 2723     		movs	r3, #39
 2538 00e6 FB18     		adds	r3, r7, r3
 2539 00e8 2522     		movs	r2, #37
 2540 00ea BA18     		adds	r2, r7, r2
 2541 00ec 1278     		ldrb	r2, [r2]
 2542 00ee 1A70     		strb	r2, [r3]
 726:../drivers/fsl_clock.c ****                 ret_vdiv = vdiv_cur;
 2543              		.loc 2 726 26
 2544 00f0 2623     		movs	r3, #38
 2545 00f2 FB18     		adds	r3, r7, r3
 2546 00f4 1322     		movs	r2, #19
 2547 00f6 BA18     		adds	r2, r7, r2
 2548 00f8 1278     		ldrb	r2, [r2]
 2549 00fa 1A70     		strb	r2, [r3]
 2550              	.L179:
 727:../drivers/fsl_clock.c ****             }
 728:../drivers/fsl_clock.c ****         }
 729:../drivers/fsl_clock.c ****         vdiv_cur++;
 2551              		.loc 2 729 17
 2552 00fc 1321     		movs	r1, #19
 2553 00fe 7B18     		adds	r3, r7, r1
 2554 0100 1A78     		ldrb	r2, [r3]
 2555 0102 7B18     		adds	r3, r7, r1
 2556 0104 0132     		adds	r2, r2, #1
 2557 0106 1A70     		strb	r2, [r3]
 730:../drivers/fsl_clock.c ****         if (vdiv_cur <= (FSL_FEATURE_MCG_PLL_VDIV_BASE + 31U))
 2558              		.loc 2 730 12
 2559 0108 7B18     		adds	r3, r7, r1
 2560 010a 1B78     		ldrb	r3, [r3]
 2561 010c 372B     		cmp	r3, #55
 2562 010e 1AD8     		bhi	.L178
 731:../drivers/fsl_clock.c ****         {
 732:../drivers/fsl_clock.c ****             ret_freq += ref_div;
 2563              		.loc 2 732 22
 2564 0110 FA69     		ldr	r2, [r7, #28]
 2565 0112 7B69     		ldr	r3, [r7, #20]
 2566 0114 D318     		adds	r3, r2, r3
 2567 0116 FB61     		str	r3, [r7, #28]
 733:../drivers/fsl_clock.c ****             /* New PRDIV/VDIV is closer. */
 734:../drivers/fsl_clock.c ****             if (diff > ret_freq - desireFreq)
 2568              		.loc 2 734 33
 2569 0118 FA69     		ldr	r2, [r7, #28]
 2570 011a BB68     		ldr	r3, [r7, #8]
 2571 011c D31A     		subs	r3, r2, r3
 2572              		.loc 2 734 16
 2573 011e 3A6A     		ldr	r2, [r7, #32]
 2574 0120 9A42     		cmp	r2, r3
 2575 0122 10D9     		bls	.L178
 735:../drivers/fsl_clock.c ****             {
 736:../drivers/fsl_clock.c ****                 diff = ret_freq - desireFreq;
 2576              		.loc 2 736 22
 2577 0124 FA69     		ldr	r2, [r7, #28]
 2578 0126 BB68     		ldr	r3, [r7, #8]
 2579 0128 D31A     		subs	r3, r2, r3
 2580 012a 3B62     		str	r3, [r7, #32]
 737:../drivers/fsl_clock.c ****                 ret_prdiv = prdiv_cur;
 2581              		.loc 2 737 27
 2582 012c 2723     		movs	r3, #39
 2583 012e FB18     		adds	r3, r7, r3
 2584 0130 2522     		movs	r2, #37
 2585 0132 BA18     		adds	r2, r7, r2
 2586 0134 1278     		ldrb	r2, [r2]
 2587 0136 1A70     		strb	r2, [r3]
 738:../drivers/fsl_clock.c ****                 ret_vdiv = vdiv_cur;
 2588              		.loc 2 738 26
 2589 0138 2623     		movs	r3, #38
 2590 013a FB18     		adds	r3, r7, r3
 2591 013c 7A18     		adds	r2, r7, r1
 2592 013e 1278     		ldrb	r2, [r2]
 2593 0140 1A70     		strb	r2, [r3]
 2594 0142 00E0     		b	.L178
 2595              	.L183:
 708:../drivers/fsl_clock.c ****         }
 2596              		.loc 2 708 13
 2597 0144 C046     		nop
 2598              	.L178:
 698:../drivers/fsl_clock.c ****     {
 2599              		.loc 2 698 66 discriminator 2
 2600 0146 2521     		movs	r1, #37
 2601 0148 7B18     		adds	r3, r7, r1
 2602 014a 1A78     		ldrb	r2, [r3]
 2603 014c 7B18     		adds	r3, r7, r1
 2604 014e 013A     		subs	r2, r2, #1
 2605 0150 1A70     		strb	r2, [r3]
 2606              	.L175:
 698:../drivers/fsl_clock.c ****     {
 2607              		.loc 2 698 5 discriminator 1
 2608 0152 2523     		movs	r3, #37
 2609 0154 FA18     		adds	r2, r7, r3
 2610 0156 1A23     		movs	r3, #26
 2611 0158 FB18     		adds	r3, r7, r3
 2612 015a 1278     		ldrb	r2, [r2]
 2613 015c 1B78     		ldrb	r3, [r3]
 2614 015e 9A42     		cmp	r2, r3
 2615 0160 81D2     		bcs	.L181
 739:../drivers/fsl_clock.c ****             }
 740:../drivers/fsl_clock.c ****         }
 741:../drivers/fsl_clock.c ****     }
 742:../drivers/fsl_clock.c **** 
 743:../drivers/fsl_clock.c ****     if (0xFFFFFFFFU != diff)
 2616              		.loc 2 743 8
 2617 0162 3B6A     		ldr	r3, [r7, #32]
 2618 0164 0133     		adds	r3, r3, #1
 2619 0166 1BD0     		beq	.L182
 744:../drivers/fsl_clock.c ****     {
 745:../drivers/fsl_clock.c ****         /* PRDIV/VDIV found. */
 746:../drivers/fsl_clock.c ****         *prdiv = ret_prdiv - FSL_FEATURE_MCG_PLL_PRDIV_BASE;
 2620              		.loc 2 746 28
 2621 0168 2721     		movs	r1, #39
 2622 016a 7B18     		adds	r3, r7, r1
 2623 016c 1B78     		ldrb	r3, [r3]
 2624 016e 013B     		subs	r3, r3, #1
 2625 0170 DAB2     		uxtb	r2, r3
 2626              		.loc 2 746 16
 2627 0172 7B68     		ldr	r3, [r7, #4]
 2628 0174 1A70     		strb	r2, [r3]
 747:../drivers/fsl_clock.c ****         *vdiv = ret_vdiv - FSL_FEATURE_MCG_PLL_VDIV_BASE;
 2629              		.loc 2 747 26
 2630 0176 2624     		movs	r4, #38
 2631 0178 3B19     		adds	r3, r7, r4
 2632 017a 1B78     		ldrb	r3, [r3]
 2633 017c 183B     		subs	r3, r3, #24
 2634 017e DAB2     		uxtb	r2, r3
 2635              		.loc 2 747 15
 2636 0180 3B68     		ldr	r3, [r7]
 2637 0182 1A70     		strb	r2, [r3]
 748:../drivers/fsl_clock.c ****         ret_freq = (refFreq / ret_prdiv) * ret_vdiv;
 2638              		.loc 2 748 29
 2639 0184 7B18     		adds	r3, r7, r1
 2640 0186 1B78     		ldrb	r3, [r3]
 2641 0188 1900     		movs	r1, r3
 2642 018a F868     		ldr	r0, [r7, #12]
 2643 018c FFF7FEFF 		bl	__aeabi_uidiv
 2644              	.LVL16:
 2645 0190 0300     		movs	r3, r0
 2646 0192 1A00     		movs	r2, r3
 2647              		.loc 2 748 42
 2648 0194 3B19     		adds	r3, r7, r4
 2649 0196 1B78     		ldrb	r3, [r3]
 2650              		.loc 2 748 18
 2651 0198 5343     		muls	r3, r2
 2652 019a FB61     		str	r3, [r7, #28]
 749:../drivers/fsl_clock.c ****         return ret_freq;
 2653              		.loc 2 749 16
 2654 019c FB69     		ldr	r3, [r7, #28]
 2655 019e 00E0     		b	.L174
 2656              	.L182:
 750:../drivers/fsl_clock.c ****     }
 751:../drivers/fsl_clock.c ****     else
 752:../drivers/fsl_clock.c ****     {
 753:../drivers/fsl_clock.c ****         /* No proper PRDIV/VDIV found. */
 754:../drivers/fsl_clock.c ****         return 0U;
 2657              		.loc 2 754 16
 2658 01a0 0023     		movs	r3, #0
 2659              	.L174:
 755:../drivers/fsl_clock.c ****     }
 756:../drivers/fsl_clock.c **** }
 2660              		.loc 2 756 1
 2661 01a2 1800     		movs	r0, r3
 2662 01a4 BD46     		mov	sp, r7
 2663 01a6 0BB0     		add	sp, sp, #44
 2664              		@ sp needed
 2665 01a8 90BD     		pop	{r4, r7, pc}
 2666              	.L185:
 2667 01aa C046     		.align	2
 2668              	.L184:
 2669 01ac 7F841E00 		.word	1999999
 2670 01b0 00E1F505 		.word	100000000
 2671 01b4 80841E00 		.word	2000000
 2672 01b8 FF083D00 		.word	3999999
 2673 01bc 00093D00 		.word	4000000
 2674              		.cfi_endproc
 2675              	.LFE80:
 2677              		.section	.rodata.CLOCK_EnablePll0.str1.4,"aMS",%progbits,1
 2678              		.align	2
 2679              	.LC16:
 2680 0000 2E66736C 		.ascii	".fsl_clock.c:760 : config\000"
 2680      5F636C6F 
 2680      636B2E63 
 2680      3A373630 
 2680      203A2063 
 2681              		.section	.text.CLOCK_EnablePll0,"ax",%progbits
 2682              		.align	1
 2683              		.global	CLOCK_EnablePll0
 2684              		.syntax unified
 2685              		.code	16
 2686              		.thumb_func
 2687              		.fpu softvfp
 2689              	CLOCK_EnablePll0:
 2690              	.LFB81:
 757:../drivers/fsl_clock.c **** 
 758:../drivers/fsl_clock.c **** void CLOCK_EnablePll0(mcg_pll_config_t const *config)
 759:../drivers/fsl_clock.c **** {
 2691              		.loc 2 759 1
 2692              		.cfi_startproc
 2693              		@ args = 0, pretend = 0, frame = 16
 2694              		@ frame_needed = 1, uses_anonymous_args = 0
 2695 0000 80B5     		push	{r7, lr}
 2696              		.cfi_def_cfa_offset 8
 2697              		.cfi_offset 7, -8
 2698              		.cfi_offset 14, -4
 2699 0002 84B0     		sub	sp, sp, #16
 2700              		.cfi_def_cfa_offset 24
 2701 0004 00AF     		add	r7, sp, #0
 2702              		.cfi_def_cfa_register 7
 2703 0006 7860     		str	r0, [r7, #4]
 760:../drivers/fsl_clock.c ****     assert(config);
 2704              		.loc 2 760 5
 2705 0008 7B68     		ldr	r3, [r7, #4]
 2706 000a 002B     		cmp	r3, #0
 2707 000c 03D1     		bne	.L187
 2708              		.loc 2 760 5 is_stmt 0 discriminator 1
 2709 000e 1F4B     		ldr	r3, .L189
 2710 0010 1800     		movs	r0, r3
 2711 0012 FFF7FEFF 		bl	__assertion_failed
 2712              	.L187:
 761:../drivers/fsl_clock.c **** 
 762:../drivers/fsl_clock.c ****     uint8_t mcg_c5 = 0U;
 2713              		.loc 2 762 13 is_stmt 1
 2714 0016 0F20     		movs	r0, #15
 2715 0018 3B18     		adds	r3, r7, r0
 2716 001a 0022     		movs	r2, #0
 2717 001c 1A70     		strb	r2, [r3]
 763:../drivers/fsl_clock.c **** 
 764:../drivers/fsl_clock.c ****     mcg_c5 |= MCG_C5_PRDIV0(config->prdiv);
 2718              		.loc 2 764 15
 2719 001e 7B68     		ldr	r3, [r7, #4]
 2720 0020 5B78     		ldrb	r3, [r3, #1]
 2721 0022 1F22     		movs	r2, #31
 2722 0024 1340     		ands	r3, r2
 2723 0026 D9B2     		uxtb	r1, r3
 2724              		.loc 2 764 12
 2725 0028 3B18     		adds	r3, r7, r0
 2726 002a 3A18     		adds	r2, r7, r0
 2727 002c 1278     		ldrb	r2, [r2]
 2728 002e 0A43     		orrs	r2, r1
 2729 0030 1A70     		strb	r2, [r3]
 765:../drivers/fsl_clock.c ****     MCG->C5 = mcg_c5; /* Disable the PLL first. */
 2730              		.loc 2 765 8
 2731 0032 174A     		ldr	r2, .L189+4
 2732              		.loc 2 765 13
 2733 0034 3B18     		adds	r3, r7, r0
 2734 0036 1B78     		ldrb	r3, [r3]
 2735 0038 1371     		strb	r3, [r2, #4]
 766:../drivers/fsl_clock.c **** 
 767:../drivers/fsl_clock.c ****     MCG->C6 = (MCG->C6 & ~MCG_C6_VDIV0_MASK) | MCG_C6_VDIV0(config->vdiv);
 2736              		.loc 2 767 19
 2737 003a 154B     		ldr	r3, .L189+4
 2738 003c 5B79     		ldrb	r3, [r3, #5]
 2739 003e DBB2     		uxtb	r3, r3
 2740              		.loc 2 767 24
 2741 0040 1F22     		movs	r2, #31
 2742 0042 9343     		bics	r3, r2
 2743 0044 DAB2     		uxtb	r2, r3
 2744              		.loc 2 767 48
 2745 0046 7B68     		ldr	r3, [r7, #4]
 2746 0048 9B78     		ldrb	r3, [r3, #2]
 2747 004a 1F21     		movs	r1, #31
 2748 004c 0B40     		ands	r3, r1
 2749 004e DBB2     		uxtb	r3, r3
 2750              		.loc 2 767 8
 2751 0050 0F49     		ldr	r1, .L189+4
 2752              		.loc 2 767 46
 2753 0052 1343     		orrs	r3, r2
 2754 0054 DBB2     		uxtb	r3, r3
 2755              		.loc 2 767 13
 2756 0056 4B71     		strb	r3, [r1, #5]
 768:../drivers/fsl_clock.c **** 
 769:../drivers/fsl_clock.c ****     /* Set enable mode. */
 770:../drivers/fsl_clock.c ****     MCG->C5 |= ((uint32_t)kMCG_PllEnableIndependent | (uint32_t)config->enableMode);
 2757              		.loc 2 770 13
 2758 0058 0D4B     		ldr	r3, .L189+4
 2759 005a 1B79     		ldrb	r3, [r3, #4]
 2760 005c DAB2     		uxtb	r2, r3
 2761              		.loc 2 770 71
 2762 005e 7B68     		ldr	r3, [r7, #4]
 2763 0060 1B78     		ldrb	r3, [r3]
 2764              		.loc 2 770 13
 2765 0062 1343     		orrs	r3, r2
 2766 0064 DBB2     		uxtb	r3, r3
 2767 0066 0A4A     		ldr	r2, .L189+4
 2768 0068 4021     		movs	r1, #64
 2769 006a 0B43     		orrs	r3, r1
 2770 006c DBB2     		uxtb	r3, r3
 2771 006e 1371     		strb	r3, [r2, #4]
 771:../drivers/fsl_clock.c **** 
 772:../drivers/fsl_clock.c ****     /* Wait for PLL lock. */
 773:../drivers/fsl_clock.c ****     while (!(MCG->S & MCG_S_LOCK0_MASK))
 2772              		.loc 2 773 11
 2773 0070 C046     		nop
 2774              	.L188:
 2775              		.loc 2 773 17 discriminator 1
 2776 0072 074B     		ldr	r3, .L189+4
 2777 0074 9B79     		ldrb	r3, [r3, #6]
 2778 0076 DBB2     		uxtb	r3, r3
 2779              		.loc 2 773 21 discriminator 1
 2780 0078 1A00     		movs	r2, r3
 2781 007a 4023     		movs	r3, #64
 2782 007c 1340     		ands	r3, r2
 2783              		.loc 2 773 11 discriminator 1
 2784 007e F8D0     		beq	.L188
 774:../drivers/fsl_clock.c ****     {
 775:../drivers/fsl_clock.c ****     }
 776:../drivers/fsl_clock.c **** }
 2785              		.loc 2 776 1
 2786 0080 C046     		nop
 2787 0082 C046     		nop
 2788 0084 BD46     		mov	sp, r7
 2789 0086 04B0     		add	sp, sp, #16
 2790              		@ sp needed
 2791 0088 80BD     		pop	{r7, pc}
 2792              	.L190:
 2793 008a C046     		.align	2
 2794              	.L189:
 2795 008c 00000000 		.word	.LC16
 2796 0090 00400640 		.word	1074151424
 2797              		.cfi_endproc
 2798              	.LFE81:
 2800              		.section	.text.CLOCK_SetOsc0MonitorMode,"ax",%progbits
 2801              		.align	1
 2802              		.global	CLOCK_SetOsc0MonitorMode
 2803              		.syntax unified
 2804              		.code	16
 2805              		.thumb_func
 2806              		.fpu softvfp
 2808              	CLOCK_SetOsc0MonitorMode:
 2809              	.LFB82:
 777:../drivers/fsl_clock.c **** 
 778:../drivers/fsl_clock.c **** void CLOCK_SetOsc0MonitorMode(mcg_monitor_mode_t mode)
 779:../drivers/fsl_clock.c **** {
 2810              		.loc 2 779 1
 2811              		.cfi_startproc
 2812              		@ args = 0, pretend = 0, frame = 8
 2813              		@ frame_needed = 1, uses_anonymous_args = 0
 2814 0000 80B5     		push	{r7, lr}
 2815              		.cfi_def_cfa_offset 8
 2816              		.cfi_offset 7, -8
 2817              		.cfi_offset 14, -4
 2818 0002 82B0     		sub	sp, sp, #8
 2819              		.cfi_def_cfa_offset 16
 2820 0004 00AF     		add	r7, sp, #0
 2821              		.cfi_def_cfa_register 7
 2822 0006 0200     		movs	r2, r0
 2823 0008 FB1D     		adds	r3, r7, #7
 2824 000a 1A70     		strb	r2, [r3]
 780:../drivers/fsl_clock.c ****     /* Clear the previous flag, MCG_SC[LOCS0]. */
 781:../drivers/fsl_clock.c ****     MCG->SC &= ~MCG_SC_ATMF_MASK;
 2825              		.loc 2 781 13
 2826 000c 1B4B     		ldr	r3, .L197
 2827 000e 1B7A     		ldrb	r3, [r3, #8]
 2828 0010 DBB2     		uxtb	r3, r3
 2829 0012 1A4A     		ldr	r2, .L197
 2830 0014 2021     		movs	r1, #32
 2831 0016 8B43     		bics	r3, r1
 2832 0018 DBB2     		uxtb	r3, r3
 2833 001a 1372     		strb	r3, [r2, #8]
 782:../drivers/fsl_clock.c **** 
 783:../drivers/fsl_clock.c ****     if (kMCG_MonitorNone == mode)
 2834              		.loc 2 783 8
 2835 001c FB1D     		adds	r3, r7, #7
 2836 001e 1B78     		ldrb	r3, [r3]
 2837 0020 002B     		cmp	r3, #0
 2838 0022 08D1     		bne	.L192
 784:../drivers/fsl_clock.c ****     {
 785:../drivers/fsl_clock.c ****         MCG->C6 &= ~MCG_C6_CME0_MASK;
 2839              		.loc 2 785 17
 2840 0024 154B     		ldr	r3, .L197
 2841 0026 5B79     		ldrb	r3, [r3, #5]
 2842 0028 DBB2     		uxtb	r3, r3
 2843 002a 144A     		ldr	r2, .L197
 2844 002c 2021     		movs	r1, #32
 2845 002e 8B43     		bics	r3, r1
 2846 0030 DBB2     		uxtb	r3, r3
 2847 0032 5371     		strb	r3, [r2, #5]
 786:../drivers/fsl_clock.c ****     }
 787:../drivers/fsl_clock.c ****     else
 788:../drivers/fsl_clock.c ****     {
 789:../drivers/fsl_clock.c ****         if (kMCG_MonitorInt == mode)
 790:../drivers/fsl_clock.c ****         {
 791:../drivers/fsl_clock.c ****             MCG->C2 &= ~MCG_C2_LOCRE0_MASK;
 792:../drivers/fsl_clock.c ****         }
 793:../drivers/fsl_clock.c ****         else
 794:../drivers/fsl_clock.c ****         {
 795:../drivers/fsl_clock.c ****             MCG->C2 |= MCG_C2_LOCRE0_MASK;
 796:../drivers/fsl_clock.c ****         }
 797:../drivers/fsl_clock.c ****         MCG->C6 |= MCG_C6_CME0_MASK;
 798:../drivers/fsl_clock.c ****     }
 799:../drivers/fsl_clock.c **** }
 2848              		.loc 2 799 1
 2849 0034 1DE0     		b	.L196
 2850              	.L192:
 789:../drivers/fsl_clock.c ****         {
 2851              		.loc 2 789 12
 2852 0036 FB1D     		adds	r3, r7, #7
 2853 0038 1B78     		ldrb	r3, [r3]
 2854 003a 012B     		cmp	r3, #1
 2855 003c 08D1     		bne	.L194
 791:../drivers/fsl_clock.c ****         }
 2856              		.loc 2 791 21
 2857 003e 0F4B     		ldr	r3, .L197
 2858 0040 5B78     		ldrb	r3, [r3, #1]
 2859 0042 DBB2     		uxtb	r3, r3
 2860 0044 0D4A     		ldr	r2, .L197
 2861 0046 7F21     		movs	r1, #127
 2862 0048 0B40     		ands	r3, r1
 2863 004a DBB2     		uxtb	r3, r3
 2864 004c 5370     		strb	r3, [r2, #1]
 2865 004e 08E0     		b	.L195
 2866              	.L194:
 795:../drivers/fsl_clock.c ****         }
 2867              		.loc 2 795 21
 2868 0050 0A4B     		ldr	r3, .L197
 2869 0052 5B78     		ldrb	r3, [r3, #1]
 2870 0054 DBB2     		uxtb	r3, r3
 2871 0056 0949     		ldr	r1, .L197
 2872 0058 8022     		movs	r2, #128
 2873 005a 5242     		rsbs	r2, r2, #0
 2874 005c 1343     		orrs	r3, r2
 2875 005e DBB2     		uxtb	r3, r3
 2876 0060 4B70     		strb	r3, [r1, #1]
 2877              	.L195:
 797:../drivers/fsl_clock.c ****     }
 2878              		.loc 2 797 17
 2879 0062 064B     		ldr	r3, .L197
 2880 0064 5B79     		ldrb	r3, [r3, #5]
 2881 0066 DBB2     		uxtb	r3, r3
 2882 0068 044A     		ldr	r2, .L197
 2883 006a 2021     		movs	r1, #32
 2884 006c 0B43     		orrs	r3, r1
 2885 006e DBB2     		uxtb	r3, r3
 2886 0070 5371     		strb	r3, [r2, #5]
 2887              	.L196:
 2888              		.loc 2 799 1
 2889 0072 C046     		nop
 2890 0074 BD46     		mov	sp, r7
 2891 0076 02B0     		add	sp, sp, #8
 2892              		@ sp needed
 2893 0078 80BD     		pop	{r7, pc}
 2894              	.L198:
 2895 007a C046     		.align	2
 2896              	.L197:
 2897 007c 00400640 		.word	1074151424
 2898              		.cfi_endproc
 2899              	.LFE82:
 2901              		.section	.text.CLOCK_SetPll0MonitorMode,"ax",%progbits
 2902              		.align	1
 2903              		.global	CLOCK_SetPll0MonitorMode
 2904              		.syntax unified
 2905              		.code	16
 2906              		.thumb_func
 2907              		.fpu softvfp
 2909              	CLOCK_SetPll0MonitorMode:
 2910              	.LFB83:
 800:../drivers/fsl_clock.c **** 
 801:../drivers/fsl_clock.c **** void CLOCK_SetPll0MonitorMode(mcg_monitor_mode_t mode)
 802:../drivers/fsl_clock.c **** {
 2911              		.loc 2 802 1
 2912              		.cfi_startproc
 2913              		@ args = 0, pretend = 0, frame = 16
 2914              		@ frame_needed = 1, uses_anonymous_args = 0
 2915 0000 80B5     		push	{r7, lr}
 2916              		.cfi_def_cfa_offset 8
 2917              		.cfi_offset 7, -8
 2918              		.cfi_offset 14, -4
 2919 0002 84B0     		sub	sp, sp, #16
 2920              		.cfi_def_cfa_offset 24
 2921 0004 00AF     		add	r7, sp, #0
 2922              		.cfi_def_cfa_register 7
 2923 0006 0200     		movs	r2, r0
 2924 0008 FB1D     		adds	r3, r7, #7
 2925 000a 1A70     		strb	r2, [r3]
 803:../drivers/fsl_clock.c ****     uint8_t mcg_c8;
 804:../drivers/fsl_clock.c **** 
 805:../drivers/fsl_clock.c ****     /* Clear previous flag. */
 806:../drivers/fsl_clock.c ****     MCG->S = MCG_S_LOLS0_MASK;
 2926              		.loc 2 806 8
 2927 000c 1C4B     		ldr	r3, .L205
 2928              		.loc 2 806 12
 2929 000e 8022     		movs	r2, #128
 2930 0010 9A71     		strb	r2, [r3, #6]
 807:../drivers/fsl_clock.c **** 
 808:../drivers/fsl_clock.c ****     if (kMCG_MonitorNone == mode)
 2931              		.loc 2 808 8
 2932 0012 FB1D     		adds	r3, r7, #7
 2933 0014 1B78     		ldrb	r3, [r3]
 2934 0016 002B     		cmp	r3, #0
 2935 0018 08D1     		bne	.L200
 809:../drivers/fsl_clock.c ****     {
 810:../drivers/fsl_clock.c ****         MCG->C6 &= ~MCG_C6_LOLIE0_MASK;
 2936              		.loc 2 810 17
 2937 001a 194B     		ldr	r3, .L205
 2938 001c 5B79     		ldrb	r3, [r3, #5]
 2939 001e DBB2     		uxtb	r3, r3
 2940 0020 174A     		ldr	r2, .L205
 2941 0022 7F21     		movs	r1, #127
 2942 0024 0B40     		ands	r3, r1
 2943 0026 DBB2     		uxtb	r3, r3
 2944 0028 5371     		strb	r3, [r2, #5]
 811:../drivers/fsl_clock.c ****     }
 812:../drivers/fsl_clock.c ****     else
 813:../drivers/fsl_clock.c ****     {
 814:../drivers/fsl_clock.c ****         mcg_c8 = MCG->C8;
 815:../drivers/fsl_clock.c **** 
 816:../drivers/fsl_clock.c ****         if (kMCG_MonitorInt == mode)
 817:../drivers/fsl_clock.c ****         {
 818:../drivers/fsl_clock.c ****             mcg_c8 &= ~MCG_C8_LOLRE_MASK;
 819:../drivers/fsl_clock.c ****         }
 820:../drivers/fsl_clock.c ****         else
 821:../drivers/fsl_clock.c ****         {
 822:../drivers/fsl_clock.c ****             mcg_c8 |= MCG_C8_LOLRE_MASK;
 823:../drivers/fsl_clock.c ****         }
 824:../drivers/fsl_clock.c ****         MCG->C8 = mcg_c8;
 825:../drivers/fsl_clock.c ****         MCG->C6 |= MCG_C6_LOLIE0_MASK;
 826:../drivers/fsl_clock.c ****     }
 827:../drivers/fsl_clock.c **** }
 2945              		.loc 2 827 1
 2946 002a 24E0     		b	.L204
 2947              	.L200:
 814:../drivers/fsl_clock.c **** 
 2948              		.loc 2 814 21
 2949 002c 144A     		ldr	r2, .L205
 814:../drivers/fsl_clock.c **** 
 2950              		.loc 2 814 16
 2951 002e 0F21     		movs	r1, #15
 2952 0030 7B18     		adds	r3, r7, r1
 2953 0032 527B     		ldrb	r2, [r2, #13]
 2954 0034 1A70     		strb	r2, [r3]
 816:../drivers/fsl_clock.c ****         {
 2955              		.loc 2 816 12
 2956 0036 FB1D     		adds	r3, r7, #7
 2957 0038 1B78     		ldrb	r3, [r3]
 2958 003a 012B     		cmp	r3, #1
 2959 003c 06D1     		bne	.L202
 818:../drivers/fsl_clock.c ****         }
 2960              		.loc 2 818 20
 2961 003e 7B18     		adds	r3, r7, r1
 2962 0040 7A18     		adds	r2, r7, r1
 2963 0042 1278     		ldrb	r2, [r2]
 2964 0044 4021     		movs	r1, #64
 2965 0046 8A43     		bics	r2, r1
 2966 0048 1A70     		strb	r2, [r3]
 2967 004a 06E0     		b	.L203
 2968              	.L202:
 822:../drivers/fsl_clock.c ****         }
 2969              		.loc 2 822 20
 2970 004c 0F22     		movs	r2, #15
 2971 004e BB18     		adds	r3, r7, r2
 2972 0050 BA18     		adds	r2, r7, r2
 2973 0052 1278     		ldrb	r2, [r2]
 2974 0054 4021     		movs	r1, #64
 2975 0056 0A43     		orrs	r2, r1
 2976 0058 1A70     		strb	r2, [r3]
 2977              	.L203:
 824:../drivers/fsl_clock.c ****         MCG->C6 |= MCG_C6_LOLIE0_MASK;
 2978              		.loc 2 824 12
 2979 005a 094A     		ldr	r2, .L205
 824:../drivers/fsl_clock.c ****         MCG->C6 |= MCG_C6_LOLIE0_MASK;
 2980              		.loc 2 824 17
 2981 005c 0F23     		movs	r3, #15
 2982 005e FB18     		adds	r3, r7, r3
 2983 0060 1B78     		ldrb	r3, [r3]
 2984 0062 5373     		strb	r3, [r2, #13]
 825:../drivers/fsl_clock.c ****     }
 2985              		.loc 2 825 17
 2986 0064 064B     		ldr	r3, .L205
 2987 0066 5B79     		ldrb	r3, [r3, #5]
 2988 0068 DBB2     		uxtb	r3, r3
 2989 006a 0549     		ldr	r1, .L205
 2990 006c 8022     		movs	r2, #128
 2991 006e 5242     		rsbs	r2, r2, #0
 2992 0070 1343     		orrs	r3, r2
 2993 0072 DBB2     		uxtb	r3, r3
 2994 0074 4B71     		strb	r3, [r1, #5]
 2995              	.L204:
 2996              		.loc 2 827 1
 2997 0076 C046     		nop
 2998 0078 BD46     		mov	sp, r7
 2999 007a 04B0     		add	sp, sp, #16
 3000              		@ sp needed
 3001 007c 80BD     		pop	{r7, pc}
 3002              	.L206:
 3003 007e C046     		.align	2
 3004              	.L205:
 3005 0080 00400640 		.word	1074151424
 3006              		.cfi_endproc
 3007              	.LFE83:
 3009              		.section	.text.CLOCK_GetStatusFlags,"ax",%progbits
 3010              		.align	1
 3011              		.global	CLOCK_GetStatusFlags
 3012              		.syntax unified
 3013              		.code	16
 3014              		.thumb_func
 3015              		.fpu softvfp
 3017              	CLOCK_GetStatusFlags:
 3018              	.LFB84:
 828:../drivers/fsl_clock.c **** 
 829:../drivers/fsl_clock.c **** uint32_t CLOCK_GetStatusFlags(void)
 830:../drivers/fsl_clock.c **** {
 3019              		.loc 2 830 1
 3020              		.cfi_startproc
 3021              		@ args = 0, pretend = 0, frame = 8
 3022              		@ frame_needed = 1, uses_anonymous_args = 0
 3023 0000 80B5     		push	{r7, lr}
 3024              		.cfi_def_cfa_offset 8
 3025              		.cfi_offset 7, -8
 3026              		.cfi_offset 14, -4
 3027 0002 82B0     		sub	sp, sp, #8
 3028              		.cfi_def_cfa_offset 16
 3029 0004 00AF     		add	r7, sp, #0
 3030              		.cfi_def_cfa_register 7
 831:../drivers/fsl_clock.c ****     uint32_t ret = 0U;
 3031              		.loc 2 831 14
 3032 0006 0023     		movs	r3, #0
 3033 0008 7B60     		str	r3, [r7, #4]
 832:../drivers/fsl_clock.c ****     uint8_t mcg_s = MCG->S;
 3034              		.loc 2 832 24
 3035 000a 174A     		ldr	r2, .L213
 3036              		.loc 2 832 13
 3037 000c FB1C     		adds	r3, r7, #3
 3038 000e 9279     		ldrb	r2, [r2, #6]
 3039 0010 1A70     		strb	r2, [r3]
 833:../drivers/fsl_clock.c **** 
 834:../drivers/fsl_clock.c ****     if (MCG->SC & MCG_SC_LOCS0_MASK)
 3040              		.loc 2 834 12
 3041 0012 154B     		ldr	r3, .L213
 3042 0014 1B7A     		ldrb	r3, [r3, #8]
 3043 0016 DBB2     		uxtb	r3, r3
 3044              		.loc 2 834 17
 3045 0018 1A00     		movs	r2, r3
 3046 001a 0123     		movs	r3, #1
 3047 001c 1340     		ands	r3, r2
 3048              		.loc 2 834 8
 3049 001e 03D0     		beq	.L208
 835:../drivers/fsl_clock.c ****     {
 836:../drivers/fsl_clock.c ****         ret |= kMCG_Osc0LostFlag;
 3050              		.loc 2 836 13
 3051 0020 7B68     		ldr	r3, [r7, #4]
 3052 0022 0122     		movs	r2, #1
 3053 0024 1343     		orrs	r3, r2
 3054 0026 7B60     		str	r3, [r7, #4]
 3055              	.L208:
 837:../drivers/fsl_clock.c ****     }
 838:../drivers/fsl_clock.c ****     if (mcg_s & MCG_S_OSCINIT0_MASK)
 3056              		.loc 2 838 15
 3057 0028 FB1C     		adds	r3, r7, #3
 3058 002a 1B78     		ldrb	r3, [r3]
 3059 002c 0222     		movs	r2, #2
 3060 002e 1340     		ands	r3, r2
 3061              		.loc 2 838 8
 3062 0030 03D0     		beq	.L209
 839:../drivers/fsl_clock.c ****     {
 840:../drivers/fsl_clock.c ****         ret |= kMCG_Osc0InitFlag;
 3063              		.loc 2 840 13
 3064 0032 7B68     		ldr	r3, [r7, #4]
 3065 0034 0222     		movs	r2, #2
 3066 0036 1343     		orrs	r3, r2
 3067 0038 7B60     		str	r3, [r7, #4]
 3068              	.L209:
 841:../drivers/fsl_clock.c ****     }
 842:../drivers/fsl_clock.c ****     if (mcg_s & MCG_S_LOLS0_MASK)
 3069              		.loc 2 842 9
 3070 003a FB1C     		adds	r3, r7, #3
 3071 003c 1B78     		ldrb	r3, [r3]
 3072 003e 5BB2     		sxtb	r3, r3
 3073              		.loc 2 842 8
 3074 0040 002B     		cmp	r3, #0
 3075 0042 03DA     		bge	.L210
 843:../drivers/fsl_clock.c ****     {
 844:../drivers/fsl_clock.c ****         ret |= kMCG_Pll0LostFlag;
 3076              		.loc 2 844 13
 3077 0044 7B68     		ldr	r3, [r7, #4]
 3078 0046 2022     		movs	r2, #32
 3079 0048 1343     		orrs	r3, r2
 3080 004a 7B60     		str	r3, [r7, #4]
 3081              	.L210:
 845:../drivers/fsl_clock.c ****     }
 846:../drivers/fsl_clock.c ****     if (mcg_s & MCG_S_LOCK0_MASK)
 3082              		.loc 2 846 15
 3083 004c FB1C     		adds	r3, r7, #3
 3084 004e 1B78     		ldrb	r3, [r3]
 3085 0050 4022     		movs	r2, #64
 3086 0052 1340     		ands	r3, r2
 3087              		.loc 2 846 8
 3088 0054 03D0     		beq	.L211
 847:../drivers/fsl_clock.c ****     {
 848:../drivers/fsl_clock.c ****         ret |= kMCG_Pll0LockFlag;
 3089              		.loc 2 848 13
 3090 0056 7B68     		ldr	r3, [r7, #4]
 3091 0058 4022     		movs	r2, #64
 3092 005a 1343     		orrs	r3, r2
 3093 005c 7B60     		str	r3, [r7, #4]
 3094              	.L211:
 849:../drivers/fsl_clock.c ****     }
 850:../drivers/fsl_clock.c ****     return ret;
 3095              		.loc 2 850 12
 3096 005e 7B68     		ldr	r3, [r7, #4]
 851:../drivers/fsl_clock.c **** }
 3097              		.loc 2 851 1
 3098 0060 1800     		movs	r0, r3
 3099 0062 BD46     		mov	sp, r7
 3100 0064 02B0     		add	sp, sp, #8
 3101              		@ sp needed
 3102 0066 80BD     		pop	{r7, pc}
 3103              	.L214:
 3104              		.align	2
 3105              	.L213:
 3106 0068 00400640 		.word	1074151424
 3107              		.cfi_endproc
 3108              	.LFE84:
 3110              		.section	.text.CLOCK_ClearStatusFlags,"ax",%progbits
 3111              		.align	1
 3112              		.global	CLOCK_ClearStatusFlags
 3113              		.syntax unified
 3114              		.code	16
 3115              		.thumb_func
 3116              		.fpu softvfp
 3118              	CLOCK_ClearStatusFlags:
 3119              	.LFB85:
 852:../drivers/fsl_clock.c **** 
 853:../drivers/fsl_clock.c **** void CLOCK_ClearStatusFlags(uint32_t mask)
 854:../drivers/fsl_clock.c **** {
 3120              		.loc 2 854 1
 3121              		.cfi_startproc
 3122              		@ args = 0, pretend = 0, frame = 8
 3123              		@ frame_needed = 1, uses_anonymous_args = 0
 3124 0000 80B5     		push	{r7, lr}
 3125              		.cfi_def_cfa_offset 8
 3126              		.cfi_offset 7, -8
 3127              		.cfi_offset 14, -4
 3128 0002 82B0     		sub	sp, sp, #8
 3129              		.cfi_def_cfa_offset 16
 3130 0004 00AF     		add	r7, sp, #0
 3131              		.cfi_def_cfa_register 7
 3132 0006 7860     		str	r0, [r7, #4]
 855:../drivers/fsl_clock.c ****     if (mask & kMCG_Osc0LostFlag)
 3133              		.loc 2 855 14
 3134 0008 7B68     		ldr	r3, [r7, #4]
 3135 000a 0122     		movs	r2, #1
 3136 000c 1340     		ands	r3, r2
 3137              		.loc 2 855 8
 3138 000e 07D0     		beq	.L216
 856:../drivers/fsl_clock.c ****     {
 857:../drivers/fsl_clock.c ****         MCG->SC &= ~MCG_SC_ATMF_MASK;
 3139              		.loc 2 857 17
 3140 0010 094B     		ldr	r3, .L219
 3141 0012 1B7A     		ldrb	r3, [r3, #8]
 3142 0014 DBB2     		uxtb	r3, r3
 3143 0016 084A     		ldr	r2, .L219
 3144 0018 2021     		movs	r1, #32
 3145 001a 8B43     		bics	r3, r1
 3146 001c DBB2     		uxtb	r3, r3
 3147 001e 1372     		strb	r3, [r2, #8]
 3148              	.L216:
 858:../drivers/fsl_clock.c ****     }
 859:../drivers/fsl_clock.c ****     if (mask & kMCG_Pll0LostFlag)
 3149              		.loc 2 859 14
 3150 0020 7B68     		ldr	r3, [r7, #4]
 3151 0022 2022     		movs	r2, #32
 3152 0024 1340     		ands	r3, r2
 3153              		.loc 2 859 8
 3154 0026 02D0     		beq	.L218
 860:../drivers/fsl_clock.c ****     {
 861:../drivers/fsl_clock.c ****         MCG->S = MCG_S_LOLS0_MASK;
 3155              		.loc 2 861 12
 3156 0028 034B     		ldr	r3, .L219
 3157              		.loc 2 861 16
 3158 002a 8022     		movs	r2, #128
 3159 002c 9A71     		strb	r2, [r3, #6]
 3160              	.L218:
 862:../drivers/fsl_clock.c ****     }
 863:../drivers/fsl_clock.c **** }
 3161              		.loc 2 863 1
 3162 002e C046     		nop
 3163 0030 BD46     		mov	sp, r7
 3164 0032 02B0     		add	sp, sp, #8
 3165              		@ sp needed
 3166 0034 80BD     		pop	{r7, pc}
 3167              	.L220:
 3168 0036 C046     		.align	2
 3169              	.L219:
 3170 0038 00400640 		.word	1074151424
 3171              		.cfi_endproc
 3172              	.LFE85:
 3174              		.section	.text.CLOCK_InitOsc0,"ax",%progbits
 3175              		.align	1
 3176              		.global	CLOCK_InitOsc0
 3177              		.syntax unified
 3178              		.code	16
 3179              		.thumb_func
 3180              		.fpu softvfp
 3182              	CLOCK_InitOsc0:
 3183              	.LFB86:
 864:../drivers/fsl_clock.c **** 
 865:../drivers/fsl_clock.c **** void CLOCK_InitOsc0(osc_config_t const *config)
 866:../drivers/fsl_clock.c **** {
 3184              		.loc 2 866 1
 3185              		.cfi_startproc
 3186              		@ args = 0, pretend = 0, frame = 16
 3187              		@ frame_needed = 1, uses_anonymous_args = 0
 3188 0000 B0B5     		push	{r4, r5, r7, lr}
 3189              		.cfi_def_cfa_offset 16
 3190              		.cfi_offset 4, -16
 3191              		.cfi_offset 5, -12
 3192              		.cfi_offset 7, -8
 3193              		.cfi_offset 14, -4
 3194 0002 84B0     		sub	sp, sp, #16
 3195              		.cfi_def_cfa_offset 32
 3196 0004 00AF     		add	r7, sp, #0
 3197              		.cfi_def_cfa_register 7
 3198 0006 7860     		str	r0, [r7, #4]
 867:../drivers/fsl_clock.c ****     uint8_t range = CLOCK_GetOscRangeFromFreq(config->freq);
 3199              		.loc 2 867 21
 3200 0008 7B68     		ldr	r3, [r7, #4]
 3201 000a 1B68     		ldr	r3, [r3]
 3202 000c 0F25     		movs	r5, #15
 3203 000e 7C19     		adds	r4, r7, r5
 3204 0010 1800     		movs	r0, r3
 3205 0012 FFF7FEFF 		bl	CLOCK_GetOscRangeFromFreq
 3206 0016 0300     		movs	r3, r0
 3207 0018 2370     		strb	r3, [r4]
 868:../drivers/fsl_clock.c **** 
 869:../drivers/fsl_clock.c ****     OSC_SetCapLoad(OSC0, config->capLoad);
 3208              		.loc 2 869 5
 3209 001a 7B68     		ldr	r3, [r7, #4]
 3210 001c 1B79     		ldrb	r3, [r3, #4]
 3211 001e 1B4A     		ldr	r2, .L225
 3212 0020 1900     		movs	r1, r3
 3213 0022 1000     		movs	r0, r2
 3214 0024 FFF7FEFF 		bl	OSC_SetCapLoad
 870:../drivers/fsl_clock.c ****     OSC_SetExtRefClkConfig(OSC0, &config->oscerConfig);
 3215              		.loc 2 870 5
 3216 0028 7B68     		ldr	r3, [r7, #4]
 3217 002a 0633     		adds	r3, r3, #6
 3218 002c 174A     		ldr	r2, .L225
 3219 002e 1900     		movs	r1, r3
 3220 0030 1000     		movs	r0, r2
 3221 0032 FFF7FEFF 		bl	OSC_SetExtRefClkConfig
 871:../drivers/fsl_clock.c **** 
 872:../drivers/fsl_clock.c ****     MCG->C2 = ((MCG->C2 & ~OSC_MODE_MASK) | MCG_C2_RANGE(range) | (uint8_t)config->workMode);
 3222              		.loc 2 872 20
 3223 0036 164B     		ldr	r3, .L225+4
 3224 0038 5B78     		ldrb	r3, [r3, #1]
 3225 003a DBB2     		uxtb	r3, r3
 3226              		.loc 2 872 25
 3227 003c 3C22     		movs	r2, #60
 3228 003e 9343     		bics	r3, r2
 3229 0040 DAB2     		uxtb	r2, r3
 3230              		.loc 2 872 45
 3231 0042 7B19     		adds	r3, r7, r5
 3232 0044 1B78     		ldrb	r3, [r3]
 3233 0046 1B01     		lsls	r3, r3, #4
 3234 0048 DBB2     		uxtb	r3, r3
 3235 004a 3021     		movs	r1, #48
 3236 004c 0B40     		ands	r3, r1
 3237 004e DBB2     		uxtb	r3, r3
 3238              		.loc 2 872 43
 3239 0050 1343     		orrs	r3, r2
 3240 0052 DAB2     		uxtb	r2, r3
 3241              		.loc 2 872 82
 3242 0054 7B68     		ldr	r3, [r7, #4]
 3243 0056 5B79     		ldrb	r3, [r3, #5]
 3244              		.loc 2 872 8
 3245 0058 0D49     		ldr	r1, .L225+4
 3246              		.loc 2 872 65
 3247 005a 1343     		orrs	r3, r2
 3248 005c DBB2     		uxtb	r3, r3
 3249              		.loc 2 872 13
 3250 005e 4B70     		strb	r3, [r1, #1]
 873:../drivers/fsl_clock.c **** 
 874:../drivers/fsl_clock.c ****     if ((kOSC_ModeExt != config->workMode) && (OSC0->CR & OSC_CR_ERCLKEN_MASK))
 3251              		.loc 2 874 32
 3252 0060 7B68     		ldr	r3, [r7, #4]
 3253 0062 5B79     		ldrb	r3, [r3, #5]
 3254              		.loc 2 874 8
 3255 0064 002B     		cmp	r3, #0
 3256 0066 0DD0     		beq	.L224
 3257              		.loc 2 874 52 discriminator 1
 3258 0068 084B     		ldr	r3, .L225
 3259 006a 1B78     		ldrb	r3, [r3]
 3260 006c DBB2     		uxtb	r3, r3
 3261              		.loc 2 874 44 discriminator 1
 3262 006e 5BB2     		sxtb	r3, r3
 3263 0070 002B     		cmp	r3, #0
 3264 0072 07DA     		bge	.L224
 875:../drivers/fsl_clock.c ****     {
 876:../drivers/fsl_clock.c ****         /* Wait for stable. */
 877:../drivers/fsl_clock.c ****         while (!(MCG->S & MCG_S_OSCINIT0_MASK))
 3265              		.loc 2 877 15
 3266 0074 C046     		nop
 3267              	.L223:
 3268              		.loc 2 877 21 discriminator 1
 3269 0076 064B     		ldr	r3, .L225+4
 3270 0078 9B79     		ldrb	r3, [r3, #6]
 3271 007a DBB2     		uxtb	r3, r3
 3272              		.loc 2 877 25 discriminator 1
 3273 007c 1A00     		movs	r2, r3
 3274 007e 0223     		movs	r3, #2
 3275 0080 1340     		ands	r3, r2
 3276              		.loc 2 877 15 discriminator 1
 3277 0082 F8D0     		beq	.L223
 3278              	.L224:
 878:../drivers/fsl_clock.c ****         {
 879:../drivers/fsl_clock.c ****         }
 880:../drivers/fsl_clock.c ****     }
 881:../drivers/fsl_clock.c **** }
 3279              		.loc 2 881 1
 3280 0084 C046     		nop
 3281 0086 BD46     		mov	sp, r7
 3282 0088 04B0     		add	sp, sp, #16
 3283              		@ sp needed
 3284 008a B0BD     		pop	{r4, r5, r7, pc}
 3285              	.L226:
 3286              		.align	2
 3287              	.L225:
 3288 008c 00500640 		.word	1074155520
 3289 0090 00400640 		.word	1074151424
 3290              		.cfi_endproc
 3291              	.LFE86:
 3293              		.section	.text.CLOCK_DeinitOsc0,"ax",%progbits
 3294              		.align	1
 3295              		.global	CLOCK_DeinitOsc0
 3296              		.syntax unified
 3297              		.code	16
 3298              		.thumb_func
 3299              		.fpu softvfp
 3301              	CLOCK_DeinitOsc0:
 3302              	.LFB87:
 882:../drivers/fsl_clock.c **** 
 883:../drivers/fsl_clock.c **** void CLOCK_DeinitOsc0(void)
 884:../drivers/fsl_clock.c **** {
 3303              		.loc 2 884 1
 3304              		.cfi_startproc
 3305              		@ args = 0, pretend = 0, frame = 0
 3306              		@ frame_needed = 1, uses_anonymous_args = 0
 3307 0000 80B5     		push	{r7, lr}
 3308              		.cfi_def_cfa_offset 8
 3309              		.cfi_offset 7, -8
 3310              		.cfi_offset 14, -4
 3311 0002 00AF     		add	r7, sp, #0
 3312              		.cfi_def_cfa_register 7
 885:../drivers/fsl_clock.c ****     OSC0->CR = 0U;
 3313              		.loc 2 885 9
 3314 0004 064B     		ldr	r3, .L228
 3315              		.loc 2 885 14
 3316 0006 0022     		movs	r2, #0
 3317 0008 1A70     		strb	r2, [r3]
 886:../drivers/fsl_clock.c ****     MCG->C2 &= ~OSC_MODE_MASK;
 3318              		.loc 2 886 13
 3319 000a 064B     		ldr	r3, .L228+4
 3320 000c 5B78     		ldrb	r3, [r3, #1]
 3321 000e DBB2     		uxtb	r3, r3
 3322 0010 044A     		ldr	r2, .L228+4
 3323 0012 3C21     		movs	r1, #60
 3324 0014 8B43     		bics	r3, r1
 3325 0016 DBB2     		uxtb	r3, r3
 3326 0018 5370     		strb	r3, [r2, #1]
 887:../drivers/fsl_clock.c **** }
 3327              		.loc 2 887 1
 3328 001a C046     		nop
 3329 001c BD46     		mov	sp, r7
 3330              		@ sp needed
 3331 001e 80BD     		pop	{r7, pc}
 3332              	.L229:
 3333              		.align	2
 3334              	.L228:
 3335 0020 00500640 		.word	1074155520
 3336 0024 00400640 		.word	1074151424
 3337              		.cfi_endproc
 3338              	.LFE87:
 3340              		.section	.text.CLOCK_TrimInternalRefClk,"ax",%progbits
 3341              		.align	1
 3342              		.global	CLOCK_TrimInternalRefClk
 3343              		.syntax unified
 3344              		.code	16
 3345              		.thumb_func
 3346              		.fpu softvfp
 3348              	CLOCK_TrimInternalRefClk:
 3349              	.LFB88:
 888:../drivers/fsl_clock.c **** 
 889:../drivers/fsl_clock.c **** status_t CLOCK_TrimInternalRefClk(uint32_t extFreq, uint32_t desireFreq, uint32_t *actualFreq, mcg_
 890:../drivers/fsl_clock.c **** {
 3350              		.loc 2 890 1
 3351              		.cfi_startproc
 3352              		@ args = 0, pretend = 0, frame = 32
 3353              		@ frame_needed = 1, uses_anonymous_args = 0
 3354 0000 80B5     		push	{r7, lr}
 3355              		.cfi_def_cfa_offset 8
 3356              		.cfi_offset 7, -8
 3357              		.cfi_offset 14, -4
 3358 0002 88B0     		sub	sp, sp, #32
 3359              		.cfi_def_cfa_offset 40
 3360 0004 00AF     		add	r7, sp, #0
 3361              		.cfi_def_cfa_register 7
 3362 0006 F860     		str	r0, [r7, #12]
 3363 0008 B960     		str	r1, [r7, #8]
 3364 000a 7A60     		str	r2, [r7, #4]
 3365 000c 1A00     		movs	r2, r3
 3366 000e FB1C     		adds	r3, r7, #3
 3367 0010 1A70     		strb	r2, [r3]
 891:../drivers/fsl_clock.c ****     uint32_t multi; /* extFreq / desireFreq */
 892:../drivers/fsl_clock.c ****     uint32_t actv;  /* Auto trim value. */
 893:../drivers/fsl_clock.c ****     uint8_t mcg_sc;
 894:../drivers/fsl_clock.c **** 
 895:../drivers/fsl_clock.c ****     static const uint32_t trimRange[2][2] = {
 896:../drivers/fsl_clock.c ****         /*     Min           Max      */
 897:../drivers/fsl_clock.c ****         {TRIM_SIRC_MIN, TRIM_SIRC_MAX}, /* Slow IRC. */
 898:../drivers/fsl_clock.c ****         {TRIM_FIRC_MIN, TRIM_FIRC_MAX}  /* Fast IRC. */
 899:../drivers/fsl_clock.c ****     };
 900:../drivers/fsl_clock.c **** 
 901:../drivers/fsl_clock.c ****     if ((extFreq > TRIM_REF_CLK_MAX) || (extFreq < TRIM_REF_CLK_MIN))
 3368              		.loc 2 901 8
 3369 0012 FB68     		ldr	r3, [r7, #12]
 3370 0014 4A4A     		ldr	r2, .L242
 3371 0016 9342     		cmp	r3, r2
 3372 0018 03D8     		bhi	.L231
 3373              		.loc 2 901 38 discriminator 1
 3374 001a FB68     		ldr	r3, [r7, #12]
 3375 001c 494A     		ldr	r2, .L242+4
 3376 001e 9342     		cmp	r3, r2
 3377 0020 01D8     		bhi	.L232
 3378              	.L231:
 902:../drivers/fsl_clock.c ****     {
 903:../drivers/fsl_clock.c ****         return kStatus_MCG_AtmBusClockInvalid;
 3379              		.loc 2 903 16
 3380 0022 494B     		ldr	r3, .L242+8
 3381 0024 87E0     		b	.L233
 3382              	.L232:
 904:../drivers/fsl_clock.c ****     }
 905:../drivers/fsl_clock.c **** 
 906:../drivers/fsl_clock.c ****     /* Check desired frequency range. */
 907:../drivers/fsl_clock.c ****     if ((desireFreq < trimRange[atms][0]) || (desireFreq > trimRange[atms][1]))
 3383              		.loc 2 907 38
 3384 0026 FB1C     		adds	r3, r7, #3
 3385 0028 1A78     		ldrb	r2, [r3]
 3386 002a 484B     		ldr	r3, .L242+12
 3387 002c D200     		lsls	r2, r2, #3
 3388 002e D358     		ldr	r3, [r2, r3]
 3389              		.loc 2 907 8
 3390 0030 BA68     		ldr	r2, [r7, #8]
 3391 0032 9A42     		cmp	r2, r3
 3392 0034 09D3     		bcc	.L234
 3393              		.loc 2 907 75 discriminator 1
 3394 0036 FB1C     		adds	r3, r7, #3
 3395 0038 1B78     		ldrb	r3, [r3]
 3396 003a 444A     		ldr	r2, .L242+12
 3397 003c DB00     		lsls	r3, r3, #3
 3398 003e D318     		adds	r3, r2, r3
 3399 0040 0433     		adds	r3, r3, #4
 3400 0042 1B68     		ldr	r3, [r3]
 3401              		.loc 2 907 43 discriminator 1
 3402 0044 BA68     		ldr	r2, [r7, #8]
 3403 0046 9A42     		cmp	r2, r3
 3404 0048 01D9     		bls	.L235
 3405              	.L234:
 908:../drivers/fsl_clock.c ****     {
 909:../drivers/fsl_clock.c ****         return kStatus_MCG_AtmDesiredFreqInvalid;
 3406              		.loc 2 909 16
 3407 004a 414B     		ldr	r3, .L242+16
 3408 004c 73E0     		b	.L233
 3409              	.L235:
 910:../drivers/fsl_clock.c ****     }
 911:../drivers/fsl_clock.c **** 
 912:../drivers/fsl_clock.c ****     /*
 913:../drivers/fsl_clock.c ****        Make sure internal reference clock is not used to generate bus clock.
 914:../drivers/fsl_clock.c ****        Here only need to check (MCG_S_IREFST == 1).
 915:../drivers/fsl_clock.c ****      */
 916:../drivers/fsl_clock.c ****     if (MCG_S_IREFST(kMCG_FllSrcInternal) == (MCG->S & MCG_S_IREFST_MASK))
 3410              		.loc 2 916 50
 3411 004e 414B     		ldr	r3, .L242+20
 3412 0050 9B79     		ldrb	r3, [r3, #6]
 3413 0052 DBB2     		uxtb	r3, r3
 3414              		.loc 2 916 54
 3415 0054 1A00     		movs	r2, r3
 3416 0056 1023     		movs	r3, #16
 3417 0058 1340     		ands	r3, r2
 3418              		.loc 2 916 8
 3419 005a 102B     		cmp	r3, #16
 3420 005c 01D1     		bne	.L236
 917:../drivers/fsl_clock.c ****     {
 918:../drivers/fsl_clock.c ****         return kStatus_MCG_AtmIrcUsed;
 3421              		.loc 2 918 16
 3422 005e 3E4B     		ldr	r3, .L242+24
 3423 0060 69E0     		b	.L233
 3424              	.L236:
 919:../drivers/fsl_clock.c ****     }
 920:../drivers/fsl_clock.c **** 
 921:../drivers/fsl_clock.c ****     multi = extFreq / desireFreq;
 3425              		.loc 2 921 11
 3426 0062 B968     		ldr	r1, [r7, #8]
 3427 0064 F868     		ldr	r0, [r7, #12]
 3428 0066 FFF7FEFF 		bl	__aeabi_uidiv
 3429              	.LVL17:
 3430 006a 0300     		movs	r3, r0
 3431 006c BB61     		str	r3, [r7, #24]
 922:../drivers/fsl_clock.c ****     actv = multi * 21U;
 3432              		.loc 2 922 10
 3433 006e BA69     		ldr	r2, [r7, #24]
 3434 0070 1300     		movs	r3, r2
 3435 0072 5B00     		lsls	r3, r3, #1
 3436 0074 9B18     		adds	r3, r3, r2
 3437 0076 DA00     		lsls	r2, r3, #3
 3438 0078 D31A     		subs	r3, r2, r3
 3439 007a FB61     		str	r3, [r7, #28]
 923:../drivers/fsl_clock.c **** 
 924:../drivers/fsl_clock.c ****     if (kMCG_AtmSel4m == atms)
 3440              		.loc 2 924 8
 3441 007c FB1C     		adds	r3, r7, #3
 3442 007e 1B78     		ldrb	r3, [r3]
 3443 0080 012B     		cmp	r3, #1
 3444 0082 02D1     		bne	.L237
 925:../drivers/fsl_clock.c ****     {
 926:../drivers/fsl_clock.c ****         actv *= 128U;
 3445              		.loc 2 926 14
 3446 0084 FB69     		ldr	r3, [r7, #28]
 3447 0086 DB01     		lsls	r3, r3, #7
 3448 0088 FB61     		str	r3, [r7, #28]
 3449              	.L237:
 927:../drivers/fsl_clock.c ****     }
 928:../drivers/fsl_clock.c **** 
 929:../drivers/fsl_clock.c ****     /* Now begin to start trim. */
 930:../drivers/fsl_clock.c ****     MCG->ATCVL = (uint8_t)actv;
 3450              		.loc 2 930 8
 3451 008a 324B     		ldr	r3, .L242+20
 3452              		.loc 2 930 18
 3453 008c FA69     		ldr	r2, [r7, #28]
 3454 008e D2B2     		uxtb	r2, r2
 3455              		.loc 2 930 16
 3456 0090 DA72     		strb	r2, [r3, #11]
 931:../drivers/fsl_clock.c ****     MCG->ATCVH = (uint8_t)(actv >> 8U);
 3457              		.loc 2 931 33
 3458 0092 FB69     		ldr	r3, [r7, #28]
 3459 0094 1A0A     		lsrs	r2, r3, #8
 3460              		.loc 2 931 8
 3461 0096 2F4B     		ldr	r3, .L242+20
 3462              		.loc 2 931 18
 3463 0098 D2B2     		uxtb	r2, r2
 3464              		.loc 2 931 16
 3465 009a 9A72     		strb	r2, [r3, #10]
 932:../drivers/fsl_clock.c **** 
 933:../drivers/fsl_clock.c ****     mcg_sc = MCG->SC;
 3466              		.loc 2 933 17
 3467 009c 2D4A     		ldr	r2, .L242+20
 3468              		.loc 2 933 12
 3469 009e 1720     		movs	r0, #23
 3470 00a0 3B18     		adds	r3, r7, r0
 3471 00a2 127A     		ldrb	r2, [r2, #8]
 3472 00a4 1A70     		strb	r2, [r3]
 934:../drivers/fsl_clock.c ****     mcg_sc &= ~(MCG_SC_ATMS_MASK | MCG_SC_LOCS0_MASK);
 3473              		.loc 2 934 12
 3474 00a6 3B18     		adds	r3, r7, r0
 3475 00a8 3A18     		adds	r2, r7, r0
 3476 00aa 1278     		ldrb	r2, [r2]
 3477 00ac 4121     		movs	r1, #65
 3478 00ae 8A43     		bics	r2, r1
 3479 00b0 1A70     		strb	r2, [r3]
 935:../drivers/fsl_clock.c ****     mcg_sc |= (MCG_SC_ATMF_MASK | MCG_SC_ATMS(atms));
 3480              		.loc 2 935 35
 3481 00b2 FB1C     		adds	r3, r7, #3
 3482 00b4 1B78     		ldrb	r3, [r3]
 3483 00b6 9B01     		lsls	r3, r3, #6
 3484 00b8 DBB2     		uxtb	r3, r3
 3485 00ba 4022     		movs	r2, #64
 3486 00bc 1340     		ands	r3, r2
 3487 00be DAB2     		uxtb	r2, r3
 3488              		.loc 2 935 12
 3489 00c0 3B18     		adds	r3, r7, r0
 3490 00c2 1B78     		ldrb	r3, [r3]
 3491 00c4 1343     		orrs	r3, r2
 3492 00c6 DAB2     		uxtb	r2, r3
 3493 00c8 3B18     		adds	r3, r7, r0
 3494 00ca 2021     		movs	r1, #32
 3495 00cc 0A43     		orrs	r2, r1
 3496 00ce 1A70     		strb	r2, [r3]
 936:../drivers/fsl_clock.c ****     MCG->SC = (mcg_sc | MCG_SC_ATME_MASK);
 3497              		.loc 2 936 8
 3498 00d0 2049     		ldr	r1, .L242+20
 3499              		.loc 2 936 13
 3500 00d2 3B18     		adds	r3, r7, r0
 3501 00d4 1B78     		ldrb	r3, [r3]
 3502 00d6 8022     		movs	r2, #128
 3503 00d8 5242     		rsbs	r2, r2, #0
 3504 00da 1343     		orrs	r3, r2
 3505 00dc DBB2     		uxtb	r3, r3
 3506 00de 0B72     		strb	r3, [r1, #8]
 937:../drivers/fsl_clock.c **** 
 938:../drivers/fsl_clock.c ****     /* Wait for finished. */
 939:../drivers/fsl_clock.c ****     while (MCG->SC & MCG_SC_ATME_MASK)
 3507              		.loc 2 939 11
 3508 00e0 C046     		nop
 3509              	.L238:
 3510              		.loc 2 939 15 discriminator 1
 3511 00e2 1C4B     		ldr	r3, .L242+20
 3512 00e4 1B7A     		ldrb	r3, [r3, #8]
 3513 00e6 DBB2     		uxtb	r3, r3
 3514              		.loc 2 939 12 discriminator 1
 3515 00e8 5BB2     		sxtb	r3, r3
 3516              		.loc 2 939 11 discriminator 1
 3517 00ea 002B     		cmp	r3, #0
 3518 00ec F9DB     		blt	.L238
 940:../drivers/fsl_clock.c ****     {
 941:../drivers/fsl_clock.c ****     }
 942:../drivers/fsl_clock.c **** 
 943:../drivers/fsl_clock.c ****     /* Error occurs? */
 944:../drivers/fsl_clock.c ****     if (MCG->SC & MCG_SC_ATMF_MASK)
 3519              		.loc 2 944 12
 3520 00ee 194B     		ldr	r3, .L242+20
 3521 00f0 1B7A     		ldrb	r3, [r3, #8]
 3522 00f2 DBB2     		uxtb	r3, r3
 3523              		.loc 2 944 17
 3524 00f4 1A00     		movs	r2, r3
 3525 00f6 2023     		movs	r3, #32
 3526 00f8 1340     		ands	r3, r2
 3527              		.loc 2 944 8
 3528 00fa 06D0     		beq	.L239
 945:../drivers/fsl_clock.c ****     {
 946:../drivers/fsl_clock.c ****         /* Clear the failed flag. */
 947:../drivers/fsl_clock.c ****         MCG->SC = mcg_sc;
 3529              		.loc 2 947 12
 3530 00fc 154A     		ldr	r2, .L242+20
 3531              		.loc 2 947 17
 3532 00fe 1723     		movs	r3, #23
 3533 0100 FB18     		adds	r3, r7, r3
 3534 0102 1B78     		ldrb	r3, [r3]
 3535 0104 1372     		strb	r3, [r2, #8]
 948:../drivers/fsl_clock.c ****         return kStatus_MCG_AtmHardwareFail;
 3536              		.loc 2 948 16
 3537 0106 154B     		ldr	r3, .L242+28
 3538 0108 15E0     		b	.L233
 3539              	.L239:
 949:../drivers/fsl_clock.c ****     }
 950:../drivers/fsl_clock.c **** 
 951:../drivers/fsl_clock.c ****     *actualFreq = extFreq / multi;
 3540              		.loc 2 951 27
 3541 010a B969     		ldr	r1, [r7, #24]
 3542 010c F868     		ldr	r0, [r7, #12]
 3543 010e FFF7FEFF 		bl	__aeabi_uidiv
 3544              	.LVL18:
 3545 0112 0300     		movs	r3, r0
 3546 0114 1A00     		movs	r2, r3
 3547              		.loc 2 951 17
 3548 0116 7B68     		ldr	r3, [r7, #4]
 3549 0118 1A60     		str	r2, [r3]
 952:../drivers/fsl_clock.c **** 
 953:../drivers/fsl_clock.c ****     if (kMCG_AtmSel4m == atms)
 3550              		.loc 2 953 8
 3551 011a FB1C     		adds	r3, r7, #3
 3552 011c 1B78     		ldrb	r3, [r3]
 3553 011e 012B     		cmp	r3, #1
 3554 0120 04D1     		bne	.L240
 954:../drivers/fsl_clock.c ****     {
 955:../drivers/fsl_clock.c ****         s_fastIrcFreq = *actualFreq;
 3555              		.loc 2 955 25
 3556 0122 7B68     		ldr	r3, [r7, #4]
 3557 0124 1A68     		ldr	r2, [r3]
 3558              		.loc 2 955 23
 3559 0126 0E4B     		ldr	r3, .L242+32
 3560 0128 1A60     		str	r2, [r3]
 3561 012a 03E0     		b	.L241
 3562              	.L240:
 956:../drivers/fsl_clock.c ****     }
 957:../drivers/fsl_clock.c ****     else
 958:../drivers/fsl_clock.c ****     {
 959:../drivers/fsl_clock.c ****         s_slowIrcFreq = *actualFreq;
 3563              		.loc 2 959 25
 3564 012c 7B68     		ldr	r3, [r7, #4]
 3565 012e 1A68     		ldr	r2, [r3]
 3566              		.loc 2 959 23
 3567 0130 0C4B     		ldr	r3, .L242+36
 3568 0132 1A60     		str	r2, [r3]
 3569              	.L241:
 960:../drivers/fsl_clock.c ****     }
 961:../drivers/fsl_clock.c **** 
 962:../drivers/fsl_clock.c ****     return kStatus_Success;
 3570              		.loc 2 962 12
 3571 0134 0023     		movs	r3, #0
 3572              	.L233:
 963:../drivers/fsl_clock.c **** }
 3573              		.loc 2 963 1
 3574 0136 1800     		movs	r0, r3
 3575 0138 BD46     		mov	sp, r7
 3576 013a 08B0     		add	sp, sp, #32
 3577              		@ sp needed
 3578 013c 80BD     		pop	{r7, pc}
 3579              	.L243:
 3580 013e C046     		.align	2
 3581              	.L242:
 3582 0140 0024F400 		.word	16000000
 3583 0144 FF117A00 		.word	7999999
 3584 0148 D2070000 		.word	2002
 3585 014c 00000000 		.word	trimRange.5302
 3586 0150 D3070000 		.word	2003
 3587 0154 00400640 		.word	1074151424
 3588 0158 D4070000 		.word	2004
 3589 015c D5070000 		.word	2005
 3590 0160 00000000 		.word	s_fastIrcFreq
 3591 0164 00000000 		.word	s_slowIrcFreq
 3592              		.cfi_endproc
 3593              	.LFE88:
 3595              		.section	.text.CLOCK_GetMode,"ax",%progbits
 3596              		.align	1
 3597              		.global	CLOCK_GetMode
 3598              		.syntax unified
 3599              		.code	16
 3600              		.thumb_func
 3601              		.fpu softvfp
 3603              	CLOCK_GetMode:
 3604              	.LFB89:
 964:../drivers/fsl_clock.c **** 
 965:../drivers/fsl_clock.c **** mcg_mode_t CLOCK_GetMode(void)
 966:../drivers/fsl_clock.c **** {
 3605              		.loc 2 966 1
 3606              		.cfi_startproc
 3607              		@ args = 0, pretend = 0, frame = 24
 3608              		@ frame_needed = 1, uses_anonymous_args = 0
 3609 0000 80B5     		push	{r7, lr}
 3610              		.cfi_def_cfa_offset 8
 3611              		.cfi_offset 7, -8
 3612              		.cfi_offset 14, -4
 3613 0002 86B0     		sub	sp, sp, #24
 3614              		.cfi_def_cfa_offset 32
 3615 0004 00AF     		add	r7, sp, #0
 3616              		.cfi_def_cfa_register 7
 967:../drivers/fsl_clock.c ****     mcg_mode_t mode = kMCG_ModeError;
 3617              		.loc 2 967 16
 3618 0006 1723     		movs	r3, #23
 3619 0008 FB18     		adds	r3, r7, r3
 3620 000a 0822     		movs	r2, #8
 3621 000c 1A70     		strb	r2, [r3]
 968:../drivers/fsl_clock.c ****     uint32_t clkst = MCG_S_CLKST_VAL;
 3622              		.loc 2 968 22
 3623 000e 354B     		ldr	r3, .L260
 3624 0010 9B79     		ldrb	r3, [r3, #6]
 3625 0012 DBB2     		uxtb	r3, r3
 3626 0014 9B08     		lsrs	r3, r3, #2
 3627              		.loc 2 968 14
 3628 0016 0322     		movs	r2, #3
 3629 0018 1340     		ands	r3, r2
 3630 001a 3B61     		str	r3, [r7, #16]
 969:../drivers/fsl_clock.c ****     uint32_t irefst = MCG_S_IREFST_VAL;
 3631              		.loc 2 969 23
 3632 001c 314B     		ldr	r3, .L260
 3633 001e 9B79     		ldrb	r3, [r3, #6]
 3634 0020 DBB2     		uxtb	r3, r3
 3635 0022 1B09     		lsrs	r3, r3, #4
 3636              		.loc 2 969 14
 3637 0024 0122     		movs	r2, #1
 3638 0026 1340     		ands	r3, r2
 3639 0028 FB60     		str	r3, [r7, #12]
 970:../drivers/fsl_clock.c ****     uint32_t lp = MCG_C2_LP_VAL;
 3640              		.loc 2 970 19
 3641 002a 2E4B     		ldr	r3, .L260
 3642 002c 5B78     		ldrb	r3, [r3, #1]
 3643 002e DBB2     		uxtb	r3, r3
 3644 0030 5B08     		lsrs	r3, r3, #1
 3645              		.loc 2 970 14
 3646 0032 0122     		movs	r2, #1
 3647 0034 1340     		ands	r3, r2
 3648 0036 BB60     		str	r3, [r7, #8]
 971:../drivers/fsl_clock.c ****     uint32_t pllst = MCG_S_PLLST_VAL;
 3649              		.loc 2 971 22
 3650 0038 2A4B     		ldr	r3, .L260
 3651 003a 9B79     		ldrb	r3, [r3, #6]
 3652 003c DBB2     		uxtb	r3, r3
 3653 003e 5B09     		lsrs	r3, r3, #5
 3654              		.loc 2 971 14
 3655 0040 0122     		movs	r2, #1
 3656 0042 1340     		ands	r3, r2
 3657 0044 7B60     		str	r3, [r7, #4]
 972:../drivers/fsl_clock.c **** 
 973:../drivers/fsl_clock.c ****     /*------------------------------------------------------------------
 974:../drivers/fsl_clock.c ****                            Mode and Registers
 975:../drivers/fsl_clock.c ****     ____________________________________________________________________
 976:../drivers/fsl_clock.c **** 
 977:../drivers/fsl_clock.c ****       Mode   |   CLKST    |   IREFST   |   PLLST   |      LP
 978:../drivers/fsl_clock.c ****     ____________________________________________________________________
 979:../drivers/fsl_clock.c **** 
 980:../drivers/fsl_clock.c ****       FEI    |  00(FLL)   |   1(INT)   |   0(FLL)  |      X
 981:../drivers/fsl_clock.c ****     ____________________________________________________________________
 982:../drivers/fsl_clock.c **** 
 983:../drivers/fsl_clock.c ****       FEE    |  00(FLL)   |   0(EXT)   |   0(FLL)  |      X
 984:../drivers/fsl_clock.c ****     ____________________________________________________________________
 985:../drivers/fsl_clock.c **** 
 986:../drivers/fsl_clock.c ****       FBE    |  10(EXT)   |   0(EXT)   |   0(FLL)  |   0(NORMAL)
 987:../drivers/fsl_clock.c ****     ____________________________________________________________________
 988:../drivers/fsl_clock.c **** 
 989:../drivers/fsl_clock.c ****       FBI    |  01(INT)   |   1(INT)   |   0(FLL)  |   0(NORMAL)
 990:../drivers/fsl_clock.c ****     ____________________________________________________________________
 991:../drivers/fsl_clock.c **** 
 992:../drivers/fsl_clock.c ****       BLPI   |  01(INT)   |   1(INT)   |   0(FLL)  |   1(LOW POWER)
 993:../drivers/fsl_clock.c ****     ____________________________________________________________________
 994:../drivers/fsl_clock.c **** 
 995:../drivers/fsl_clock.c ****       BLPE   |  10(EXT)   |   0(EXT)   |     X     |   1(LOW POWER)
 996:../drivers/fsl_clock.c ****     ____________________________________________________________________
 997:../drivers/fsl_clock.c **** 
 998:../drivers/fsl_clock.c ****       PEE    |  11(PLL)   |   0(EXT)   |   1(PLL)  |      X
 999:../drivers/fsl_clock.c ****     ____________________________________________________________________
1000:../drivers/fsl_clock.c **** 
1001:../drivers/fsl_clock.c ****       PBE    |  10(EXT)   |   0(EXT)   |   1(PLL)  |   O(NORMAL)
1002:../drivers/fsl_clock.c ****     ____________________________________________________________________
1003:../drivers/fsl_clock.c **** 
1004:../drivers/fsl_clock.c ****       PBI    |  01(INT)   |   1(INT)   |   1(PLL)  |   0(NORMAL)
1005:../drivers/fsl_clock.c ****     ____________________________________________________________________
1006:../drivers/fsl_clock.c **** 
1007:../drivers/fsl_clock.c ****       PEI    |  11(PLL)   |   1(INT)   |   1(PLL)  |      X
1008:../drivers/fsl_clock.c ****     ____________________________________________________________________
1009:../drivers/fsl_clock.c **** 
1010:../drivers/fsl_clock.c ****     ----------------------------------------------------------------------*/
1011:../drivers/fsl_clock.c **** 
1012:../drivers/fsl_clock.c ****     switch (clkst)
 3658              		.loc 2 1012 5
 3659 0046 3B69     		ldr	r3, [r7, #16]
 3660 0048 032B     		cmp	r3, #3
 3661 004a 3ED0     		beq	.L245
 3662 004c 3B69     		ldr	r3, [r7, #16]
 3663 004e 032B     		cmp	r3, #3
 3664 0050 40D8     		bhi	.L259
 3665 0052 3B69     		ldr	r3, [r7, #16]
 3666 0054 022B     		cmp	r3, #2
 3667 0056 23D0     		beq	.L247
 3668 0058 3B69     		ldr	r3, [r7, #16]
 3669 005a 022B     		cmp	r3, #2
 3670 005c 3AD8     		bhi	.L259
 3671 005e 3B69     		ldr	r3, [r7, #16]
 3672 0060 002B     		cmp	r3, #0
 3673 0062 03D0     		beq	.L248
 3674 0064 3B69     		ldr	r3, [r7, #16]
 3675 0066 012B     		cmp	r3, #1
 3676 0068 0DD0     		beq	.L249
1013:../drivers/fsl_clock.c ****     {
1014:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatFll:
1015:../drivers/fsl_clock.c ****             if (kMCG_FllSrcExternal == irefst)
1016:../drivers/fsl_clock.c ****             {
1017:../drivers/fsl_clock.c ****                 mode = kMCG_ModeFEE;
1018:../drivers/fsl_clock.c ****             }
1019:../drivers/fsl_clock.c ****             else
1020:../drivers/fsl_clock.c ****             {
1021:../drivers/fsl_clock.c ****                 mode = kMCG_ModeFEI;
1022:../drivers/fsl_clock.c ****             }
1023:../drivers/fsl_clock.c ****             break;
1024:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatInt:
1025:../drivers/fsl_clock.c ****             if (lp)
1026:../drivers/fsl_clock.c ****             {
1027:../drivers/fsl_clock.c ****                 mode = kMCG_ModeBLPI;
1028:../drivers/fsl_clock.c ****             }
1029:../drivers/fsl_clock.c ****             else
1030:../drivers/fsl_clock.c ****             {
1031:../drivers/fsl_clock.c ****                 {
1032:../drivers/fsl_clock.c ****                     mode = kMCG_ModeFBI;
1033:../drivers/fsl_clock.c ****                 }
1034:../drivers/fsl_clock.c ****             }
1035:../drivers/fsl_clock.c ****             break;
1036:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatExt:
1037:../drivers/fsl_clock.c ****             if (lp)
1038:../drivers/fsl_clock.c ****             {
1039:../drivers/fsl_clock.c ****                 mode = kMCG_ModeBLPE;
1040:../drivers/fsl_clock.c ****             }
1041:../drivers/fsl_clock.c ****             else
1042:../drivers/fsl_clock.c ****             {
1043:../drivers/fsl_clock.c ****                 if (kMCG_PllstPll == pllst)
1044:../drivers/fsl_clock.c ****                 {
1045:../drivers/fsl_clock.c ****                     mode = kMCG_ModePBE;
1046:../drivers/fsl_clock.c ****                 }
1047:../drivers/fsl_clock.c ****                 else
1048:../drivers/fsl_clock.c ****                 {
1049:../drivers/fsl_clock.c ****                     mode = kMCG_ModeFBE;
1050:../drivers/fsl_clock.c ****                 }
1051:../drivers/fsl_clock.c ****             }
1052:../drivers/fsl_clock.c ****             break;
1053:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatPll:
1054:../drivers/fsl_clock.c ****         {
1055:../drivers/fsl_clock.c ****             mode = kMCG_ModePEE;
1056:../drivers/fsl_clock.c ****         }
1057:../drivers/fsl_clock.c ****         break;
1058:../drivers/fsl_clock.c ****         default:
1059:../drivers/fsl_clock.c ****             break;
 3677              		.loc 2 1059 13
 3678 006a 33E0     		b	.L259
 3679              	.L248:
1015:../drivers/fsl_clock.c ****             {
 3680              		.loc 2 1015 16
 3681 006c FB68     		ldr	r3, [r7, #12]
 3682 006e 002B     		cmp	r3, #0
 3683 0070 04D1     		bne	.L250
1017:../drivers/fsl_clock.c ****             }
 3684              		.loc 2 1017 22
 3685 0072 1723     		movs	r3, #23
 3686 0074 FB18     		adds	r3, r7, r3
 3687 0076 0322     		movs	r2, #3
 3688 0078 1A70     		strb	r2, [r3]
1023:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatInt:
 3689              		.loc 2 1023 13
 3690 007a 2CE0     		b	.L252
 3691              	.L250:
1021:../drivers/fsl_clock.c ****             }
 3692              		.loc 2 1021 22
 3693 007c 1723     		movs	r3, #23
 3694 007e FB18     		adds	r3, r7, r3
 3695 0080 0022     		movs	r2, #0
 3696 0082 1A70     		strb	r2, [r3]
1023:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatInt:
 3697              		.loc 2 1023 13
 3698 0084 27E0     		b	.L252
 3699              	.L249:
1025:../drivers/fsl_clock.c ****             {
 3700              		.loc 2 1025 16
 3701 0086 BB68     		ldr	r3, [r7, #8]
 3702 0088 002B     		cmp	r3, #0
 3703 008a 04D0     		beq	.L253
1027:../drivers/fsl_clock.c ****             }
 3704              		.loc 2 1027 22
 3705 008c 1723     		movs	r3, #23
 3706 008e FB18     		adds	r3, r7, r3
 3707 0090 0222     		movs	r2, #2
 3708 0092 1A70     		strb	r2, [r3]
1035:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatExt:
 3709              		.loc 2 1035 13
 3710 0094 1FE0     		b	.L252
 3711              	.L253:
1032:../drivers/fsl_clock.c ****                 }
 3712              		.loc 2 1032 26
 3713 0096 1723     		movs	r3, #23
 3714 0098 FB18     		adds	r3, r7, r3
 3715 009a 0122     		movs	r2, #1
 3716 009c 1A70     		strb	r2, [r3]
1035:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatExt:
 3717              		.loc 2 1035 13
 3718 009e 1AE0     		b	.L252
 3719              	.L247:
1037:../drivers/fsl_clock.c ****             {
 3720              		.loc 2 1037 16
 3721 00a0 BB68     		ldr	r3, [r7, #8]
 3722 00a2 002B     		cmp	r3, #0
 3723 00a4 04D0     		beq	.L255
1039:../drivers/fsl_clock.c ****             }
 3724              		.loc 2 1039 22
 3725 00a6 1723     		movs	r3, #23
 3726 00a8 FB18     		adds	r3, r7, r3
 3727 00aa 0522     		movs	r2, #5
 3728 00ac 1A70     		strb	r2, [r3]
1052:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatPll:
 3729              		.loc 2 1052 13
 3730 00ae 12E0     		b	.L252
 3731              	.L255:
1043:../drivers/fsl_clock.c ****                 {
 3732              		.loc 2 1043 20
 3733 00b0 7B68     		ldr	r3, [r7, #4]
 3734 00b2 012B     		cmp	r3, #1
 3735 00b4 04D1     		bne	.L257
1045:../drivers/fsl_clock.c ****                 }
 3736              		.loc 2 1045 26
 3737 00b6 1723     		movs	r3, #23
 3738 00b8 FB18     		adds	r3, r7, r3
 3739 00ba 0622     		movs	r2, #6
 3740 00bc 1A70     		strb	r2, [r3]
1052:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatPll:
 3741              		.loc 2 1052 13
 3742 00be 0AE0     		b	.L252
 3743              	.L257:
1049:../drivers/fsl_clock.c ****                 }
 3744              		.loc 2 1049 26
 3745 00c0 1723     		movs	r3, #23
 3746 00c2 FB18     		adds	r3, r7, r3
 3747 00c4 0422     		movs	r2, #4
 3748 00c6 1A70     		strb	r2, [r3]
1052:../drivers/fsl_clock.c ****         case kMCG_ClkOutStatPll:
 3749              		.loc 2 1052 13
 3750 00c8 05E0     		b	.L252
 3751              	.L245:
1055:../drivers/fsl_clock.c ****         }
 3752              		.loc 2 1055 18
 3753 00ca 1723     		movs	r3, #23
 3754 00cc FB18     		adds	r3, r7, r3
 3755 00ce 0722     		movs	r2, #7
 3756 00d0 1A70     		strb	r2, [r3]
1057:../drivers/fsl_clock.c ****         default:
 3757              		.loc 2 1057 9
 3758 00d2 00E0     		b	.L252
 3759              	.L259:
 3760              		.loc 2 1059 13
 3761 00d4 C046     		nop
 3762              	.L252:
1060:../drivers/fsl_clock.c ****     }
1061:../drivers/fsl_clock.c **** 
1062:../drivers/fsl_clock.c ****     return mode;
 3763              		.loc 2 1062 12
 3764 00d6 1723     		movs	r3, #23
 3765 00d8 FB18     		adds	r3, r7, r3
 3766 00da 1B78     		ldrb	r3, [r3]
1063:../drivers/fsl_clock.c **** }
 3767              		.loc 2 1063 1
 3768 00dc 1800     		movs	r0, r3
 3769 00de BD46     		mov	sp, r7
 3770 00e0 06B0     		add	sp, sp, #24
 3771              		@ sp needed
 3772 00e2 80BD     		pop	{r7, pc}
 3773              	.L261:
 3774              		.align	2
 3775              	.L260:
 3776 00e4 00400640 		.word	1074151424
 3777              		.cfi_endproc
 3778              	.LFE89:
 3780              		.section	.text.CLOCK_SetFeiMode,"ax",%progbits
 3781              		.align	1
 3782              		.global	CLOCK_SetFeiMode
 3783              		.syntax unified
 3784              		.code	16
 3785              		.thumb_func
 3786              		.fpu softvfp
 3788              	CLOCK_SetFeiMode:
 3789              	.LFB90:
1064:../drivers/fsl_clock.c **** 
1065:../drivers/fsl_clock.c **** status_t CLOCK_SetFeiMode(mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(void))
1066:../drivers/fsl_clock.c **** {
 3790              		.loc 2 1066 1
 3791              		.cfi_startproc
 3792              		@ args = 0, pretend = 0, frame = 16
 3793              		@ frame_needed = 1, uses_anonymous_args = 0
 3794 0000 80B5     		push	{r7, lr}
 3795              		.cfi_def_cfa_offset 8
 3796              		.cfi_offset 7, -8
 3797              		.cfi_offset 14, -4
 3798 0002 84B0     		sub	sp, sp, #16
 3799              		.cfi_def_cfa_offset 24
 3800 0004 00AF     		add	r7, sp, #0
 3801              		.cfi_def_cfa_register 7
 3802 0006 3A60     		str	r2, [r7]
 3803 0008 FB1D     		adds	r3, r7, #7
 3804 000a 021C     		adds	r2, r0, #0
 3805 000c 1A70     		strb	r2, [r3]
 3806 000e BB1D     		adds	r3, r7, #6
 3807 0010 0A1C     		adds	r2, r1, #0
 3808 0012 1A70     		strb	r2, [r3]
1067:../drivers/fsl_clock.c ****     uint8_t mcg_c4;
1068:../drivers/fsl_clock.c ****     bool change_drs = false;
 3809              		.loc 2 1068 10
 3810 0014 0F21     		movs	r1, #15
 3811 0016 7B18     		adds	r3, r7, r1
 3812 0018 0022     		movs	r2, #0
 3813 001a 1A70     		strb	r2, [r3]
1069:../drivers/fsl_clock.c **** 
1070:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1071:../drivers/fsl_clock.c ****     mcg_mode_t mode = CLOCK_GetMode();
1072:../drivers/fsl_clock.c ****     if (!((kMCG_ModeFEI == mode) || (kMCG_ModeFBI == mode) || (kMCG_ModeFBE == mode) || (kMCG_ModeF
1073:../drivers/fsl_clock.c ****     {
1074:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeUnreachable;
1075:../drivers/fsl_clock.c ****     }
1076:../drivers/fsl_clock.c **** #endif
1077:../drivers/fsl_clock.c ****     mcg_c4 = MCG->C4;
 3814              		.loc 2 1077 17
 3815 001c 2E4A     		ldr	r2, .L269
 3816              		.loc 2 1077 12
 3817 001e 0E23     		movs	r3, #14
 3818 0020 FB18     		adds	r3, r7, r3
 3819 0022 D278     		ldrb	r2, [r2, #3]
 3820 0024 1A70     		strb	r2, [r3]
1078:../drivers/fsl_clock.c **** 
1079:../drivers/fsl_clock.c ****     /*
1080:../drivers/fsl_clock.c ****        Errata: ERR007993
1081:../drivers/fsl_clock.c ****        Workaround: Invert MCG_C4[DMX32] or change MCG_C4[DRST_DRS] before
1082:../drivers/fsl_clock.c ****        reference clock source changes, then reset to previous value after
1083:../drivers/fsl_clock.c ****        reference clock changes.
1084:../drivers/fsl_clock.c ****      */
1085:../drivers/fsl_clock.c ****     if (kMCG_FllSrcExternal == MCG_S_IREFST_VAL)
 3821              		.loc 2 1085 32
 3822 0026 2C4B     		ldr	r3, .L269
 3823 0028 9B79     		ldrb	r3, [r3, #6]
 3824 002a DBB2     		uxtb	r3, r3
 3825              		.loc 2 1085 29
 3826 002c 1A00     		movs	r2, r3
 3827 002e 1023     		movs	r3, #16
 3828 0030 1340     		ands	r3, r2
 3829              		.loc 2 1085 8
 3830 0032 0AD1     		bne	.L263
1086:../drivers/fsl_clock.c ****     {
1087:../drivers/fsl_clock.c ****         change_drs = true;
 3831              		.loc 2 1087 20
 3832 0034 7B18     		adds	r3, r7, r1
 3833 0036 0122     		movs	r2, #1
 3834 0038 1A70     		strb	r2, [r3]
1088:../drivers/fsl_clock.c ****         /* Change the LSB of DRST_DRS. */
1089:../drivers/fsl_clock.c ****         MCG->C4 ^= (1U << MCG_C4_DRST_DRS_SHIFT);
 3835              		.loc 2 1089 17
 3836 003a 274B     		ldr	r3, .L269
 3837 003c DB78     		ldrb	r3, [r3, #3]
 3838 003e DBB2     		uxtb	r3, r3
 3839 0040 254A     		ldr	r2, .L269
 3840 0042 2021     		movs	r1, #32
 3841 0044 4B40     		eors	r3, r1
 3842 0046 DBB2     		uxtb	r3, r3
 3843 0048 D370     		strb	r3, [r2, #3]
 3844              	.L263:
1090:../drivers/fsl_clock.c ****     }
1091:../drivers/fsl_clock.c **** 
1092:../drivers/fsl_clock.c ****     /* Set CLKS and IREFS. */
1093:../drivers/fsl_clock.c ****     MCG->C1 =
1094:../drivers/fsl_clock.c ****         ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK))) | (MCG_C1_CLKS(kMCG_ClkOutSrcOut)    
 3845              		.loc 2 1094 14
 3846 004a 234B     		ldr	r3, .L269
 3847 004c 1B78     		ldrb	r3, [r3]
 3848 004e DBB2     		uxtb	r3, r3
 3849              		.loc 2 1094 19
 3850 0050 3B22     		movs	r2, #59
 3851 0052 1340     		ands	r3, r2
 3852 0054 DBB2     		uxtb	r3, r3
1093:../drivers/fsl_clock.c ****         ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK))) | (MCG_C1_CLKS(kMCG_ClkOutSrcOut)    
 3853              		.loc 2 1093 8
 3854 0056 204A     		ldr	r2, .L269
 3855              		.loc 2 1094 63
 3856 0058 0421     		movs	r1, #4
 3857 005a 0B43     		orrs	r3, r1
 3858 005c DBB2     		uxtb	r3, r3
1093:../drivers/fsl_clock.c ****         ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK))) | (MCG_C1_CLKS(kMCG_ClkOutSrcOut)    
 3859              		.loc 2 1093 13
 3860 005e 1370     		strb	r3, [r2]
1095:../drivers/fsl_clock.c ****                                                                  | MCG_C1_IREFS(kMCG_FllSrcInternal
1096:../drivers/fsl_clock.c **** 
1097:../drivers/fsl_clock.c ****     /* Wait and check status. */
1098:../drivers/fsl_clock.c ****     while (kMCG_FllSrcInternal != MCG_S_IREFST_VAL)
 3861              		.loc 2 1098 11
 3862 0060 C046     		nop
 3863              	.L264:
 3864              		.loc 2 1098 35 discriminator 1
 3865 0062 1D4B     		ldr	r3, .L269
 3866 0064 9B79     		ldrb	r3, [r3, #6]
 3867 0066 DBB2     		uxtb	r3, r3
 3868 0068 1B09     		lsrs	r3, r3, #4
 3869 006a 0122     		movs	r2, #1
 3870 006c 1340     		ands	r3, r2
 3871              		.loc 2 1098 11 discriminator 1
 3872 006e 012B     		cmp	r3, #1
 3873 0070 F7D1     		bne	.L264
1099:../drivers/fsl_clock.c ****     {
1100:../drivers/fsl_clock.c ****     }
1101:../drivers/fsl_clock.c **** 
1102:../drivers/fsl_clock.c ****     /* Errata: ERR007993 */
1103:../drivers/fsl_clock.c ****     if (change_drs)
 3874              		.loc 2 1103 8
 3875 0072 0F23     		movs	r3, #15
 3876 0074 FB18     		adds	r3, r7, r3
 3877 0076 1B78     		ldrb	r3, [r3]
 3878 0078 002B     		cmp	r3, #0
 3879 007a 04D0     		beq	.L265
1104:../drivers/fsl_clock.c ****     {
1105:../drivers/fsl_clock.c ****         MCG->C4 = mcg_c4;
 3880              		.loc 2 1105 12
 3881 007c 164A     		ldr	r2, .L269
 3882              		.loc 2 1105 17
 3883 007e 0E23     		movs	r3, #14
 3884 0080 FB18     		adds	r3, r7, r3
 3885 0082 1B78     		ldrb	r3, [r3]
 3886 0084 D370     		strb	r3, [r2, #3]
 3887              	.L265:
1106:../drivers/fsl_clock.c ****     }
1107:../drivers/fsl_clock.c **** 
1108:../drivers/fsl_clock.c ****     /* In FEI mode, the MCG_C4[DMX32] is set to 0U. */
1109:../drivers/fsl_clock.c ****     MCG->C4 = (mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) | (MCG_C4_DMX32(dmx32) | MCG_C
 3888              		.loc 2 1109 23
 3889 0086 0E23     		movs	r3, #14
 3890 0088 FB18     		adds	r3, r7, r3
 3891 008a 1B78     		ldrb	r3, [r3]
 3892 008c 1F22     		movs	r2, #31
 3893 008e 1340     		ands	r3, r2
 3894 0090 DAB2     		uxtb	r2, r3
 3895              		.loc 2 1109 73
 3896 0092 FB1D     		adds	r3, r7, #7
 3897 0094 1B78     		ldrb	r3, [r3]
 3898 0096 DB01     		lsls	r3, r3, #7
 3899 0098 D9B2     		uxtb	r1, r3
 3900              		.loc 2 1109 95
 3901 009a BB1D     		adds	r3, r7, #6
 3902 009c 1B78     		ldrb	r3, [r3]
 3903 009e 5B01     		lsls	r3, r3, #5
 3904 00a0 DBB2     		uxtb	r3, r3
 3905 00a2 6020     		movs	r0, #96
 3906 00a4 0340     		ands	r3, r0
 3907 00a6 DBB2     		uxtb	r3, r3
 3908              		.loc 2 1109 93
 3909 00a8 0B43     		orrs	r3, r1
 3910 00aa DBB2     		uxtb	r3, r3
 3911              		.loc 2 1109 8
 3912 00ac 0A49     		ldr	r1, .L269
 3913              		.loc 2 1109 70
 3914 00ae 1343     		orrs	r3, r2
 3915 00b0 DBB2     		uxtb	r3, r3
 3916              		.loc 2 1109 13
 3917 00b2 CB70     		strb	r3, [r1, #3]
1110:../drivers/fsl_clock.c **** 
1111:../drivers/fsl_clock.c ****     /* Check MCG_S[CLKST] */
1112:../drivers/fsl_clock.c ****     while (kMCG_ClkOutStatFll != MCG_S_CLKST_VAL)
 3918              		.loc 2 1112 11
 3919 00b4 C046     		nop
 3920              	.L266:
 3921              		.loc 2 1112 34 discriminator 1
 3922 00b6 084B     		ldr	r3, .L269
 3923 00b8 9B79     		ldrb	r3, [r3, #6]
 3924 00ba DBB2     		uxtb	r3, r3
 3925 00bc 9B08     		lsrs	r3, r3, #2
 3926 00be 0322     		movs	r2, #3
 3927 00c0 1340     		ands	r3, r2
 3928              		.loc 2 1112 11 discriminator 1
 3929 00c2 F8D1     		bne	.L266
1113:../drivers/fsl_clock.c ****     {
1114:../drivers/fsl_clock.c ****     }
1115:../drivers/fsl_clock.c **** 
1116:../drivers/fsl_clock.c ****     /* Wait for FLL stable time. */
1117:../drivers/fsl_clock.c ****     if (fllStableDelay)
 3930              		.loc 2 1117 8
 3931 00c4 3B68     		ldr	r3, [r7]
 3932 00c6 002B     		cmp	r3, #0
 3933 00c8 01D0     		beq	.L267
1118:../drivers/fsl_clock.c ****     {
1119:../drivers/fsl_clock.c ****         fllStableDelay();
 3934              		.loc 2 1119 9
 3935 00ca 3B68     		ldr	r3, [r7]
 3936 00cc 9847     		blx	r3
 3937              	.LVL19:
 3938              	.L267:
1120:../drivers/fsl_clock.c ****     }
1121:../drivers/fsl_clock.c **** 
1122:../drivers/fsl_clock.c ****     return kStatus_Success;
 3939              		.loc 2 1122 12
 3940 00ce 0023     		movs	r3, #0
1123:../drivers/fsl_clock.c **** }
 3941              		.loc 2 1123 1
 3942 00d0 1800     		movs	r0, r3
 3943 00d2 BD46     		mov	sp, r7
 3944 00d4 04B0     		add	sp, sp, #16
 3945              		@ sp needed
 3946 00d6 80BD     		pop	{r7, pc}
 3947              	.L270:
 3948              		.align	2
 3949              	.L269:
 3950 00d8 00400640 		.word	1074151424
 3951              		.cfi_endproc
 3952              	.LFE90:
 3954              		.section	.text.CLOCK_SetFeeMode,"ax",%progbits
 3955              		.align	1
 3956              		.global	CLOCK_SetFeeMode
 3957              		.syntax unified
 3958              		.code	16
 3959              		.thumb_func
 3960              		.fpu softvfp
 3962              	CLOCK_SetFeeMode:
 3963              	.LFB91:
1124:../drivers/fsl_clock.c **** 
1125:../drivers/fsl_clock.c **** status_t CLOCK_SetFeeMode(uint8_t frdiv, mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(v
1126:../drivers/fsl_clock.c **** {
 3964              		.loc 2 1126 1
 3965              		.cfi_startproc
 3966              		@ args = 0, pretend = 0, frame = 16
 3967              		@ frame_needed = 1, uses_anonymous_args = 0
 3968 0000 90B5     		push	{r4, r7, lr}
 3969              		.cfi_def_cfa_offset 12
 3970              		.cfi_offset 4, -12
 3971              		.cfi_offset 7, -8
 3972              		.cfi_offset 14, -4
 3973 0002 85B0     		sub	sp, sp, #20
 3974              		.cfi_def_cfa_offset 32
 3975 0004 00AF     		add	r7, sp, #0
 3976              		.cfi_def_cfa_register 7
 3977 0006 0400     		movs	r4, r0
 3978 0008 0800     		movs	r0, r1
 3979 000a 1100     		movs	r1, r2
 3980 000c 3B60     		str	r3, [r7]
 3981 000e FB1D     		adds	r3, r7, #7
 3982 0010 221C     		adds	r2, r4, #0
 3983 0012 1A70     		strb	r2, [r3]
 3984 0014 BB1D     		adds	r3, r7, #6
 3985 0016 021C     		adds	r2, r0, #0
 3986 0018 1A70     		strb	r2, [r3]
 3987 001a 7B1D     		adds	r3, r7, #5
 3988 001c 0A1C     		adds	r2, r1, #0
 3989 001e 1A70     		strb	r2, [r3]
1127:../drivers/fsl_clock.c ****     uint8_t mcg_c4;
1128:../drivers/fsl_clock.c ****     bool change_drs = false;
 3990              		.loc 2 1128 10
 3991 0020 0F21     		movs	r1, #15
 3992 0022 7B18     		adds	r3, r7, r1
 3993 0024 0022     		movs	r2, #0
 3994 0026 1A70     		strb	r2, [r3]
1129:../drivers/fsl_clock.c **** 
1130:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1131:../drivers/fsl_clock.c ****     mcg_mode_t mode = CLOCK_GetMode();
1132:../drivers/fsl_clock.c ****     if (!((kMCG_ModeFEE == mode) || (kMCG_ModeFBI == mode) || (kMCG_ModeFBE == mode) || (kMCG_ModeF
1133:../drivers/fsl_clock.c ****     {
1134:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeUnreachable;
1135:../drivers/fsl_clock.c ****     }
1136:../drivers/fsl_clock.c **** #endif
1137:../drivers/fsl_clock.c ****     mcg_c4 = MCG->C4;
 3995              		.loc 2 1137 17
 3996 0028 3F4A     		ldr	r2, .L282
 3997              		.loc 2 1137 12
 3998 002a 0E23     		movs	r3, #14
 3999 002c FB18     		adds	r3, r7, r3
 4000 002e D278     		ldrb	r2, [r2, #3]
 4001 0030 1A70     		strb	r2, [r3]
1138:../drivers/fsl_clock.c **** 
1139:../drivers/fsl_clock.c ****     /*
1140:../drivers/fsl_clock.c ****        Errata: ERR007993
1141:../drivers/fsl_clock.c ****        Workaround: Invert MCG_C4[DMX32] or change MCG_C4[DRST_DRS] before
1142:../drivers/fsl_clock.c ****        reference clock source changes, then reset to previous value after
1143:../drivers/fsl_clock.c ****        reference clock changes.
1144:../drivers/fsl_clock.c ****      */
1145:../drivers/fsl_clock.c ****     if (kMCG_FllSrcInternal == MCG_S_IREFST_VAL)
 4002              		.loc 2 1145 32
 4003 0032 3D4B     		ldr	r3, .L282
 4004 0034 9B79     		ldrb	r3, [r3, #6]
 4005 0036 DBB2     		uxtb	r3, r3
 4006 0038 1B09     		lsrs	r3, r3, #4
 4007 003a 0122     		movs	r2, #1
 4008 003c 1340     		ands	r3, r2
 4009              		.loc 2 1145 8
 4010 003e 012B     		cmp	r3, #1
 4011 0040 0AD1     		bne	.L272
1146:../drivers/fsl_clock.c ****     {
1147:../drivers/fsl_clock.c ****         change_drs = true;
 4012              		.loc 2 1147 20
 4013 0042 7B18     		adds	r3, r7, r1
 4014 0044 0122     		movs	r2, #1
 4015 0046 1A70     		strb	r2, [r3]
1148:../drivers/fsl_clock.c ****         /* Change the LSB of DRST_DRS. */
1149:../drivers/fsl_clock.c ****         MCG->C4 ^= (1U << MCG_C4_DRST_DRS_SHIFT);
 4016              		.loc 2 1149 17
 4017 0048 374B     		ldr	r3, .L282
 4018 004a DB78     		ldrb	r3, [r3, #3]
 4019 004c DBB2     		uxtb	r3, r3
 4020 004e 364A     		ldr	r2, .L282
 4021 0050 2021     		movs	r1, #32
 4022 0052 4B40     		eors	r3, r1
 4023 0054 DBB2     		uxtb	r3, r3
 4024 0056 D370     		strb	r3, [r2, #3]
 4025              	.L272:
1150:../drivers/fsl_clock.c ****     }
1151:../drivers/fsl_clock.c **** 
1152:../drivers/fsl_clock.c ****     /* Set CLKS and IREFS. */
1153:../drivers/fsl_clock.c ****     MCG->C1 = ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK)) |
 4026              		.loc 2 1153 20
 4027 0058 334B     		ldr	r3, .L282
 4028 005a 1B78     		ldrb	r3, [r3]
 4029 005c DBB2     		uxtb	r3, r3
 4030              		.loc 2 1153 25
 4031 005e 0322     		movs	r2, #3
 4032 0060 1340     		ands	r3, r2
 4033 0062 DAB2     		uxtb	r2, r3
1154:../drivers/fsl_clock.c ****                (MCG_C1_CLKS(kMCG_ClkOutSrcOut)         /* CLKS = 0 */
1155:../drivers/fsl_clock.c ****                 | MCG_C1_FRDIV(frdiv)                  /* FRDIV */
 4034              		.loc 2 1155 19
 4035 0064 FB1D     		adds	r3, r7, #7
 4036 0066 1B78     		ldrb	r3, [r3]
 4037 0068 DB00     		lsls	r3, r3, #3
 4038 006a DBB2     		uxtb	r3, r3
1156:../drivers/fsl_clock.c ****                 | MCG_C1_IREFS(kMCG_FllSrcExternal))); /* IREFS = 0 */
 4039              		.loc 2 1156 17
 4040 006c 3821     		movs	r1, #56
 4041 006e 0B40     		ands	r3, r1
 4042 0070 DBB2     		uxtb	r3, r3
1153:../drivers/fsl_clock.c ****                (MCG_C1_CLKS(kMCG_ClkOutSrcOut)         /* CLKS = 0 */
 4043              		.loc 2 1153 8
 4044 0072 2D49     		ldr	r1, .L282
1153:../drivers/fsl_clock.c ****                (MCG_C1_CLKS(kMCG_ClkOutSrcOut)         /* CLKS = 0 */
 4045              		.loc 2 1153 88
 4046 0074 1343     		orrs	r3, r2
 4047 0076 DBB2     		uxtb	r3, r3
1153:../drivers/fsl_clock.c ****                (MCG_C1_CLKS(kMCG_ClkOutSrcOut)         /* CLKS = 0 */
 4048              		.loc 2 1153 13
 4049 0078 0B70     		strb	r3, [r1]
1157:../drivers/fsl_clock.c **** 
1158:../drivers/fsl_clock.c ****     /* If use external crystal as clock source, wait for it stable. */
1159:../drivers/fsl_clock.c ****     {
1160:../drivers/fsl_clock.c ****         if (MCG->C2 & MCG_C2_EREFS_MASK)
 4050              		.loc 2 1160 16
 4051 007a 2B4B     		ldr	r3, .L282
 4052 007c 5B78     		ldrb	r3, [r3, #1]
 4053 007e DBB2     		uxtb	r3, r3
 4054              		.loc 2 1160 21
 4055 0080 1A00     		movs	r2, r3
 4056 0082 0423     		movs	r3, #4
 4057 0084 1340     		ands	r3, r2
 4058              		.loc 2 1160 12
 4059 0086 07D0     		beq	.L281
1161:../drivers/fsl_clock.c ****         {
1162:../drivers/fsl_clock.c ****             while (!(MCG->S & MCG_S_OSCINIT0_MASK))
 4060              		.loc 2 1162 19
 4061 0088 C046     		nop
 4062              	.L274:
 4063              		.loc 2 1162 25 discriminator 1
 4064 008a 274B     		ldr	r3, .L282
 4065 008c 9B79     		ldrb	r3, [r3, #6]
 4066 008e DBB2     		uxtb	r3, r3
 4067              		.loc 2 1162 29 discriminator 1
 4068 0090 1A00     		movs	r2, r3
 4069 0092 0223     		movs	r3, #2
 4070 0094 1340     		ands	r3, r2
 4071              		.loc 2 1162 19 discriminator 1
 4072 0096 F8D0     		beq	.L274
 4073              	.L281:
1163:../drivers/fsl_clock.c ****             {
1164:../drivers/fsl_clock.c ****             }
1165:../drivers/fsl_clock.c ****         }
1166:../drivers/fsl_clock.c ****     }
1167:../drivers/fsl_clock.c **** 
1168:../drivers/fsl_clock.c ****     /* Wait and check status. */
1169:../drivers/fsl_clock.c ****     while (kMCG_FllSrcExternal != MCG_S_IREFST_VAL)
 4074              		.loc 2 1169 11
 4075 0098 C046     		nop
 4076              	.L275:
 4077              		.loc 2 1169 35 discriminator 1
 4078 009a 234B     		ldr	r3, .L282
 4079 009c 9B79     		ldrb	r3, [r3, #6]
 4080 009e DBB2     		uxtb	r3, r3
 4081              		.loc 2 1169 32 discriminator 1
 4082 00a0 1A00     		movs	r2, r3
 4083 00a2 1023     		movs	r3, #16
 4084 00a4 1340     		ands	r3, r2
 4085              		.loc 2 1169 11 discriminator 1
 4086 00a6 F8D1     		bne	.L275
1170:../drivers/fsl_clock.c ****     {
1171:../drivers/fsl_clock.c ****     }
1172:../drivers/fsl_clock.c **** 
1173:../drivers/fsl_clock.c ****     /* Errata: ERR007993 */
1174:../drivers/fsl_clock.c ****     if (change_drs)
 4087              		.loc 2 1174 8
 4088 00a8 0F23     		movs	r3, #15
 4089 00aa FB18     		adds	r3, r7, r3
 4090 00ac 1B78     		ldrb	r3, [r3]
 4091 00ae 002B     		cmp	r3, #0
 4092 00b0 04D0     		beq	.L276
1175:../drivers/fsl_clock.c ****     {
1176:../drivers/fsl_clock.c ****         MCG->C4 = mcg_c4;
 4093              		.loc 2 1176 12
 4094 00b2 1D4A     		ldr	r2, .L282
 4095              		.loc 2 1176 17
 4096 00b4 0E23     		movs	r3, #14
 4097 00b6 FB18     		adds	r3, r7, r3
 4098 00b8 1B78     		ldrb	r3, [r3]
 4099 00ba D370     		strb	r3, [r2, #3]
 4100              	.L276:
1177:../drivers/fsl_clock.c ****     }
1178:../drivers/fsl_clock.c **** 
1179:../drivers/fsl_clock.c ****     /* Set DRS and DMX32. */
1180:../drivers/fsl_clock.c ****     mcg_c4 = ((mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) | (MCG_C4_DMX32(dmx32) | MCG_C
 4101              		.loc 2 1180 23
 4102 00bc 0E24     		movs	r4, #14
 4103 00be 3B19     		adds	r3, r7, r4
 4104 00c0 1B78     		ldrb	r3, [r3]
 4105 00c2 1F22     		movs	r2, #31
 4106 00c4 1340     		ands	r3, r2
 4107 00c6 D9B2     		uxtb	r1, r3
 4108              		.loc 2 1180 73
 4109 00c8 BB1D     		adds	r3, r7, #6
 4110 00ca 1B78     		ldrb	r3, [r3]
 4111 00cc DB01     		lsls	r3, r3, #7
 4112 00ce DAB2     		uxtb	r2, r3
 4113              		.loc 2 1180 95
 4114 00d0 7B1D     		adds	r3, r7, #5
 4115 00d2 1B78     		ldrb	r3, [r3]
 4116 00d4 5B01     		lsls	r3, r3, #5
 4117 00d6 DBB2     		uxtb	r3, r3
 4118 00d8 6020     		movs	r0, #96
 4119 00da 0340     		ands	r3, r0
 4120 00dc DBB2     		uxtb	r3, r3
 4121              		.loc 2 1180 93
 4122 00de 1343     		orrs	r3, r2
 4123 00e0 DAB2     		uxtb	r2, r3
 4124              		.loc 2 1180 12
 4125 00e2 3B19     		adds	r3, r7, r4
 4126 00e4 0A43     		orrs	r2, r1
 4127 00e6 1A70     		strb	r2, [r3]
1181:../drivers/fsl_clock.c ****     MCG->C4 = mcg_c4;
 4128              		.loc 2 1181 8
 4129 00e8 0F4A     		ldr	r2, .L282
 4130              		.loc 2 1181 13
 4131 00ea 3B19     		adds	r3, r7, r4
 4132 00ec 1B78     		ldrb	r3, [r3]
 4133 00ee D370     		strb	r3, [r2, #3]
1182:../drivers/fsl_clock.c **** 
1183:../drivers/fsl_clock.c ****     /* Wait for DRST_DRS update. */
1184:../drivers/fsl_clock.c ****     while (MCG->C4 != mcg_c4)
 4134              		.loc 2 1184 11
 4135 00f0 C046     		nop
 4136              	.L277:
 4137              		.loc 2 1184 15 discriminator 1
 4138 00f2 0D4B     		ldr	r3, .L282
 4139 00f4 DB78     		ldrb	r3, [r3, #3]
 4140 00f6 DBB2     		uxtb	r3, r3
 4141              		.loc 2 1184 11 discriminator 1
 4142 00f8 0E22     		movs	r2, #14
 4143 00fa BA18     		adds	r2, r7, r2
 4144 00fc 1278     		ldrb	r2, [r2]
 4145 00fe 9A42     		cmp	r2, r3
 4146 0100 F7D1     		bne	.L277
1185:../drivers/fsl_clock.c ****     {
1186:../drivers/fsl_clock.c ****     }
1187:../drivers/fsl_clock.c **** 
1188:../drivers/fsl_clock.c ****     /* Check MCG_S[CLKST] */
1189:../drivers/fsl_clock.c ****     while (kMCG_ClkOutStatFll != MCG_S_CLKST_VAL)
 4147              		.loc 2 1189 11
 4148 0102 C046     		nop
 4149              	.L278:
 4150              		.loc 2 1189 34 discriminator 1
 4151 0104 084B     		ldr	r3, .L282
 4152 0106 9B79     		ldrb	r3, [r3, #6]
 4153 0108 DBB2     		uxtb	r3, r3
 4154 010a 9B08     		lsrs	r3, r3, #2
 4155 010c 0322     		movs	r2, #3
 4156 010e 1340     		ands	r3, r2
 4157              		.loc 2 1189 11 discriminator 1
 4158 0110 F8D1     		bne	.L278
1190:../drivers/fsl_clock.c ****     {
1191:../drivers/fsl_clock.c ****     }
1192:../drivers/fsl_clock.c **** 
1193:../drivers/fsl_clock.c ****     /* Wait for FLL stable time. */
1194:../drivers/fsl_clock.c ****     if (fllStableDelay)
 4159              		.loc 2 1194 8
 4160 0112 3B68     		ldr	r3, [r7]
 4161 0114 002B     		cmp	r3, #0
 4162 0116 01D0     		beq	.L279
1195:../drivers/fsl_clock.c ****     {
1196:../drivers/fsl_clock.c ****         fllStableDelay();
 4163              		.loc 2 1196 9
 4164 0118 3B68     		ldr	r3, [r7]
 4165 011a 9847     		blx	r3
 4166              	.LVL20:
 4167              	.L279:
1197:../drivers/fsl_clock.c ****     }
1198:../drivers/fsl_clock.c **** 
1199:../drivers/fsl_clock.c ****     return kStatus_Success;
 4168              		.loc 2 1199 12
 4169 011c 0023     		movs	r3, #0
1200:../drivers/fsl_clock.c **** }
 4170              		.loc 2 1200 1
 4171 011e 1800     		movs	r0, r3
 4172 0120 BD46     		mov	sp, r7
 4173 0122 05B0     		add	sp, sp, #20
 4174              		@ sp needed
 4175 0124 90BD     		pop	{r4, r7, pc}
 4176              	.L283:
 4177 0126 C046     		.align	2
 4178              	.L282:
 4179 0128 00400640 		.word	1074151424
 4180              		.cfi_endproc
 4181              	.LFE91:
 4183              		.section	.text.CLOCK_SetFbiMode,"ax",%progbits
 4184              		.align	1
 4185              		.global	CLOCK_SetFbiMode
 4186              		.syntax unified
 4187              		.code	16
 4188              		.thumb_func
 4189              		.fpu softvfp
 4191              	CLOCK_SetFbiMode:
 4192              	.LFB92:
1201:../drivers/fsl_clock.c **** 
1202:../drivers/fsl_clock.c **** status_t CLOCK_SetFbiMode(mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(void))
1203:../drivers/fsl_clock.c **** {
 4193              		.loc 2 1203 1
 4194              		.cfi_startproc
 4195              		@ args = 0, pretend = 0, frame = 16
 4196              		@ frame_needed = 1, uses_anonymous_args = 0
 4197 0000 80B5     		push	{r7, lr}
 4198              		.cfi_def_cfa_offset 8
 4199              		.cfi_offset 7, -8
 4200              		.cfi_offset 14, -4
 4201 0002 84B0     		sub	sp, sp, #16
 4202              		.cfi_def_cfa_offset 24
 4203 0004 00AF     		add	r7, sp, #0
 4204              		.cfi_def_cfa_register 7
 4205 0006 3A60     		str	r2, [r7]
 4206 0008 FB1D     		adds	r3, r7, #7
 4207 000a 021C     		adds	r2, r0, #0
 4208 000c 1A70     		strb	r2, [r3]
 4209 000e BB1D     		adds	r3, r7, #6
 4210 0010 0A1C     		adds	r2, r1, #0
 4211 0012 1A70     		strb	r2, [r3]
1204:../drivers/fsl_clock.c ****     uint8_t mcg_c4;
1205:../drivers/fsl_clock.c ****     bool change_drs = false;
 4212              		.loc 2 1205 10
 4213 0014 0F20     		movs	r0, #15
 4214 0016 3B18     		adds	r3, r7, r0
 4215 0018 0022     		movs	r2, #0
 4216 001a 1A70     		strb	r2, [r3]
1206:../drivers/fsl_clock.c **** 
1207:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1208:../drivers/fsl_clock.c ****     mcg_mode_t mode = CLOCK_GetMode();
1209:../drivers/fsl_clock.c **** 
1210:../drivers/fsl_clock.c ****     if (!((kMCG_ModeFEE == mode) || (kMCG_ModeFBI == mode) || (kMCG_ModeFBE == mode) || (kMCG_ModeF
1211:../drivers/fsl_clock.c ****           (kMCG_ModeBLPI == mode)))
1212:../drivers/fsl_clock.c **** 
1213:../drivers/fsl_clock.c ****     {
1214:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeUnreachable;
1215:../drivers/fsl_clock.c ****     }
1216:../drivers/fsl_clock.c **** #endif
1217:../drivers/fsl_clock.c **** 
1218:../drivers/fsl_clock.c ****     mcg_c4 = MCG->C4;
 4217              		.loc 2 1218 17
 4218 001c 334A     		ldr	r2, .L292
 4219              		.loc 2 1218 12
 4220 001e 0E23     		movs	r3, #14
 4221 0020 FB18     		adds	r3, r7, r3
 4222 0022 D278     		ldrb	r2, [r2, #3]
 4223 0024 1A70     		strb	r2, [r3]
1219:../drivers/fsl_clock.c **** 
1220:../drivers/fsl_clock.c ****     MCG->C2 &= ~MCG_C2_LP_MASK; /* Disable lowpower. */
 4224              		.loc 2 1220 13
 4225 0026 314B     		ldr	r3, .L292
 4226 0028 5B78     		ldrb	r3, [r3, #1]
 4227 002a DBB2     		uxtb	r3, r3
 4228 002c 2F4A     		ldr	r2, .L292
 4229 002e 0221     		movs	r1, #2
 4230 0030 8B43     		bics	r3, r1
 4231 0032 DBB2     		uxtb	r3, r3
 4232 0034 5370     		strb	r3, [r2, #1]
1221:../drivers/fsl_clock.c **** 
1222:../drivers/fsl_clock.c ****     /*
1223:../drivers/fsl_clock.c ****        Errata: ERR007993
1224:../drivers/fsl_clock.c ****        Workaround: Invert MCG_C4[DMX32] or change MCG_C4[DRST_DRS] before
1225:../drivers/fsl_clock.c ****        reference clock source changes, then reset to previous value after
1226:../drivers/fsl_clock.c ****        reference clock changes.
1227:../drivers/fsl_clock.c ****      */
1228:../drivers/fsl_clock.c ****     if (kMCG_FllSrcExternal == MCG_S_IREFST_VAL)
 4233              		.loc 2 1228 32
 4234 0036 2D4B     		ldr	r3, .L292
 4235 0038 9B79     		ldrb	r3, [r3, #6]
 4236 003a DBB2     		uxtb	r3, r3
 4237              		.loc 2 1228 29
 4238 003c 1A00     		movs	r2, r3
 4239 003e 1023     		movs	r3, #16
 4240 0040 1340     		ands	r3, r2
 4241              		.loc 2 1228 8
 4242 0042 0AD1     		bne	.L285
1229:../drivers/fsl_clock.c ****     {
1230:../drivers/fsl_clock.c ****         change_drs = true;
 4243              		.loc 2 1230 20
 4244 0044 3B18     		adds	r3, r7, r0
 4245 0046 0122     		movs	r2, #1
 4246 0048 1A70     		strb	r2, [r3]
1231:../drivers/fsl_clock.c ****         /* Change the LSB of DRST_DRS. */
1232:../drivers/fsl_clock.c ****         MCG->C4 ^= (1U << MCG_C4_DRST_DRS_SHIFT);
 4247              		.loc 2 1232 17
 4248 004a 284B     		ldr	r3, .L292
 4249 004c DB78     		ldrb	r3, [r3, #3]
 4250 004e DBB2     		uxtb	r3, r3
 4251 0050 264A     		ldr	r2, .L292
 4252 0052 2021     		movs	r1, #32
 4253 0054 4B40     		eors	r3, r1
 4254 0056 DBB2     		uxtb	r3, r3
 4255 0058 D370     		strb	r3, [r2, #3]
 4256              	.L285:
1233:../drivers/fsl_clock.c ****     }
1234:../drivers/fsl_clock.c **** 
1235:../drivers/fsl_clock.c ****     /* Set CLKS and IREFS. */
1236:../drivers/fsl_clock.c ****     MCG->C1 =
1237:../drivers/fsl_clock.c ****         ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK)) | (MCG_C1_CLKS(kMCG_ClkOutSrcInternal)
 4257              		.loc 2 1237 14
 4258 005a 244B     		ldr	r3, .L292
 4259 005c 1B78     		ldrb	r3, [r3]
 4260 005e DBB2     		uxtb	r3, r3
 4261              		.loc 2 1237 19
 4262 0060 3B22     		movs	r2, #59
 4263 0062 1340     		ands	r3, r2
 4264 0064 DBB2     		uxtb	r3, r3
1236:../drivers/fsl_clock.c ****         ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK)) | (MCG_C1_CLKS(kMCG_ClkOutSrcInternal)
 4265              		.loc 2 1236 8
 4266 0066 214A     		ldr	r2, .L292
 4267              		.loc 2 1237 62
 4268 0068 4421     		movs	r1, #68
 4269 006a 0B43     		orrs	r3, r1
 4270 006c DBB2     		uxtb	r3, r3
1236:../drivers/fsl_clock.c ****         ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK)) | (MCG_C1_CLKS(kMCG_ClkOutSrcInternal)
 4271              		.loc 2 1236 13
 4272 006e 1370     		strb	r3, [r2]
1238:../drivers/fsl_clock.c ****                                                                 | MCG_C1_IREFS(kMCG_FllSrcInternal)
1239:../drivers/fsl_clock.c **** 
1240:../drivers/fsl_clock.c ****     /* Wait and check status. */
1241:../drivers/fsl_clock.c ****     while (kMCG_FllSrcInternal != MCG_S_IREFST_VAL)
 4273              		.loc 2 1241 11
 4274 0070 C046     		nop
 4275              	.L286:
 4276              		.loc 2 1241 35 discriminator 1
 4277 0072 1E4B     		ldr	r3, .L292
 4278 0074 9B79     		ldrb	r3, [r3, #6]
 4279 0076 DBB2     		uxtb	r3, r3
 4280 0078 1B09     		lsrs	r3, r3, #4
 4281 007a 0122     		movs	r2, #1
 4282 007c 1340     		ands	r3, r2
 4283              		.loc 2 1241 11 discriminator 1
 4284 007e 012B     		cmp	r3, #1
 4285 0080 F7D1     		bne	.L286
1242:../drivers/fsl_clock.c ****     {
1243:../drivers/fsl_clock.c ****     }
1244:../drivers/fsl_clock.c **** 
1245:../drivers/fsl_clock.c ****     /* Errata: ERR007993 */
1246:../drivers/fsl_clock.c ****     if (change_drs)
 4286              		.loc 2 1246 8
 4287 0082 0F23     		movs	r3, #15
 4288 0084 FB18     		adds	r3, r7, r3
 4289 0086 1B78     		ldrb	r3, [r3]
 4290 0088 002B     		cmp	r3, #0
 4291 008a 04D0     		beq	.L291
1247:../drivers/fsl_clock.c ****     {
1248:../drivers/fsl_clock.c ****         MCG->C4 = mcg_c4;
 4292              		.loc 2 1248 12
 4293 008c 174A     		ldr	r2, .L292
 4294              		.loc 2 1248 17
 4295 008e 0E23     		movs	r3, #14
 4296 0090 FB18     		adds	r3, r7, r3
 4297 0092 1B78     		ldrb	r3, [r3]
 4298 0094 D370     		strb	r3, [r2, #3]
 4299              	.L291:
1249:../drivers/fsl_clock.c ****     }
1250:../drivers/fsl_clock.c **** 
1251:../drivers/fsl_clock.c ****     while (kMCG_ClkOutStatInt != MCG_S_CLKST_VAL)
 4300              		.loc 2 1251 11
 4301 0096 C046     		nop
 4302              	.L288:
 4303              		.loc 2 1251 34 discriminator 1
 4304 0098 144B     		ldr	r3, .L292
 4305 009a 9B79     		ldrb	r3, [r3, #6]
 4306 009c DBB2     		uxtb	r3, r3
 4307 009e 9B08     		lsrs	r3, r3, #2
 4308 00a0 0322     		movs	r2, #3
 4309 00a2 1340     		ands	r3, r2
 4310              		.loc 2 1251 11 discriminator 1
 4311 00a4 012B     		cmp	r3, #1
 4312 00a6 F7D1     		bne	.L288
1252:../drivers/fsl_clock.c ****     {
1253:../drivers/fsl_clock.c ****     }
1254:../drivers/fsl_clock.c **** 
1255:../drivers/fsl_clock.c ****     MCG->C4 = (mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) | (MCG_C4_DMX32(dmx32) | MCG_C
 4313              		.loc 2 1255 23
 4314 00a8 0E23     		movs	r3, #14
 4315 00aa FB18     		adds	r3, r7, r3
 4316 00ac 1B78     		ldrb	r3, [r3]
 4317 00ae 1F22     		movs	r2, #31
 4318 00b0 1340     		ands	r3, r2
 4319 00b2 DAB2     		uxtb	r2, r3
 4320              		.loc 2 1255 73
 4321 00b4 FB1D     		adds	r3, r7, #7
 4322 00b6 1B78     		ldrb	r3, [r3]
 4323 00b8 DB01     		lsls	r3, r3, #7
 4324 00ba D9B2     		uxtb	r1, r3
 4325              		.loc 2 1255 95
 4326 00bc BB1D     		adds	r3, r7, #6
 4327 00be 1B78     		ldrb	r3, [r3]
 4328 00c0 5B01     		lsls	r3, r3, #5
 4329 00c2 DBB2     		uxtb	r3, r3
 4330 00c4 6020     		movs	r0, #96
 4331 00c6 0340     		ands	r3, r0
 4332 00c8 DBB2     		uxtb	r3, r3
 4333              		.loc 2 1255 93
 4334 00ca 0B43     		orrs	r3, r1
 4335 00cc DBB2     		uxtb	r3, r3
 4336              		.loc 2 1255 8
 4337 00ce 0749     		ldr	r1, .L292
 4338              		.loc 2 1255 70
 4339 00d0 1343     		orrs	r3, r2
 4340 00d2 DBB2     		uxtb	r3, r3
 4341              		.loc 2 1255 13
 4342 00d4 CB70     		strb	r3, [r1, #3]
1256:../drivers/fsl_clock.c **** 
1257:../drivers/fsl_clock.c ****     /* Wait for FLL stable time. */
1258:../drivers/fsl_clock.c ****     if (fllStableDelay)
 4343              		.loc 2 1258 8
 4344 00d6 3B68     		ldr	r3, [r7]
 4345 00d8 002B     		cmp	r3, #0
 4346 00da 01D0     		beq	.L289
1259:../drivers/fsl_clock.c ****     {
1260:../drivers/fsl_clock.c ****         fllStableDelay();
 4347              		.loc 2 1260 9
 4348 00dc 3B68     		ldr	r3, [r7]
 4349 00de 9847     		blx	r3
 4350              	.LVL21:
 4351              	.L289:
1261:../drivers/fsl_clock.c ****     }
1262:../drivers/fsl_clock.c **** 
1263:../drivers/fsl_clock.c ****     return kStatus_Success;
 4352              		.loc 2 1263 12
 4353 00e0 0023     		movs	r3, #0
1264:../drivers/fsl_clock.c **** }
 4354              		.loc 2 1264 1
 4355 00e2 1800     		movs	r0, r3
 4356 00e4 BD46     		mov	sp, r7
 4357 00e6 04B0     		add	sp, sp, #16
 4358              		@ sp needed
 4359 00e8 80BD     		pop	{r7, pc}
 4360              	.L293:
 4361 00ea C046     		.align	2
 4362              	.L292:
 4363 00ec 00400640 		.word	1074151424
 4364              		.cfi_endproc
 4365              	.LFE92:
 4367              		.section	.text.CLOCK_SetFbeMode,"ax",%progbits
 4368              		.align	1
 4369              		.global	CLOCK_SetFbeMode
 4370              		.syntax unified
 4371              		.code	16
 4372              		.thumb_func
 4373              		.fpu softvfp
 4375              	CLOCK_SetFbeMode:
 4376              	.LFB93:
1265:../drivers/fsl_clock.c **** 
1266:../drivers/fsl_clock.c **** status_t CLOCK_SetFbeMode(uint8_t frdiv, mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(v
1267:../drivers/fsl_clock.c **** {
 4377              		.loc 2 1267 1
 4378              		.cfi_startproc
 4379              		@ args = 0, pretend = 0, frame = 16
 4380              		@ frame_needed = 1, uses_anonymous_args = 0
 4381 0000 90B5     		push	{r4, r7, lr}
 4382              		.cfi_def_cfa_offset 12
 4383              		.cfi_offset 4, -12
 4384              		.cfi_offset 7, -8
 4385              		.cfi_offset 14, -4
 4386 0002 85B0     		sub	sp, sp, #20
 4387              		.cfi_def_cfa_offset 32
 4388 0004 00AF     		add	r7, sp, #0
 4389              		.cfi_def_cfa_register 7
 4390 0006 0400     		movs	r4, r0
 4391 0008 0800     		movs	r0, r1
 4392 000a 1100     		movs	r1, r2
 4393 000c 3B60     		str	r3, [r7]
 4394 000e FB1D     		adds	r3, r7, #7
 4395 0010 221C     		adds	r2, r4, #0
 4396 0012 1A70     		strb	r2, [r3]
 4397 0014 BB1D     		adds	r3, r7, #6
 4398 0016 021C     		adds	r2, r0, #0
 4399 0018 1A70     		strb	r2, [r3]
 4400 001a 7B1D     		adds	r3, r7, #5
 4401 001c 0A1C     		adds	r2, r1, #0
 4402 001e 1A70     		strb	r2, [r3]
1268:../drivers/fsl_clock.c ****     uint8_t mcg_c4;
1269:../drivers/fsl_clock.c ****     bool change_drs = false;
 4403              		.loc 2 1269 10
 4404 0020 0F23     		movs	r3, #15
 4405 0022 FB18     		adds	r3, r7, r3
 4406 0024 0022     		movs	r2, #0
 4407 0026 1A70     		strb	r2, [r3]
1270:../drivers/fsl_clock.c **** 
1271:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1272:../drivers/fsl_clock.c ****     mcg_mode_t mode = CLOCK_GetMode();
1273:../drivers/fsl_clock.c ****     if (!((kMCG_ModeFEE == mode) || (kMCG_ModeFBI == mode) || (kMCG_ModeFBE == mode) || (kMCG_ModeF
1274:../drivers/fsl_clock.c ****           (kMCG_ModePBE == mode) || (kMCG_ModeBLPE == mode)))
1275:../drivers/fsl_clock.c ****     {
1276:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeUnreachable;
1277:../drivers/fsl_clock.c ****     }
1278:../drivers/fsl_clock.c **** #endif
1279:../drivers/fsl_clock.c **** 
1280:../drivers/fsl_clock.c ****     /* Change to FLL mode. */
1281:../drivers/fsl_clock.c ****     MCG->C6 &= ~MCG_C6_PLLS_MASK;
 4408              		.loc 2 1281 13
 4409 0028 474B     		ldr	r3, .L305
 4410 002a 5B79     		ldrb	r3, [r3, #5]
 4411 002c DBB2     		uxtb	r3, r3
 4412 002e 464A     		ldr	r2, .L305
 4413 0030 4021     		movs	r1, #64
 4414 0032 8B43     		bics	r3, r1
 4415 0034 DBB2     		uxtb	r3, r3
 4416 0036 5371     		strb	r3, [r2, #5]
1282:../drivers/fsl_clock.c ****     while (MCG->S & MCG_S_PLLST_MASK)
 4417              		.loc 2 1282 11
 4418 0038 C046     		nop
 4419              	.L295:
 4420              		.loc 2 1282 15 discriminator 1
 4421 003a 434B     		ldr	r3, .L305
 4422 003c 9B79     		ldrb	r3, [r3, #6]
 4423 003e DBB2     		uxtb	r3, r3
 4424              		.loc 2 1282 19 discriminator 1
 4425 0040 1A00     		movs	r2, r3
 4426 0042 2023     		movs	r3, #32
 4427 0044 1340     		ands	r3, r2
 4428              		.loc 2 1282 11 discriminator 1
 4429 0046 F8D1     		bne	.L295
1283:../drivers/fsl_clock.c ****     {
1284:../drivers/fsl_clock.c ****     }
1285:../drivers/fsl_clock.c **** 
1286:../drivers/fsl_clock.c ****     /* Set LP bit to enable the FLL */
1287:../drivers/fsl_clock.c ****     MCG->C2 &= ~MCG_C2_LP_MASK;
 4430              		.loc 2 1287 13
 4431 0048 3F4B     		ldr	r3, .L305
 4432 004a 5B78     		ldrb	r3, [r3, #1]
 4433 004c DBB2     		uxtb	r3, r3
 4434 004e 3E4A     		ldr	r2, .L305
 4435 0050 0221     		movs	r1, #2
 4436 0052 8B43     		bics	r3, r1
 4437 0054 DBB2     		uxtb	r3, r3
 4438 0056 5370     		strb	r3, [r2, #1]
1288:../drivers/fsl_clock.c **** 
1289:../drivers/fsl_clock.c ****     mcg_c4 = MCG->C4;
 4439              		.loc 2 1289 17
 4440 0058 3B4A     		ldr	r2, .L305
 4441              		.loc 2 1289 12
 4442 005a 0E23     		movs	r3, #14
 4443 005c FB18     		adds	r3, r7, r3
 4444 005e D278     		ldrb	r2, [r2, #3]
 4445 0060 1A70     		strb	r2, [r3]
1290:../drivers/fsl_clock.c **** 
1291:../drivers/fsl_clock.c ****     /*
1292:../drivers/fsl_clock.c ****        Errata: ERR007993
1293:../drivers/fsl_clock.c ****        Workaround: Invert MCG_C4[DMX32] or change MCG_C4[DRST_DRS] before
1294:../drivers/fsl_clock.c ****        reference clock source changes, then reset to previous value after
1295:../drivers/fsl_clock.c ****        reference clock changes.
1296:../drivers/fsl_clock.c ****      */
1297:../drivers/fsl_clock.c ****     if (kMCG_FllSrcInternal == MCG_S_IREFST_VAL)
 4446              		.loc 2 1297 32
 4447 0062 394B     		ldr	r3, .L305
 4448 0064 9B79     		ldrb	r3, [r3, #6]
 4449 0066 DBB2     		uxtb	r3, r3
 4450 0068 1B09     		lsrs	r3, r3, #4
 4451 006a 0122     		movs	r2, #1
 4452 006c 1340     		ands	r3, r2
 4453              		.loc 2 1297 8
 4454 006e 012B     		cmp	r3, #1
 4455 0070 0BD1     		bne	.L296
1298:../drivers/fsl_clock.c ****     {
1299:../drivers/fsl_clock.c ****         change_drs = true;
 4456              		.loc 2 1299 20
 4457 0072 0F23     		movs	r3, #15
 4458 0074 FB18     		adds	r3, r7, r3
 4459 0076 0122     		movs	r2, #1
 4460 0078 1A70     		strb	r2, [r3]
1300:../drivers/fsl_clock.c ****         /* Change the LSB of DRST_DRS. */
1301:../drivers/fsl_clock.c ****         MCG->C4 ^= (1U << MCG_C4_DRST_DRS_SHIFT);
 4461              		.loc 2 1301 17
 4462 007a 334B     		ldr	r3, .L305
 4463 007c DB78     		ldrb	r3, [r3, #3]
 4464 007e DBB2     		uxtb	r3, r3
 4465 0080 314A     		ldr	r2, .L305
 4466 0082 2021     		movs	r1, #32
 4467 0084 4B40     		eors	r3, r1
 4468 0086 DBB2     		uxtb	r3, r3
 4469 0088 D370     		strb	r3, [r2, #3]
 4470              	.L296:
1302:../drivers/fsl_clock.c ****     }
1303:../drivers/fsl_clock.c **** 
1304:../drivers/fsl_clock.c ****     /* Set CLKS and IREFS. */
1305:../drivers/fsl_clock.c ****     MCG->C1 = ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK)) |
 4471              		.loc 2 1305 20
 4472 008a 2F4B     		ldr	r3, .L305
 4473 008c 1B78     		ldrb	r3, [r3]
 4474 008e DBB2     		uxtb	r3, r3
 4475              		.loc 2 1305 25
 4476 0090 0322     		movs	r2, #3
 4477 0092 1340     		ands	r3, r2
 4478 0094 DAB2     		uxtb	r2, r3
1306:../drivers/fsl_clock.c ****                (MCG_C1_CLKS(kMCG_ClkOutSrcExternal)    /* CLKS = 2 */
1307:../drivers/fsl_clock.c ****                 | MCG_C1_FRDIV(frdiv)                  /* FRDIV = frdiv */
 4479              		.loc 2 1307 19
 4480 0096 FB1D     		adds	r3, r7, #7
 4481 0098 1B78     		ldrb	r3, [r3]
 4482 009a DB00     		lsls	r3, r3, #3
 4483 009c DBB2     		uxtb	r3, r3
 4484 009e 3821     		movs	r1, #56
 4485 00a0 0B40     		ands	r3, r1
 4486 00a2 DBB2     		uxtb	r3, r3
1305:../drivers/fsl_clock.c ****                (MCG_C1_CLKS(kMCG_ClkOutSrcExternal)    /* CLKS = 2 */
 4487              		.loc 2 1305 88
 4488 00a4 1343     		orrs	r3, r2
 4489 00a6 DBB2     		uxtb	r3, r3
1305:../drivers/fsl_clock.c ****                (MCG_C1_CLKS(kMCG_ClkOutSrcExternal)    /* CLKS = 2 */
 4490              		.loc 2 1305 8
 4491 00a8 2749     		ldr	r1, .L305
1305:../drivers/fsl_clock.c ****                (MCG_C1_CLKS(kMCG_ClkOutSrcExternal)    /* CLKS = 2 */
 4492              		.loc 2 1305 88
 4493 00aa 8022     		movs	r2, #128
 4494 00ac 5242     		rsbs	r2, r2, #0
 4495 00ae 1343     		orrs	r3, r2
 4496 00b0 DBB2     		uxtb	r3, r3
1305:../drivers/fsl_clock.c ****                (MCG_C1_CLKS(kMCG_ClkOutSrcExternal)    /* CLKS = 2 */
 4497              		.loc 2 1305 13
 4498 00b2 0B70     		strb	r3, [r1]
1308:../drivers/fsl_clock.c ****                 | MCG_C1_IREFS(kMCG_FllSrcExternal))); /* IREFS = 0 */
1309:../drivers/fsl_clock.c **** 
1310:../drivers/fsl_clock.c ****     /* If use external crystal as clock source, wait for it stable. */
1311:../drivers/fsl_clock.c ****     {
1312:../drivers/fsl_clock.c ****         if (MCG->C2 & MCG_C2_EREFS_MASK)
 4499              		.loc 2 1312 16
 4500 00b4 244B     		ldr	r3, .L305
 4501 00b6 5B78     		ldrb	r3, [r3, #1]
 4502 00b8 DBB2     		uxtb	r3, r3
 4503              		.loc 2 1312 21
 4504 00ba 1A00     		movs	r2, r3
 4505 00bc 0423     		movs	r3, #4
 4506 00be 1340     		ands	r3, r2
 4507              		.loc 2 1312 12
 4508 00c0 07D0     		beq	.L304
1313:../drivers/fsl_clock.c ****         {
1314:../drivers/fsl_clock.c ****             while (!(MCG->S & MCG_S_OSCINIT0_MASK))
 4509              		.loc 2 1314 19
 4510 00c2 C046     		nop
 4511              	.L298:
 4512              		.loc 2 1314 25 discriminator 1
 4513 00c4 204B     		ldr	r3, .L305
 4514 00c6 9B79     		ldrb	r3, [r3, #6]
 4515 00c8 DBB2     		uxtb	r3, r3
 4516              		.loc 2 1314 29 discriminator 1
 4517 00ca 1A00     		movs	r2, r3
 4518 00cc 0223     		movs	r3, #2
 4519 00ce 1340     		ands	r3, r2
 4520              		.loc 2 1314 19 discriminator 1
 4521 00d0 F8D0     		beq	.L298
 4522              	.L304:
1315:../drivers/fsl_clock.c ****             {
1316:../drivers/fsl_clock.c ****             }
1317:../drivers/fsl_clock.c ****         }
1318:../drivers/fsl_clock.c ****     }
1319:../drivers/fsl_clock.c **** 
1320:../drivers/fsl_clock.c ****     /* Wait for Reference clock Status bit to clear */
1321:../drivers/fsl_clock.c ****     while (kMCG_FllSrcExternal != MCG_S_IREFST_VAL)
 4523              		.loc 2 1321 11
 4524 00d2 C046     		nop
 4525              	.L299:
 4526              		.loc 2 1321 35 discriminator 1
 4527 00d4 1C4B     		ldr	r3, .L305
 4528 00d6 9B79     		ldrb	r3, [r3, #6]
 4529 00d8 DBB2     		uxtb	r3, r3
 4530              		.loc 2 1321 32 discriminator 1
 4531 00da 1A00     		movs	r2, r3
 4532 00dc 1023     		movs	r3, #16
 4533 00de 1340     		ands	r3, r2
 4534              		.loc 2 1321 11 discriminator 1
 4535 00e0 F8D1     		bne	.L299
1322:../drivers/fsl_clock.c ****     {
1323:../drivers/fsl_clock.c ****     }
1324:../drivers/fsl_clock.c **** 
1325:../drivers/fsl_clock.c ****     /* Errata: ERR007993 */
1326:../drivers/fsl_clock.c ****     if (change_drs)
 4536              		.loc 2 1326 8
 4537 00e2 0F23     		movs	r3, #15
 4538 00e4 FB18     		adds	r3, r7, r3
 4539 00e6 1B78     		ldrb	r3, [r3]
 4540 00e8 002B     		cmp	r3, #0
 4541 00ea 04D0     		beq	.L300
1327:../drivers/fsl_clock.c ****     {
1328:../drivers/fsl_clock.c ****         MCG->C4 = mcg_c4;
 4542              		.loc 2 1328 12
 4543 00ec 164A     		ldr	r2, .L305
 4544              		.loc 2 1328 17
 4545 00ee 0E23     		movs	r3, #14
 4546 00f0 FB18     		adds	r3, r7, r3
 4547 00f2 1B78     		ldrb	r3, [r3]
 4548 00f4 D370     		strb	r3, [r2, #3]
 4549              	.L300:
1329:../drivers/fsl_clock.c ****     }
1330:../drivers/fsl_clock.c **** 
1331:../drivers/fsl_clock.c ****     /* Set DRST_DRS and DMX32. */
1332:../drivers/fsl_clock.c ****     mcg_c4 = ((mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) | (MCG_C4_DMX32(dmx32) | MCG_C
 4550              		.loc 2 1332 23
 4551 00f6 0E24     		movs	r4, #14
 4552 00f8 3B19     		adds	r3, r7, r4
 4553 00fa 1B78     		ldrb	r3, [r3]
 4554 00fc 1F22     		movs	r2, #31
 4555 00fe 1340     		ands	r3, r2
 4556 0100 D9B2     		uxtb	r1, r3
 4557              		.loc 2 1332 73
 4558 0102 BB1D     		adds	r3, r7, #6
 4559 0104 1B78     		ldrb	r3, [r3]
 4560 0106 DB01     		lsls	r3, r3, #7
 4561 0108 DAB2     		uxtb	r2, r3
 4562              		.loc 2 1332 95
 4563 010a 7B1D     		adds	r3, r7, #5
 4564 010c 1B78     		ldrb	r3, [r3]
 4565 010e 5B01     		lsls	r3, r3, #5
 4566 0110 DBB2     		uxtb	r3, r3
 4567 0112 6020     		movs	r0, #96
 4568 0114 0340     		ands	r3, r0
 4569 0116 DBB2     		uxtb	r3, r3
 4570              		.loc 2 1332 93
 4571 0118 1343     		orrs	r3, r2
 4572 011a DAB2     		uxtb	r2, r3
 4573              		.loc 2 1332 12
 4574 011c 3B19     		adds	r3, r7, r4
 4575 011e 0A43     		orrs	r2, r1
 4576 0120 1A70     		strb	r2, [r3]
1333:../drivers/fsl_clock.c **** 
1334:../drivers/fsl_clock.c ****     /* Wait for clock status bits to show clock source is ext ref clk */
1335:../drivers/fsl_clock.c ****     while (kMCG_ClkOutStatExt != MCG_S_CLKST_VAL)
 4577              		.loc 2 1335 11
 4578 0122 C046     		nop
 4579              	.L301:
 4580              		.loc 2 1335 34 discriminator 1
 4581 0124 084B     		ldr	r3, .L305
 4582 0126 9B79     		ldrb	r3, [r3, #6]
 4583 0128 DBB2     		uxtb	r3, r3
 4584 012a 9B08     		lsrs	r3, r3, #2
 4585 012c 0322     		movs	r2, #3
 4586 012e 1340     		ands	r3, r2
 4587              		.loc 2 1335 11 discriminator 1
 4588 0130 022B     		cmp	r3, #2
 4589 0132 F7D1     		bne	.L301
1336:../drivers/fsl_clock.c ****     {
1337:../drivers/fsl_clock.c ****     }
1338:../drivers/fsl_clock.c **** 
1339:../drivers/fsl_clock.c ****     /* Wait for fll stable time. */
1340:../drivers/fsl_clock.c ****     if (fllStableDelay)
 4590              		.loc 2 1340 8
 4591 0134 3B68     		ldr	r3, [r7]
 4592 0136 002B     		cmp	r3, #0
 4593 0138 01D0     		beq	.L302
1341:../drivers/fsl_clock.c ****     {
1342:../drivers/fsl_clock.c ****         fllStableDelay();
 4594              		.loc 2 1342 9
 4595 013a 3B68     		ldr	r3, [r7]
 4596 013c 9847     		blx	r3
 4597              	.LVL22:
 4598              	.L302:
1343:../drivers/fsl_clock.c ****     }
1344:../drivers/fsl_clock.c **** 
1345:../drivers/fsl_clock.c ****     return kStatus_Success;
 4599              		.loc 2 1345 12
 4600 013e 0023     		movs	r3, #0
1346:../drivers/fsl_clock.c **** }
 4601              		.loc 2 1346 1
 4602 0140 1800     		movs	r0, r3
 4603 0142 BD46     		mov	sp, r7
 4604 0144 05B0     		add	sp, sp, #20
 4605              		@ sp needed
 4606 0146 90BD     		pop	{r4, r7, pc}
 4607              	.L306:
 4608              		.align	2
 4609              	.L305:
 4610 0148 00400640 		.word	1074151424
 4611              		.cfi_endproc
 4612              	.LFE93:
 4614              		.section	.text.CLOCK_SetBlpiMode,"ax",%progbits
 4615              		.align	1
 4616              		.global	CLOCK_SetBlpiMode
 4617              		.syntax unified
 4618              		.code	16
 4619              		.thumb_func
 4620              		.fpu softvfp
 4622              	CLOCK_SetBlpiMode:
 4623              	.LFB94:
1347:../drivers/fsl_clock.c **** 
1348:../drivers/fsl_clock.c **** status_t CLOCK_SetBlpiMode(void)
1349:../drivers/fsl_clock.c **** {
 4624              		.loc 2 1349 1
 4625              		.cfi_startproc
 4626              		@ args = 0, pretend = 0, frame = 0
 4627              		@ frame_needed = 1, uses_anonymous_args = 0
 4628 0000 80B5     		push	{r7, lr}
 4629              		.cfi_def_cfa_offset 8
 4630              		.cfi_offset 7, -8
 4631              		.cfi_offset 14, -4
 4632 0002 00AF     		add	r7, sp, #0
 4633              		.cfi_def_cfa_register 7
1350:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1351:../drivers/fsl_clock.c ****     if (MCG_S_CLKST_VAL != kMCG_ClkOutStatInt)
1352:../drivers/fsl_clock.c ****     {
1353:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeUnreachable;
1354:../drivers/fsl_clock.c ****     }
1355:../drivers/fsl_clock.c **** #endif /* MCG_CONFIG_CHECK_PARAM */
1356:../drivers/fsl_clock.c **** 
1357:../drivers/fsl_clock.c ****     /* Set LP. */
1358:../drivers/fsl_clock.c ****     MCG->C2 |= MCG_C2_LP_MASK;
 4634              		.loc 2 1358 13
 4635 0004 054B     		ldr	r3, .L309
 4636 0006 5B78     		ldrb	r3, [r3, #1]
 4637 0008 DBB2     		uxtb	r3, r3
 4638 000a 044A     		ldr	r2, .L309
 4639 000c 0221     		movs	r1, #2
 4640 000e 0B43     		orrs	r3, r1
 4641 0010 DBB2     		uxtb	r3, r3
 4642 0012 5370     		strb	r3, [r2, #1]
1359:../drivers/fsl_clock.c **** 
1360:../drivers/fsl_clock.c ****     return kStatus_Success;
 4643              		.loc 2 1360 12
 4644 0014 0023     		movs	r3, #0
1361:../drivers/fsl_clock.c **** }
 4645              		.loc 2 1361 1
 4646 0016 1800     		movs	r0, r3
 4647 0018 BD46     		mov	sp, r7
 4648              		@ sp needed
 4649 001a 80BD     		pop	{r7, pc}
 4650              	.L310:
 4651              		.align	2
 4652              	.L309:
 4653 001c 00400640 		.word	1074151424
 4654              		.cfi_endproc
 4655              	.LFE94:
 4657              		.section	.text.CLOCK_SetBlpeMode,"ax",%progbits
 4658              		.align	1
 4659              		.global	CLOCK_SetBlpeMode
 4660              		.syntax unified
 4661              		.code	16
 4662              		.thumb_func
 4663              		.fpu softvfp
 4665              	CLOCK_SetBlpeMode:
 4666              	.LFB95:
1362:../drivers/fsl_clock.c **** 
1363:../drivers/fsl_clock.c **** status_t CLOCK_SetBlpeMode(void)
1364:../drivers/fsl_clock.c **** {
 4667              		.loc 2 1364 1
 4668              		.cfi_startproc
 4669              		@ args = 0, pretend = 0, frame = 0
 4670              		@ frame_needed = 1, uses_anonymous_args = 0
 4671 0000 80B5     		push	{r7, lr}
 4672              		.cfi_def_cfa_offset 8
 4673              		.cfi_offset 7, -8
 4674              		.cfi_offset 14, -4
 4675 0002 00AF     		add	r7, sp, #0
 4676              		.cfi_def_cfa_register 7
1365:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1366:../drivers/fsl_clock.c ****     if (MCG_S_CLKST_VAL != kMCG_ClkOutStatExt)
1367:../drivers/fsl_clock.c ****     {
1368:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeUnreachable;
1369:../drivers/fsl_clock.c ****     }
1370:../drivers/fsl_clock.c **** #endif
1371:../drivers/fsl_clock.c **** 
1372:../drivers/fsl_clock.c ****     /* Set LP bit to enter BLPE mode. */
1373:../drivers/fsl_clock.c ****     MCG->C2 |= MCG_C2_LP_MASK;
 4677              		.loc 2 1373 13
 4678 0004 054B     		ldr	r3, .L313
 4679 0006 5B78     		ldrb	r3, [r3, #1]
 4680 0008 DBB2     		uxtb	r3, r3
 4681 000a 044A     		ldr	r2, .L313
 4682 000c 0221     		movs	r1, #2
 4683 000e 0B43     		orrs	r3, r1
 4684 0010 DBB2     		uxtb	r3, r3
 4685 0012 5370     		strb	r3, [r2, #1]
1374:../drivers/fsl_clock.c **** 
1375:../drivers/fsl_clock.c ****     return kStatus_Success;
 4686              		.loc 2 1375 12
 4687 0014 0023     		movs	r3, #0
1376:../drivers/fsl_clock.c **** }
 4688              		.loc 2 1376 1
 4689 0016 1800     		movs	r0, r3
 4690 0018 BD46     		mov	sp, r7
 4691              		@ sp needed
 4692 001a 80BD     		pop	{r7, pc}
 4693              	.L314:
 4694              		.align	2
 4695              	.L313:
 4696 001c 00400640 		.word	1074151424
 4697              		.cfi_endproc
 4698              	.LFE95:
 4700              		.section	.rodata.CLOCK_SetPbeMode.str1.4,"aMS",%progbits,1
 4701              		.align	2
 4702              	.LC21:
 4703 0000 2E66736C 		.ascii	".fsl_clock.c:1380 : config\000"
 4703      5F636C6F 
 4703      636B2E63 
 4703      3A313338 
 4703      30203A20 
 4704              		.section	.text.CLOCK_SetPbeMode,"ax",%progbits
 4705              		.align	1
 4706              		.global	CLOCK_SetPbeMode
 4707              		.syntax unified
 4708              		.code	16
 4709              		.thumb_func
 4710              		.fpu softvfp
 4712              	CLOCK_SetPbeMode:
 4713              	.LFB96:
1377:../drivers/fsl_clock.c **** 
1378:../drivers/fsl_clock.c **** status_t CLOCK_SetPbeMode(mcg_pll_clk_select_t pllcs, mcg_pll_config_t const *config)
1379:../drivers/fsl_clock.c **** {
 4714              		.loc 2 1379 1
 4715              		.cfi_startproc
 4716              		@ args = 0, pretend = 0, frame = 8
 4717              		@ frame_needed = 1, uses_anonymous_args = 0
 4718 0000 80B5     		push	{r7, lr}
 4719              		.cfi_def_cfa_offset 8
 4720              		.cfi_offset 7, -8
 4721              		.cfi_offset 14, -4
 4722 0002 82B0     		sub	sp, sp, #8
 4723              		.cfi_def_cfa_offset 16
 4724 0004 00AF     		add	r7, sp, #0
 4725              		.cfi_def_cfa_register 7
 4726 0006 0200     		movs	r2, r0
 4727 0008 3960     		str	r1, [r7]
 4728 000a FB1D     		adds	r3, r7, #7
 4729 000c 1A70     		strb	r2, [r3]
1380:../drivers/fsl_clock.c ****     assert(config);
 4730              		.loc 2 1380 5
 4731 000e 3B68     		ldr	r3, [r7]
 4732 0010 002B     		cmp	r3, #0
 4733 0012 03D1     		bne	.L316
 4734              		.loc 2 1380 5 is_stmt 0 discriminator 1
 4735 0014 244B     		ldr	r3, .L321
 4736 0016 1800     		movs	r0, r3
 4737 0018 FFF7FEFF 		bl	__assertion_failed
 4738              	.L316:
1381:../drivers/fsl_clock.c **** 
1382:../drivers/fsl_clock.c ****     /*
1383:../drivers/fsl_clock.c ****        This function is designed to change MCG to PBE mode from PEE/BLPE/FBE,
1384:../drivers/fsl_clock.c ****        but with this workflow, the source mode could be all modes except PEI/PBI.
1385:../drivers/fsl_clock.c ****      */
1386:../drivers/fsl_clock.c ****     MCG->C2 &= ~MCG_C2_LP_MASK; /* Disable lowpower. */
 4739              		.loc 2 1386 13 is_stmt 1
 4740 001c 234B     		ldr	r3, .L321+4
 4741 001e 5B78     		ldrb	r3, [r3, #1]
 4742 0020 DBB2     		uxtb	r3, r3
 4743 0022 224A     		ldr	r2, .L321+4
 4744 0024 0221     		movs	r1, #2
 4745 0026 8B43     		bics	r3, r1
 4746 0028 DBB2     		uxtb	r3, r3
 4747 002a 5370     		strb	r3, [r2, #1]
1387:../drivers/fsl_clock.c **** 
1388:../drivers/fsl_clock.c ****     /* Change to use external clock first. */
1389:../drivers/fsl_clock.c ****     MCG->C1 = ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK)) | MCG_C1_CLKS(kMCG_ClkOutSrcExte
 4748              		.loc 2 1389 20
 4749 002c 1F4B     		ldr	r3, .L321+4
 4750 002e 1B78     		ldrb	r3, [r3]
 4751 0030 DBB2     		uxtb	r3, r3
 4752              		.loc 2 1389 25
 4753 0032 3B22     		movs	r2, #59
 4754 0034 1340     		ands	r3, r2
 4755 0036 DBB2     		uxtb	r3, r3
 4756              		.loc 2 1389 8
 4757 0038 1C49     		ldr	r1, .L321+4
 4758              		.loc 2 1389 68
 4759 003a 8022     		movs	r2, #128
 4760 003c 5242     		rsbs	r2, r2, #0
 4761 003e 1343     		orrs	r3, r2
 4762 0040 DBB2     		uxtb	r3, r3
 4763              		.loc 2 1389 13
 4764 0042 0B70     		strb	r3, [r1]
1390:../drivers/fsl_clock.c **** 
1391:../drivers/fsl_clock.c ****     /* Wait for CLKST clock status bits to show clock source is ext ref clk */
1392:../drivers/fsl_clock.c ****     while ((MCG->S & (MCG_S_IREFST_MASK | MCG_S_CLKST_MASK)) !=
 4765              		.loc 2 1392 11
 4766 0044 C046     		nop
 4767              	.L317:
 4768              		.loc 2 1392 16 discriminator 1
 4769 0046 194B     		ldr	r3, .L321+4
 4770 0048 9B79     		ldrb	r3, [r3, #6]
 4771 004a DBB2     		uxtb	r3, r3
 4772              		.loc 2 1392 20 discriminator 1
 4773 004c 1A00     		movs	r2, r3
 4774 004e 1C23     		movs	r3, #28
 4775 0050 1340     		ands	r3, r2
 4776              		.loc 2 1392 11 discriminator 1
 4777 0052 082B     		cmp	r3, #8
 4778 0054 F7D1     		bne	.L317
1393:../drivers/fsl_clock.c ****            (MCG_S_IREFST(kMCG_FllSrcExternal) | MCG_S_CLKST(kMCG_ClkOutStatExt)))
1394:../drivers/fsl_clock.c ****     {
1395:../drivers/fsl_clock.c ****     }
1396:../drivers/fsl_clock.c **** 
1397:../drivers/fsl_clock.c ****     /* Disable PLL first, then configure PLL. */
1398:../drivers/fsl_clock.c ****     MCG->C6 &= ~MCG_C6_PLLS_MASK;
 4779              		.loc 2 1398 13
 4780 0056 154B     		ldr	r3, .L321+4
 4781 0058 5B79     		ldrb	r3, [r3, #5]
 4782 005a DBB2     		uxtb	r3, r3
 4783 005c 134A     		ldr	r2, .L321+4
 4784 005e 4021     		movs	r1, #64
 4785 0060 8B43     		bics	r3, r1
 4786 0062 DBB2     		uxtb	r3, r3
 4787 0064 5371     		strb	r3, [r2, #5]
1399:../drivers/fsl_clock.c ****     while (MCG->S & MCG_S_PLLST_MASK)
 4788              		.loc 2 1399 11
 4789 0066 C046     		nop
 4790              	.L318:
 4791              		.loc 2 1399 15 discriminator 1
 4792 0068 104B     		ldr	r3, .L321+4
 4793 006a 9B79     		ldrb	r3, [r3, #6]
 4794 006c DBB2     		uxtb	r3, r3
 4795              		.loc 2 1399 19 discriminator 1
 4796 006e 1A00     		movs	r2, r3
 4797 0070 2023     		movs	r3, #32
 4798 0072 1340     		ands	r3, r2
 4799              		.loc 2 1399 11 discriminator 1
 4800 0074 F8D1     		bne	.L318
1400:../drivers/fsl_clock.c ****     {
1401:../drivers/fsl_clock.c ****     }
1402:../drivers/fsl_clock.c **** 
1403:../drivers/fsl_clock.c ****     /* Configure the PLL. */
1404:../drivers/fsl_clock.c ****     {
1405:../drivers/fsl_clock.c ****         CLOCK_EnablePll0(config);
 4801              		.loc 2 1405 9
 4802 0076 3B68     		ldr	r3, [r7]
 4803 0078 1800     		movs	r0, r3
 4804 007a FFF7FEFF 		bl	CLOCK_EnablePll0
1406:../drivers/fsl_clock.c ****     }
1407:../drivers/fsl_clock.c **** 
1408:../drivers/fsl_clock.c ****     /* Change to PLL mode. */
1409:../drivers/fsl_clock.c ****     MCG->C6 |= MCG_C6_PLLS_MASK;
 4805              		.loc 2 1409 13
 4806 007e 0B4B     		ldr	r3, .L321+4
 4807 0080 5B79     		ldrb	r3, [r3, #5]
 4808 0082 DBB2     		uxtb	r3, r3
 4809 0084 094A     		ldr	r2, .L321+4
 4810 0086 4021     		movs	r1, #64
 4811 0088 0B43     		orrs	r3, r1
 4812 008a DBB2     		uxtb	r3, r3
 4813 008c 5371     		strb	r3, [r2, #5]
1410:../drivers/fsl_clock.c **** 
1411:../drivers/fsl_clock.c ****     /* Wait for PLL mode changed. */
1412:../drivers/fsl_clock.c ****     while (!(MCG->S & MCG_S_PLLST_MASK))
 4814              		.loc 2 1412 11
 4815 008e C046     		nop
 4816              	.L319:
 4817              		.loc 2 1412 17 discriminator 1
 4818 0090 064B     		ldr	r3, .L321+4
 4819 0092 9B79     		ldrb	r3, [r3, #6]
 4820 0094 DBB2     		uxtb	r3, r3
 4821              		.loc 2 1412 21 discriminator 1
 4822 0096 1A00     		movs	r2, r3
 4823 0098 2023     		movs	r3, #32
 4824 009a 1340     		ands	r3, r2
 4825              		.loc 2 1412 11 discriminator 1
 4826 009c F8D0     		beq	.L319
1413:../drivers/fsl_clock.c ****     {
1414:../drivers/fsl_clock.c ****     }
1415:../drivers/fsl_clock.c **** 
1416:../drivers/fsl_clock.c ****     return kStatus_Success;
 4827              		.loc 2 1416 12
 4828 009e 0023     		movs	r3, #0
1417:../drivers/fsl_clock.c **** }
 4829              		.loc 2 1417 1
 4830 00a0 1800     		movs	r0, r3
 4831 00a2 BD46     		mov	sp, r7
 4832 00a4 02B0     		add	sp, sp, #8
 4833              		@ sp needed
 4834 00a6 80BD     		pop	{r7, pc}
 4835              	.L322:
 4836              		.align	2
 4837              	.L321:
 4838 00a8 00000000 		.word	.LC21
 4839 00ac 00400640 		.word	1074151424
 4840              		.cfi_endproc
 4841              	.LFE96:
 4843              		.section	.text.CLOCK_SetPeeMode,"ax",%progbits
 4844              		.align	1
 4845              		.global	CLOCK_SetPeeMode
 4846              		.syntax unified
 4847              		.code	16
 4848              		.thumb_func
 4849              		.fpu softvfp
 4851              	CLOCK_SetPeeMode:
 4852              	.LFB97:
1418:../drivers/fsl_clock.c **** 
1419:../drivers/fsl_clock.c **** status_t CLOCK_SetPeeMode(void)
1420:../drivers/fsl_clock.c **** {
 4853              		.loc 2 1420 1
 4854              		.cfi_startproc
 4855              		@ args = 0, pretend = 0, frame = 0
 4856              		@ frame_needed = 1, uses_anonymous_args = 0
 4857 0000 80B5     		push	{r7, lr}
 4858              		.cfi_def_cfa_offset 8
 4859              		.cfi_offset 7, -8
 4860              		.cfi_offset 14, -4
 4861 0002 00AF     		add	r7, sp, #0
 4862              		.cfi_def_cfa_register 7
1421:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1422:../drivers/fsl_clock.c ****     mcg_mode_t mode = CLOCK_GetMode();
1423:../drivers/fsl_clock.c ****     if (kMCG_ModePBE != mode)
1424:../drivers/fsl_clock.c ****     {
1425:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeUnreachable;
1426:../drivers/fsl_clock.c ****     }
1427:../drivers/fsl_clock.c **** #endif
1428:../drivers/fsl_clock.c **** 
1429:../drivers/fsl_clock.c ****     /* Change to use PLL/FLL output clock first. */
1430:../drivers/fsl_clock.c ****     MCG->C1 = (MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcOut);
 4863              		.loc 2 1430 19
 4864 0004 0A4B     		ldr	r3, .L326
 4865 0006 1B78     		ldrb	r3, [r3]
 4866 0008 DBB2     		uxtb	r3, r3
 4867              		.loc 2 1430 8
 4868 000a 094A     		ldr	r2, .L326
 4869              		.loc 2 1430 45
 4870 000c 3F21     		movs	r1, #63
 4871 000e 0B40     		ands	r3, r1
 4872 0010 DBB2     		uxtb	r3, r3
 4873              		.loc 2 1430 13
 4874 0012 1370     		strb	r3, [r2]
1431:../drivers/fsl_clock.c **** 
1432:../drivers/fsl_clock.c ****     /* Wait for clock status bits to update */
1433:../drivers/fsl_clock.c ****     while (MCG_S_CLKST_VAL != kMCG_ClkOutStatPll)
 4875              		.loc 2 1433 11
 4876 0014 C046     		nop
 4877              	.L324:
 4878              		.loc 2 1433 12 discriminator 1
 4879 0016 064B     		ldr	r3, .L326
 4880 0018 9B79     		ldrb	r3, [r3, #6]
 4881 001a DBB2     		uxtb	r3, r3
 4882 001c 9B08     		lsrs	r3, r3, #2
 4883 001e 0322     		movs	r2, #3
 4884 0020 1340     		ands	r3, r2
 4885              		.loc 2 1433 11 discriminator 1
 4886 0022 032B     		cmp	r3, #3
 4887 0024 F7D1     		bne	.L324
1434:../drivers/fsl_clock.c ****     {
1435:../drivers/fsl_clock.c ****     }
1436:../drivers/fsl_clock.c **** 
1437:../drivers/fsl_clock.c ****     return kStatus_Success;
 4888              		.loc 2 1437 12
 4889 0026 0023     		movs	r3, #0
1438:../drivers/fsl_clock.c **** }
 4890              		.loc 2 1438 1
 4891 0028 1800     		movs	r0, r3
 4892 002a BD46     		mov	sp, r7
 4893              		@ sp needed
 4894 002c 80BD     		pop	{r7, pc}
 4895              	.L327:
 4896 002e C046     		.align	2
 4897              	.L326:
 4898 0030 00400640 		.word	1074151424
 4899              		.cfi_endproc
 4900              	.LFE97:
 4902              		.section	.text.CLOCK_ExternalModeToFbeModeQuick,"ax",%progbits
 4903              		.align	1
 4904              		.global	CLOCK_ExternalModeToFbeModeQuick
 4905              		.syntax unified
 4906              		.code	16
 4907              		.thumb_func
 4908              		.fpu softvfp
 4910              	CLOCK_ExternalModeToFbeModeQuick:
 4911              	.LFB98:
1439:../drivers/fsl_clock.c **** 
1440:../drivers/fsl_clock.c **** status_t CLOCK_ExternalModeToFbeModeQuick(void)
1441:../drivers/fsl_clock.c **** {
 4912              		.loc 2 1441 1
 4913              		.cfi_startproc
 4914              		@ args = 0, pretend = 0, frame = 0
 4915              		@ frame_needed = 1, uses_anonymous_args = 0
 4916 0000 80B5     		push	{r7, lr}
 4917              		.cfi_def_cfa_offset 8
 4918              		.cfi_offset 7, -8
 4919              		.cfi_offset 14, -4
 4920 0002 00AF     		add	r7, sp, #0
 4921              		.cfi_def_cfa_register 7
1442:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1443:../drivers/fsl_clock.c ****     if (MCG->S & MCG_S_IREFST_MASK)
1444:../drivers/fsl_clock.c ****     {
1445:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeInvalid;
1446:../drivers/fsl_clock.c ****     }
1447:../drivers/fsl_clock.c **** #endif /* MCG_CONFIG_CHECK_PARAM */
1448:../drivers/fsl_clock.c **** 
1449:../drivers/fsl_clock.c ****     /* Disable low power */
1450:../drivers/fsl_clock.c ****     MCG->C2 &= ~MCG_C2_LP_MASK;
 4922              		.loc 2 1450 13
 4923 0004 184B     		ldr	r3, .L332
 4924 0006 5B78     		ldrb	r3, [r3, #1]
 4925 0008 DBB2     		uxtb	r3, r3
 4926 000a 174A     		ldr	r2, .L332
 4927 000c 0221     		movs	r1, #2
 4928 000e 8B43     		bics	r3, r1
 4929 0010 DBB2     		uxtb	r3, r3
 4930 0012 5370     		strb	r3, [r2, #1]
1451:../drivers/fsl_clock.c **** 
1452:../drivers/fsl_clock.c ****     MCG->C1 = ((MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcExternal));
 4931              		.loc 2 1452 20
 4932 0014 144B     		ldr	r3, .L332
 4933 0016 1B78     		ldrb	r3, [r3]
 4934 0018 DBB2     		uxtb	r3, r3
 4935              		.loc 2 1452 25
 4936 001a 3F22     		movs	r2, #63
 4937 001c 1340     		ands	r3, r2
 4938 001e DBB2     		uxtb	r3, r3
 4939              		.loc 2 1452 8
 4940 0020 1149     		ldr	r1, .L332
 4941              		.loc 2 1452 46
 4942 0022 8022     		movs	r2, #128
 4943 0024 5242     		rsbs	r2, r2, #0
 4944 0026 1343     		orrs	r3, r2
 4945 0028 DBB2     		uxtb	r3, r3
 4946              		.loc 2 1452 13
 4947 002a 0B70     		strb	r3, [r1]
1453:../drivers/fsl_clock.c ****     while (MCG_S_CLKST_VAL != kMCG_ClkOutStatExt)
 4948              		.loc 2 1453 11
 4949 002c C046     		nop
 4950              	.L329:
 4951              		.loc 2 1453 12 discriminator 1
 4952 002e 0E4B     		ldr	r3, .L332
 4953 0030 9B79     		ldrb	r3, [r3, #6]
 4954 0032 DBB2     		uxtb	r3, r3
 4955 0034 9B08     		lsrs	r3, r3, #2
 4956 0036 0322     		movs	r2, #3
 4957 0038 1340     		ands	r3, r2
 4958              		.loc 2 1453 11 discriminator 1
 4959 003a 022B     		cmp	r3, #2
 4960 003c F7D1     		bne	.L329
1454:../drivers/fsl_clock.c ****     {
1455:../drivers/fsl_clock.c ****     }
1456:../drivers/fsl_clock.c **** 
1457:../drivers/fsl_clock.c ****     /* Disable PLL. */
1458:../drivers/fsl_clock.c ****     MCG->C6 &= ~MCG_C6_PLLS_MASK;
 4961              		.loc 2 1458 13
 4962 003e 0A4B     		ldr	r3, .L332
 4963 0040 5B79     		ldrb	r3, [r3, #5]
 4964 0042 DBB2     		uxtb	r3, r3
 4965 0044 084A     		ldr	r2, .L332
 4966 0046 4021     		movs	r1, #64
 4967 0048 8B43     		bics	r3, r1
 4968 004a DBB2     		uxtb	r3, r3
 4969 004c 5371     		strb	r3, [r2, #5]
1459:../drivers/fsl_clock.c ****     while (MCG->S & MCG_S_PLLST_MASK)
 4970              		.loc 2 1459 11
 4971 004e C046     		nop
 4972              	.L330:
 4973              		.loc 2 1459 15 discriminator 1
 4974 0050 054B     		ldr	r3, .L332
 4975 0052 9B79     		ldrb	r3, [r3, #6]
 4976 0054 DBB2     		uxtb	r3, r3
 4977              		.loc 2 1459 19 discriminator 1
 4978 0056 1A00     		movs	r2, r3
 4979 0058 2023     		movs	r3, #32
 4980 005a 1340     		ands	r3, r2
 4981              		.loc 2 1459 11 discriminator 1
 4982 005c F8D1     		bne	.L330
1460:../drivers/fsl_clock.c ****     {
1461:../drivers/fsl_clock.c ****     }
1462:../drivers/fsl_clock.c **** 
1463:../drivers/fsl_clock.c ****     return kStatus_Success;
 4983              		.loc 2 1463 12
 4984 005e 0023     		movs	r3, #0
1464:../drivers/fsl_clock.c **** }
 4985              		.loc 2 1464 1
 4986 0060 1800     		movs	r0, r3
 4987 0062 BD46     		mov	sp, r7
 4988              		@ sp needed
 4989 0064 80BD     		pop	{r7, pc}
 4990              	.L333:
 4991 0066 C046     		.align	2
 4992              	.L332:
 4993 0068 00400640 		.word	1074151424
 4994              		.cfi_endproc
 4995              	.LFE98:
 4997              		.section	.text.CLOCK_InternalModeToFbiModeQuick,"ax",%progbits
 4998              		.align	1
 4999              		.global	CLOCK_InternalModeToFbiModeQuick
 5000              		.syntax unified
 5001              		.code	16
 5002              		.thumb_func
 5003              		.fpu softvfp
 5005              	CLOCK_InternalModeToFbiModeQuick:
 5006              	.LFB99:
1465:../drivers/fsl_clock.c **** 
1466:../drivers/fsl_clock.c **** status_t CLOCK_InternalModeToFbiModeQuick(void)
1467:../drivers/fsl_clock.c **** {
 5007              		.loc 2 1467 1
 5008              		.cfi_startproc
 5009              		@ args = 0, pretend = 0, frame = 0
 5010              		@ frame_needed = 1, uses_anonymous_args = 0
 5011 0000 80B5     		push	{r7, lr}
 5012              		.cfi_def_cfa_offset 8
 5013              		.cfi_offset 7, -8
 5014              		.cfi_offset 14, -4
 5015 0002 00AF     		add	r7, sp, #0
 5016              		.cfi_def_cfa_register 7
1468:../drivers/fsl_clock.c **** #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
1469:../drivers/fsl_clock.c ****     if (!(MCG->S & MCG_S_IREFST_MASK))
1470:../drivers/fsl_clock.c ****     {
1471:../drivers/fsl_clock.c ****         return kStatus_MCG_ModeInvalid;
1472:../drivers/fsl_clock.c ****     }
1473:../drivers/fsl_clock.c **** #endif
1474:../drivers/fsl_clock.c **** 
1475:../drivers/fsl_clock.c ****     /* Disable low power */
1476:../drivers/fsl_clock.c ****     MCG->C2 &= ~MCG_C2_LP_MASK;
 5017              		.loc 2 1476 13
 5018 0004 0F4B     		ldr	r3, .L337
 5019 0006 5B78     		ldrb	r3, [r3, #1]
 5020 0008 DBB2     		uxtb	r3, r3
 5021 000a 0E4A     		ldr	r2, .L337
 5022 000c 0221     		movs	r1, #2
 5023 000e 8B43     		bics	r3, r1
 5024 0010 DBB2     		uxtb	r3, r3
 5025 0012 5370     		strb	r3, [r2, #1]
1477:../drivers/fsl_clock.c **** 
1478:../drivers/fsl_clock.c ****     MCG->C1 = ((MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcInternal));
 5026              		.loc 2 1478 20
 5027 0014 0B4B     		ldr	r3, .L337
 5028 0016 1B78     		ldrb	r3, [r3]
 5029 0018 DBB2     		uxtb	r3, r3
 5030              		.loc 2 1478 25
 5031 001a 3F22     		movs	r2, #63
 5032 001c 1340     		ands	r3, r2
 5033 001e DBB2     		uxtb	r3, r3
 5034              		.loc 2 1478 8
 5035 0020 084A     		ldr	r2, .L337
 5036              		.loc 2 1478 46
 5037 0022 4021     		movs	r1, #64
 5038 0024 0B43     		orrs	r3, r1
 5039 0026 DBB2     		uxtb	r3, r3
 5040              		.loc 2 1478 13
 5041 0028 1370     		strb	r3, [r2]
1479:../drivers/fsl_clock.c ****     while (MCG_S_CLKST_VAL != kMCG_ClkOutStatInt)
 5042              		.loc 2 1479 11
 5043 002a C046     		nop
 5044              	.L335:
 5045              		.loc 2 1479 12 discriminator 1
 5046 002c 054B     		ldr	r3, .L337
 5047 002e 9B79     		ldrb	r3, [r3, #6]
 5048 0030 DBB2     		uxtb	r3, r3
 5049 0032 9B08     		lsrs	r3, r3, #2
 5050 0034 0322     		movs	r2, #3
 5051 0036 1340     		ands	r3, r2
 5052              		.loc 2 1479 11 discriminator 1
 5053 0038 012B     		cmp	r3, #1
 5054 003a F7D1     		bne	.L335
1480:../drivers/fsl_clock.c ****     {
1481:../drivers/fsl_clock.c ****     }
1482:../drivers/fsl_clock.c **** 
1483:../drivers/fsl_clock.c ****     return kStatus_Success;
 5055              		.loc 2 1483 12
 5056 003c 0023     		movs	r3, #0
1484:../drivers/fsl_clock.c **** }
 5057              		.loc 2 1484 1
 5058 003e 1800     		movs	r0, r3
 5059 0040 BD46     		mov	sp, r7
 5060              		@ sp needed
 5061 0042 80BD     		pop	{r7, pc}
 5062              	.L338:
 5063              		.align	2
 5064              	.L337:
 5065 0044 00400640 		.word	1074151424
 5066              		.cfi_endproc
 5067              	.LFE99:
 5069              		.section	.text.CLOCK_BootToFeiMode,"ax",%progbits
 5070              		.align	1
 5071              		.global	CLOCK_BootToFeiMode
 5072              		.syntax unified
 5073              		.code	16
 5074              		.thumb_func
 5075              		.fpu softvfp
 5077              	CLOCK_BootToFeiMode:
 5078              	.LFB100:
1485:../drivers/fsl_clock.c **** 
1486:../drivers/fsl_clock.c **** status_t CLOCK_BootToFeiMode(mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(void))
1487:../drivers/fsl_clock.c **** {
 5079              		.loc 2 1487 1
 5080              		.cfi_startproc
 5081              		@ args = 0, pretend = 0, frame = 8
 5082              		@ frame_needed = 1, uses_anonymous_args = 0
 5083 0000 80B5     		push	{r7, lr}
 5084              		.cfi_def_cfa_offset 8
 5085              		.cfi_offset 7, -8
 5086              		.cfi_offset 14, -4
 5087 0002 82B0     		sub	sp, sp, #8
 5088              		.cfi_def_cfa_offset 16
 5089 0004 00AF     		add	r7, sp, #0
 5090              		.cfi_def_cfa_register 7
 5091 0006 3A60     		str	r2, [r7]
 5092 0008 FB1D     		adds	r3, r7, #7
 5093 000a 021C     		adds	r2, r0, #0
 5094 000c 1A70     		strb	r2, [r3]
 5095 000e BB1D     		adds	r3, r7, #6
 5096 0010 0A1C     		adds	r2, r1, #0
 5097 0012 1A70     		strb	r2, [r3]
1488:../drivers/fsl_clock.c ****     return CLOCK_SetFeiMode(dmx32, drs, fllStableDelay);
 5098              		.loc 2 1488 12
 5099 0014 3A68     		ldr	r2, [r7]
 5100 0016 BB1D     		adds	r3, r7, #6
 5101 0018 1978     		ldrb	r1, [r3]
 5102 001a FB1D     		adds	r3, r7, #7
 5103 001c 1B78     		ldrb	r3, [r3]
 5104 001e 1800     		movs	r0, r3
 5105 0020 FFF7FEFF 		bl	CLOCK_SetFeiMode
 5106 0024 0300     		movs	r3, r0
1489:../drivers/fsl_clock.c **** }
 5107              		.loc 2 1489 1
 5108 0026 1800     		movs	r0, r3
 5109 0028 BD46     		mov	sp, r7
 5110 002a 02B0     		add	sp, sp, #8
 5111              		@ sp needed
 5112 002c 80BD     		pop	{r7, pc}
 5113              		.cfi_endproc
 5114              	.LFE100:
 5116              		.section	.text.CLOCK_BootToFeeMode,"ax",%progbits
 5117              		.align	1
 5118              		.global	CLOCK_BootToFeeMode
 5119              		.syntax unified
 5120              		.code	16
 5121              		.thumb_func
 5122              		.fpu softvfp
 5124              	CLOCK_BootToFeeMode:
 5125              	.LFB101:
1490:../drivers/fsl_clock.c **** 
1491:../drivers/fsl_clock.c **** status_t CLOCK_BootToFeeMode(
1492:../drivers/fsl_clock.c ****     mcg_oscsel_t oscsel, uint8_t frdiv, mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(vo
1493:../drivers/fsl_clock.c **** {
 5126              		.loc 2 1493 1
 5127              		.cfi_startproc
 5128              		@ args = 4, pretend = 0, frame = 8
 5129              		@ frame_needed = 1, uses_anonymous_args = 0
 5130 0000 B0B5     		push	{r4, r5, r7, lr}
 5131              		.cfi_def_cfa_offset 16
 5132              		.cfi_offset 4, -16
 5133              		.cfi_offset 5, -12
 5134              		.cfi_offset 7, -8
 5135              		.cfi_offset 14, -4
 5136 0002 82B0     		sub	sp, sp, #8
 5137              		.cfi_def_cfa_offset 24
 5138 0004 00AF     		add	r7, sp, #0
 5139              		.cfi_def_cfa_register 7
 5140 0006 0500     		movs	r5, r0
 5141 0008 0C00     		movs	r4, r1
 5142 000a 1000     		movs	r0, r2
 5143 000c 1900     		movs	r1, r3
 5144 000e FB1D     		adds	r3, r7, #7
 5145 0010 2A1C     		adds	r2, r5, #0
 5146 0012 1A70     		strb	r2, [r3]
 5147 0014 BB1D     		adds	r3, r7, #6
 5148 0016 221C     		adds	r2, r4, #0
 5149 0018 1A70     		strb	r2, [r3]
 5150 001a 7B1D     		adds	r3, r7, #5
 5151 001c 021C     		adds	r2, r0, #0
 5152 001e 1A70     		strb	r2, [r3]
 5153 0020 3B1D     		adds	r3, r7, #4
 5154 0022 0A1C     		adds	r2, r1, #0
 5155 0024 1A70     		strb	r2, [r3]
1494:../drivers/fsl_clock.c ****     CLOCK_SetExternalRefClkConfig(oscsel);
 5156              		.loc 2 1494 5
 5157 0026 FB1D     		adds	r3, r7, #7
 5158 0028 1B78     		ldrb	r3, [r3]
 5159 002a 1800     		movs	r0, r3
 5160 002c FFF7FEFF 		bl	CLOCK_SetExternalRefClkConfig
1495:../drivers/fsl_clock.c **** 
1496:../drivers/fsl_clock.c ****     return CLOCK_SetFeeMode(frdiv, dmx32, drs, fllStableDelay);
 5161              		.loc 2 1496 12
 5162 0030 BC69     		ldr	r4, [r7, #24]
 5163 0032 3B1D     		adds	r3, r7, #4
 5164 0034 1A78     		ldrb	r2, [r3]
 5165 0036 7B1D     		adds	r3, r7, #5
 5166 0038 1978     		ldrb	r1, [r3]
 5167 003a BB1D     		adds	r3, r7, #6
 5168 003c 1878     		ldrb	r0, [r3]
 5169 003e 2300     		movs	r3, r4
 5170 0040 FFF7FEFF 		bl	CLOCK_SetFeeMode
 5171 0044 0300     		movs	r3, r0
1497:../drivers/fsl_clock.c **** }
 5172              		.loc 2 1497 1
 5173 0046 1800     		movs	r0, r3
 5174 0048 BD46     		mov	sp, r7
 5175 004a 02B0     		add	sp, sp, #8
 5176              		@ sp needed
 5177 004c B0BD     		pop	{r4, r5, r7, pc}
 5178              		.cfi_endproc
 5179              	.LFE101:
 5181              		.section	.text.CLOCK_BootToBlpiMode,"ax",%progbits
 5182              		.align	1
 5183              		.global	CLOCK_BootToBlpiMode
 5184              		.syntax unified
 5185              		.code	16
 5186              		.thumb_func
 5187              		.fpu softvfp
 5189              	CLOCK_BootToBlpiMode:
 5190              	.LFB102:
1498:../drivers/fsl_clock.c **** 
1499:../drivers/fsl_clock.c **** status_t CLOCK_BootToBlpiMode(uint8_t fcrdiv, mcg_irc_mode_t ircs, uint8_t ircEnableMode)
1500:../drivers/fsl_clock.c **** {
 5191              		.loc 2 1500 1
 5192              		.cfi_startproc
 5193              		@ args = 0, pretend = 0, frame = 8
 5194              		@ frame_needed = 1, uses_anonymous_args = 0
 5195 0000 90B5     		push	{r4, r7, lr}
 5196              		.cfi_def_cfa_offset 12
 5197              		.cfi_offset 4, -12
 5198              		.cfi_offset 7, -8
 5199              		.cfi_offset 14, -4
 5200 0002 83B0     		sub	sp, sp, #12
 5201              		.cfi_def_cfa_offset 24
 5202 0004 00AF     		add	r7, sp, #0
 5203              		.cfi_def_cfa_register 7
 5204 0006 0400     		movs	r4, r0
 5205 0008 0800     		movs	r0, r1
 5206 000a 1100     		movs	r1, r2
 5207 000c FB1D     		adds	r3, r7, #7
 5208 000e 221C     		adds	r2, r4, #0
 5209 0010 1A70     		strb	r2, [r3]
 5210 0012 BB1D     		adds	r3, r7, #6
 5211 0014 021C     		adds	r2, r0, #0
 5212 0016 1A70     		strb	r2, [r3]
 5213 0018 7B1D     		adds	r3, r7, #5
 5214 001a 0A1C     		adds	r2, r1, #0
 5215 001c 1A70     		strb	r2, [r3]
1501:../drivers/fsl_clock.c ****     /* If reset mode is FEI mode, set MCGIRCLK and always success. */
1502:../drivers/fsl_clock.c ****     CLOCK_SetInternalRefClkConfig(ircEnableMode, ircs, fcrdiv);
 5216              		.loc 2 1502 5
 5217 001e FB1D     		adds	r3, r7, #7
 5218 0020 1A78     		ldrb	r2, [r3]
 5219 0022 BB1D     		adds	r3, r7, #6
 5220 0024 1978     		ldrb	r1, [r3]
 5221 0026 7B1D     		adds	r3, r7, #5
 5222 0028 1B78     		ldrb	r3, [r3]
 5223 002a 1800     		movs	r0, r3
 5224 002c FFF7FEFF 		bl	CLOCK_SetInternalRefClkConfig
1503:../drivers/fsl_clock.c **** 
1504:../drivers/fsl_clock.c ****     /* If reset mode is not BLPI, first enter FBI mode. */
1505:../drivers/fsl_clock.c ****     MCG->C1 = (MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcInternal);
 5225              		.loc 2 1505 19
 5226 0030 104B     		ldr	r3, .L346
 5227 0032 1B78     		ldrb	r3, [r3]
 5228 0034 DBB2     		uxtb	r3, r3
 5229              		.loc 2 1505 24
 5230 0036 3F22     		movs	r2, #63
 5231 0038 1340     		ands	r3, r2
 5232 003a DBB2     		uxtb	r3, r3
 5233              		.loc 2 1505 8
 5234 003c 0D4A     		ldr	r2, .L346
 5235              		.loc 2 1505 45
 5236 003e 4021     		movs	r1, #64
 5237 0040 0B43     		orrs	r3, r1
 5238 0042 DBB2     		uxtb	r3, r3
 5239              		.loc 2 1505 13
 5240 0044 1370     		strb	r3, [r2]
1506:../drivers/fsl_clock.c ****     while (MCG_S_CLKST_VAL != kMCG_ClkOutStatInt)
 5241              		.loc 2 1506 11
 5242 0046 C046     		nop
 5243              	.L344:
 5244              		.loc 2 1506 12 discriminator 1
 5245 0048 0A4B     		ldr	r3, .L346
 5246 004a 9B79     		ldrb	r3, [r3, #6]
 5247 004c DBB2     		uxtb	r3, r3
 5248 004e 9B08     		lsrs	r3, r3, #2
 5249 0050 0322     		movs	r2, #3
 5250 0052 1340     		ands	r3, r2
 5251              		.loc 2 1506 11 discriminator 1
 5252 0054 012B     		cmp	r3, #1
 5253 0056 F7D1     		bne	.L344
1507:../drivers/fsl_clock.c ****     {
1508:../drivers/fsl_clock.c ****     }
1509:../drivers/fsl_clock.c **** 
1510:../drivers/fsl_clock.c ****     /* Enter BLPI mode. */
1511:../drivers/fsl_clock.c ****     MCG->C2 |= MCG_C2_LP_MASK;
 5254              		.loc 2 1511 13
 5255 0058 064B     		ldr	r3, .L346
 5256 005a 5B78     		ldrb	r3, [r3, #1]
 5257 005c DBB2     		uxtb	r3, r3
 5258 005e 054A     		ldr	r2, .L346
 5259 0060 0221     		movs	r1, #2
 5260 0062 0B43     		orrs	r3, r1
 5261 0064 DBB2     		uxtb	r3, r3
 5262 0066 5370     		strb	r3, [r2, #1]
1512:../drivers/fsl_clock.c **** 
1513:../drivers/fsl_clock.c ****     return kStatus_Success;
 5263              		.loc 2 1513 12
 5264 0068 0023     		movs	r3, #0
1514:../drivers/fsl_clock.c **** }
 5265              		.loc 2 1514 1
 5266 006a 1800     		movs	r0, r3
 5267 006c BD46     		mov	sp, r7
 5268 006e 03B0     		add	sp, sp, #12
 5269              		@ sp needed
 5270 0070 90BD     		pop	{r4, r7, pc}
 5271              	.L347:
 5272 0072 C046     		.align	2
 5273              	.L346:
 5274 0074 00400640 		.word	1074151424
 5275              		.cfi_endproc
 5276              	.LFE102:
 5278              		.section	.text.CLOCK_BootToBlpeMode,"ax",%progbits
 5279              		.align	1
 5280              		.global	CLOCK_BootToBlpeMode
 5281              		.syntax unified
 5282              		.code	16
 5283              		.thumb_func
 5284              		.fpu softvfp
 5286              	CLOCK_BootToBlpeMode:
 5287              	.LFB103:
1515:../drivers/fsl_clock.c **** 
1516:../drivers/fsl_clock.c **** status_t CLOCK_BootToBlpeMode(mcg_oscsel_t oscsel)
1517:../drivers/fsl_clock.c **** {
 5288              		.loc 2 1517 1
 5289              		.cfi_startproc
 5290              		@ args = 0, pretend = 0, frame = 8
 5291              		@ frame_needed = 1, uses_anonymous_args = 0
 5292 0000 80B5     		push	{r7, lr}
 5293              		.cfi_def_cfa_offset 8
 5294              		.cfi_offset 7, -8
 5295              		.cfi_offset 14, -4
 5296 0002 82B0     		sub	sp, sp, #8
 5297              		.cfi_def_cfa_offset 16
 5298 0004 00AF     		add	r7, sp, #0
 5299              		.cfi_def_cfa_register 7
 5300 0006 0200     		movs	r2, r0
 5301 0008 FB1D     		adds	r3, r7, #7
 5302 000a 1A70     		strb	r2, [r3]
1518:../drivers/fsl_clock.c ****     CLOCK_SetExternalRefClkConfig(oscsel);
 5303              		.loc 2 1518 5
 5304 000c FB1D     		adds	r3, r7, #7
 5305 000e 1B78     		ldrb	r3, [r3]
 5306 0010 1800     		movs	r0, r3
 5307 0012 FFF7FEFF 		bl	CLOCK_SetExternalRefClkConfig
1519:../drivers/fsl_clock.c **** 
1520:../drivers/fsl_clock.c ****     /* Set to FBE mode. */
1521:../drivers/fsl_clock.c ****     MCG->C1 =
1522:../drivers/fsl_clock.c ****         ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK)) | (MCG_C1_CLKS(kMCG_ClkOutSrcExternal)
 5308              		.loc 2 1522 14
 5309 0016 184B     		ldr	r3, .L354
 5310 0018 1B78     		ldrb	r3, [r3]
 5311 001a DBB2     		uxtb	r3, r3
 5312              		.loc 2 1522 19
 5313 001c 3B22     		movs	r2, #59
 5314 001e 1340     		ands	r3, r2
 5315 0020 DBB2     		uxtb	r3, r3
1521:../drivers/fsl_clock.c ****         ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK)) | (MCG_C1_CLKS(kMCG_ClkOutSrcExternal)
 5316              		.loc 2 1521 8
 5317 0022 1549     		ldr	r1, .L354
 5318              		.loc 2 1522 62
 5319 0024 8022     		movs	r2, #128
 5320 0026 5242     		rsbs	r2, r2, #0
 5321 0028 1343     		orrs	r3, r2
 5322 002a DBB2     		uxtb	r3, r3
1521:../drivers/fsl_clock.c ****         ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK)) | (MCG_C1_CLKS(kMCG_ClkOutSrcExternal)
 5323              		.loc 2 1521 13
 5324 002c 0B70     		strb	r3, [r1]
1523:../drivers/fsl_clock.c ****                                                                 | MCG_C1_IREFS(kMCG_FllSrcExternal)
1524:../drivers/fsl_clock.c **** 
1525:../drivers/fsl_clock.c ****     /* If use external crystal as clock source, wait for it stable. */
1526:../drivers/fsl_clock.c ****     {
1527:../drivers/fsl_clock.c ****         if (MCG->C2 & MCG_C2_EREFS_MASK)
 5325              		.loc 2 1527 16
 5326 002e 124B     		ldr	r3, .L354
 5327 0030 5B78     		ldrb	r3, [r3, #1]
 5328 0032 DBB2     		uxtb	r3, r3
 5329              		.loc 2 1527 21
 5330 0034 1A00     		movs	r2, r3
 5331 0036 0423     		movs	r3, #4
 5332 0038 1340     		ands	r3, r2
 5333              		.loc 2 1527 12
 5334 003a 07D0     		beq	.L353
1528:../drivers/fsl_clock.c ****         {
1529:../drivers/fsl_clock.c ****             while (!(MCG->S & MCG_S_OSCINIT0_MASK))
 5335              		.loc 2 1529 19
 5336 003c C046     		nop
 5337              	.L350:
 5338              		.loc 2 1529 25 discriminator 1
 5339 003e 0E4B     		ldr	r3, .L354
 5340 0040 9B79     		ldrb	r3, [r3, #6]
 5341 0042 DBB2     		uxtb	r3, r3
 5342              		.loc 2 1529 29 discriminator 1
 5343 0044 1A00     		movs	r2, r3
 5344 0046 0223     		movs	r3, #2
 5345 0048 1340     		ands	r3, r2
 5346              		.loc 2 1529 19 discriminator 1
 5347 004a F8D0     		beq	.L350
 5348              	.L353:
1530:../drivers/fsl_clock.c ****             {
1531:../drivers/fsl_clock.c ****             }
1532:../drivers/fsl_clock.c ****         }
1533:../drivers/fsl_clock.c ****     }
1534:../drivers/fsl_clock.c **** 
1535:../drivers/fsl_clock.c ****     /* Wait for MCG_S[CLKST] and MCG_S[IREFST]. */
1536:../drivers/fsl_clock.c ****     while ((MCG->S & (MCG_S_IREFST_MASK | MCG_S_CLKST_MASK)) !=
 5349              		.loc 2 1536 11
 5350 004c C046     		nop
 5351              	.L351:
 5352              		.loc 2 1536 16 discriminator 1
 5353 004e 0A4B     		ldr	r3, .L354
 5354 0050 9B79     		ldrb	r3, [r3, #6]
 5355 0052 DBB2     		uxtb	r3, r3
 5356              		.loc 2 1536 20 discriminator 1
 5357 0054 1A00     		movs	r2, r3
 5358 0056 1C23     		movs	r3, #28
 5359 0058 1340     		ands	r3, r2
 5360              		.loc 2 1536 11 discriminator 1
 5361 005a 082B     		cmp	r3, #8
 5362 005c F7D1     		bne	.L351
1537:../drivers/fsl_clock.c ****            (MCG_S_IREFST(kMCG_FllSrcExternal) | MCG_S_CLKST(kMCG_ClkOutStatExt)))
1538:../drivers/fsl_clock.c ****     {
1539:../drivers/fsl_clock.c ****     }
1540:../drivers/fsl_clock.c **** 
1541:../drivers/fsl_clock.c ****     /* In FBE now, start to enter BLPE. */
1542:../drivers/fsl_clock.c ****     MCG->C2 |= MCG_C2_LP_MASK;
 5363              		.loc 2 1542 13
 5364 005e 064B     		ldr	r3, .L354
 5365 0060 5B78     		ldrb	r3, [r3, #1]
 5366 0062 DBB2     		uxtb	r3, r3
 5367 0064 044A     		ldr	r2, .L354
 5368 0066 0221     		movs	r1, #2
 5369 0068 0B43     		orrs	r3, r1
 5370 006a DBB2     		uxtb	r3, r3
 5371 006c 5370     		strb	r3, [r2, #1]
1543:../drivers/fsl_clock.c **** 
1544:../drivers/fsl_clock.c ****     return kStatus_Success;
 5372              		.loc 2 1544 12
 5373 006e 0023     		movs	r3, #0
1545:../drivers/fsl_clock.c **** }
 5374              		.loc 2 1545 1
 5375 0070 1800     		movs	r0, r3
 5376 0072 BD46     		mov	sp, r7
 5377 0074 02B0     		add	sp, sp, #8
 5378              		@ sp needed
 5379 0076 80BD     		pop	{r7, pc}
 5380              	.L355:
 5381              		.align	2
 5382              	.L354:
 5383 0078 00400640 		.word	1074151424
 5384              		.cfi_endproc
 5385              	.LFE103:
 5387              		.section	.rodata.CLOCK_BootToPeeMode.str1.4,"aMS",%progbits,1
 5388              		.align	2
 5389              	.LC23:
 5390 0000 2E66736C 		.ascii	".fsl_clock.c:1549 : config\000"
 5390      5F636C6F 
 5390      636B2E63 
 5390      3A313534 
 5390      39203A20 
 5391              		.section	.text.CLOCK_BootToPeeMode,"ax",%progbits
 5392              		.align	1
 5393              		.global	CLOCK_BootToPeeMode
 5394              		.syntax unified
 5395              		.code	16
 5396              		.thumb_func
 5397              		.fpu softvfp
 5399              	CLOCK_BootToPeeMode:
 5400              	.LFB104:
1546:../drivers/fsl_clock.c **** 
1547:../drivers/fsl_clock.c **** status_t CLOCK_BootToPeeMode(mcg_oscsel_t oscsel, mcg_pll_clk_select_t pllcs, mcg_pll_config_t cons
1548:../drivers/fsl_clock.c **** {
 5401              		.loc 2 1548 1
 5402              		.cfi_startproc
 5403              		@ args = 0, pretend = 0, frame = 8
 5404              		@ frame_needed = 1, uses_anonymous_args = 0
 5405 0000 80B5     		push	{r7, lr}
 5406              		.cfi_def_cfa_offset 8
 5407              		.cfi_offset 7, -8
 5408              		.cfi_offset 14, -4
 5409 0002 82B0     		sub	sp, sp, #8
 5410              		.cfi_def_cfa_offset 16
 5411 0004 00AF     		add	r7, sp, #0
 5412              		.cfi_def_cfa_register 7
 5413 0006 3A60     		str	r2, [r7]
 5414 0008 FB1D     		adds	r3, r7, #7
 5415 000a 021C     		adds	r2, r0, #0
 5416 000c 1A70     		strb	r2, [r3]
 5417 000e BB1D     		adds	r3, r7, #6
 5418 0010 0A1C     		adds	r2, r1, #0
 5419 0012 1A70     		strb	r2, [r3]
1549:../drivers/fsl_clock.c ****     assert(config);
 5420              		.loc 2 1549 5
 5421 0014 3B68     		ldr	r3, [r7]
 5422 0016 002B     		cmp	r3, #0
 5423 0018 03D1     		bne	.L357
 5424              		.loc 2 1549 5 is_stmt 0 discriminator 1
 5425 001a 134B     		ldr	r3, .L360
 5426 001c 1800     		movs	r0, r3
 5427 001e FFF7FEFF 		bl	__assertion_failed
 5428              	.L357:
1550:../drivers/fsl_clock.c **** 
1551:../drivers/fsl_clock.c ****     CLOCK_SetExternalRefClkConfig(oscsel);
 5429              		.loc 2 1551 5 is_stmt 1
 5430 0022 FB1D     		adds	r3, r7, #7
 5431 0024 1B78     		ldrb	r3, [r3]
 5432 0026 1800     		movs	r0, r3
 5433 0028 FFF7FEFF 		bl	CLOCK_SetExternalRefClkConfig
1552:../drivers/fsl_clock.c **** 
1553:../drivers/fsl_clock.c ****     CLOCK_SetPbeMode(pllcs, config);
 5434              		.loc 2 1553 5
 5435 002c 3A68     		ldr	r2, [r7]
 5436 002e BB1D     		adds	r3, r7, #6
 5437 0030 1B78     		ldrb	r3, [r3]
 5438 0032 1100     		movs	r1, r2
 5439 0034 1800     		movs	r0, r3
 5440 0036 FFF7FEFF 		bl	CLOCK_SetPbeMode
1554:../drivers/fsl_clock.c **** 
1555:../drivers/fsl_clock.c ****     /* Change to use PLL output clock. */
1556:../drivers/fsl_clock.c ****     MCG->C1 = (MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcOut);
 5441              		.loc 2 1556 19
 5442 003a 0C4B     		ldr	r3, .L360+4
 5443 003c 1B78     		ldrb	r3, [r3]
 5444 003e DBB2     		uxtb	r3, r3
 5445              		.loc 2 1556 8
 5446 0040 0A4A     		ldr	r2, .L360+4
 5447              		.loc 2 1556 45
 5448 0042 3F21     		movs	r1, #63
 5449 0044 0B40     		ands	r3, r1
 5450 0046 DBB2     		uxtb	r3, r3
 5451              		.loc 2 1556 13
 5452 0048 1370     		strb	r3, [r2]
1557:../drivers/fsl_clock.c ****     while (MCG_S_CLKST_VAL != kMCG_ClkOutStatPll)
 5453              		.loc 2 1557 11
 5454 004a C046     		nop
 5455              	.L358:
 5456              		.loc 2 1557 12 discriminator 1
 5457 004c 074B     		ldr	r3, .L360+4
 5458 004e 9B79     		ldrb	r3, [r3, #6]
 5459 0050 DBB2     		uxtb	r3, r3
 5460 0052 9B08     		lsrs	r3, r3, #2
 5461 0054 0322     		movs	r2, #3
 5462 0056 1340     		ands	r3, r2
 5463              		.loc 2 1557 11 discriminator 1
 5464 0058 032B     		cmp	r3, #3
 5465 005a F7D1     		bne	.L358
1558:../drivers/fsl_clock.c ****     {
1559:../drivers/fsl_clock.c ****     }
1560:../drivers/fsl_clock.c **** 
1561:../drivers/fsl_clock.c ****     return kStatus_Success;
 5466              		.loc 2 1561 12
 5467 005c 0023     		movs	r3, #0
1562:../drivers/fsl_clock.c **** }
 5468              		.loc 2 1562 1
 5469 005e 1800     		movs	r0, r3
 5470 0060 BD46     		mov	sp, r7
 5471 0062 02B0     		add	sp, sp, #8
 5472              		@ sp needed
 5473 0064 80BD     		pop	{r7, pc}
 5474              	.L361:
 5475 0066 C046     		.align	2
 5476              	.L360:
 5477 0068 00000000 		.word	.LC23
 5478 006c 00400640 		.word	1074151424
 5479              		.cfi_endproc
 5480              	.LFE104:
 5482              		.section	.rodata.mcgModeMatrix,"a"
 5483              		.align	2
 5486              	mcgModeMatrix:
 5487 0000 00       		.byte	0
 5488 0001 01       		.byte	1
 5489 0002 01       		.byte	1
 5490 0003 03       		.byte	3
 5491 0004 04       		.byte	4
 5492 0005 04       		.byte	4
 5493 0006 04       		.byte	4
 5494 0007 04       		.byte	4
 5495 0008 00       		.byte	0
 5496 0009 01       		.byte	1
 5497 000a 02       		.byte	2
 5498 000b 03       		.byte	3
 5499 000c 04       		.byte	4
 5500 000d 04       		.byte	4
 5501 000e 04       		.byte	4
 5502 000f 04       		.byte	4
 5503 0010 01       		.byte	1
 5504 0011 01       		.byte	1
 5505 0012 02       		.byte	2
 5506 0013 01       		.byte	1
 5507 0014 01       		.byte	1
 5508 0015 01       		.byte	1
 5509 0016 01       		.byte	1
 5510 0017 01       		.byte	1
 5511 0018 00       		.byte	0
 5512 0019 01       		.byte	1
 5513 001a 01       		.byte	1
 5514 001b 03       		.byte	3
 5515 001c 04       		.byte	4
 5516 001d 04       		.byte	4
 5517 001e 04       		.byte	4
 5518 001f 04       		.byte	4
 5519 0020 00       		.byte	0
 5520 0021 01       		.byte	1
 5521 0022 01       		.byte	1
 5522 0023 03       		.byte	3
 5523 0024 04       		.byte	4
 5524 0025 05       		.byte	5
 5525 0026 06       		.byte	6
 5526 0027 06       		.byte	6
 5527 0028 04       		.byte	4
 5528 0029 04       		.byte	4
 5529 002a 04       		.byte	4
 5530 002b 04       		.byte	4
 5531 002c 04       		.byte	4
 5532 002d 05       		.byte	5
 5533 002e 06       		.byte	6
 5534 002f 06       		.byte	6
 5535 0030 04       		.byte	4
 5536 0031 04       		.byte	4
 5537 0032 04       		.byte	4
 5538 0033 04       		.byte	4
 5539 0034 04       		.byte	4
 5540 0035 05       		.byte	5
 5541 0036 06       		.byte	6
 5542 0037 07       		.byte	7
 5543 0038 06       		.byte	6
 5544 0039 06       		.byte	6
 5545 003a 06       		.byte	6
 5546 003b 06       		.byte	6
 5547 003c 06       		.byte	6
 5548 003d 06       		.byte	6
 5549 003e 06       		.byte	6
 5550 003f 06       		.byte	6
 5551              		.section	.text.CLOCK_SetMcgConfig,"ax",%progbits
 5552              		.align	1
 5553              		.global	CLOCK_SetMcgConfig
 5554              		.syntax unified
 5555              		.code	16
 5556              		.thumb_func
 5557              		.fpu softvfp
 5559              	CLOCK_SetMcgConfig:
 5560              	.LFB105:
1563:../drivers/fsl_clock.c **** 
1564:../drivers/fsl_clock.c **** /*
1565:../drivers/fsl_clock.c ****    The transaction matrix. It defines the path for mode switch, the row is for
1566:../drivers/fsl_clock.c ****    current mode and the column is target mode.
1567:../drivers/fsl_clock.c ****    For example, switch from FEI to PEE:
1568:../drivers/fsl_clock.c ****    1. Current mode FEI, next mode is mcgModeMatrix[FEI][PEE] = FBE, so swith to FBE.
1569:../drivers/fsl_clock.c ****    2. Current mode FBE, next mode is mcgModeMatrix[FBE][PEE] = PBE, so swith to PBE.
1570:../drivers/fsl_clock.c ****    3. Current mode PBE, next mode is mcgModeMatrix[PBE][PEE] = PEE, so swith to PEE.
1571:../drivers/fsl_clock.c ****    Thus the MCG mode has changed from FEI to PEE.
1572:../drivers/fsl_clock.c ****  */
1573:../drivers/fsl_clock.c **** static const mcg_mode_t mcgModeMatrix[8][8] = {
1574:../drivers/fsl_clock.c ****     {kMCG_ModeFEI, kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeFEE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeF
1575:../drivers/fsl_clock.c ****      kMCG_ModeFBE}, /* FEI */
1576:../drivers/fsl_clock.c ****     {kMCG_ModeFEI, kMCG_ModeFBI, kMCG_ModeBLPI, kMCG_ModeFEE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_Mode
1577:../drivers/fsl_clock.c ****      kMCG_ModeFBE}, /* FBI */
1578:../drivers/fsl_clock.c ****     {kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeBLPI, kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeFBI, kMCG_Mode
1579:../drivers/fsl_clock.c ****      kMCG_ModeFBI}, /* BLPI */
1580:../drivers/fsl_clock.c ****     {kMCG_ModeFEI, kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeFEE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeF
1581:../drivers/fsl_clock.c ****      kMCG_ModeFBE}, /* FEE */
1582:../drivers/fsl_clock.c ****     {kMCG_ModeFEI, kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeFEE, kMCG_ModeFBE, kMCG_ModeBLPE, kMCG_Mode
1583:../drivers/fsl_clock.c ****      kMCG_ModePBE}, /* FBE */
1584:../drivers/fsl_clock.c ****     {kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeBLPE, kMCG_Mode
1585:../drivers/fsl_clock.c ****      kMCG_ModePBE}, /* BLPE */
1586:../drivers/fsl_clock.c ****     {kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeBLPE, kMCG_Mode
1587:../drivers/fsl_clock.c ****      kMCG_ModePEE}, /* PBE */
1588:../drivers/fsl_clock.c ****     {kMCG_ModePBE, kMCG_ModePBE, kMCG_ModePBE, kMCG_ModePBE, kMCG_ModePBE, kMCG_ModePBE, kMCG_ModeP
1589:../drivers/fsl_clock.c ****      kMCG_ModePBE} /* PEE */
1590:../drivers/fsl_clock.c ****     /*    FEI           FBI           BLPI           FEE           FBE           BLPE           PBE
1591:../drivers/fsl_clock.c **** };
1592:../drivers/fsl_clock.c **** 
1593:../drivers/fsl_clock.c **** status_t CLOCK_SetMcgConfig(const mcg_config_t *config)
1594:../drivers/fsl_clock.c **** {
 5561              		.loc 2 1594 1
 5562              		.cfi_startproc
 5563              		@ args = 0, pretend = 0, frame = 24
 5564              		@ frame_needed = 1, uses_anonymous_args = 0
 5565 0000 90B5     		push	{r4, r7, lr}
 5566              		.cfi_def_cfa_offset 12
 5567              		.cfi_offset 4, -12
 5568              		.cfi_offset 7, -8
 5569              		.cfi_offset 14, -4
 5570 0002 87B0     		sub	sp, sp, #28
 5571              		.cfi_def_cfa_offset 40
 5572 0004 00AF     		add	r7, sp, #0
 5573              		.cfi_def_cfa_register 7
 5574 0006 7860     		str	r0, [r7, #4]
1595:../drivers/fsl_clock.c ****     mcg_mode_t next_mode;
1596:../drivers/fsl_clock.c ****     status_t status = kStatus_Success;
 5575              		.loc 2 1596 14
 5576 0008 0023     		movs	r3, #0
 5577 000a 3B61     		str	r3, [r7, #16]
1597:../drivers/fsl_clock.c **** 
1598:../drivers/fsl_clock.c ****     mcg_pll_clk_select_t pllcs = kMCG_PllClkSelPll0;
 5578              		.loc 2 1598 26
 5579 000c 0F23     		movs	r3, #15
 5580 000e FB18     		adds	r3, r7, r3
 5581 0010 0022     		movs	r2, #0
 5582 0012 1A70     		strb	r2, [r3]
1599:../drivers/fsl_clock.c **** 
1600:../drivers/fsl_clock.c ****     /* Re-configure MCGIRCLK, if MCGIRCLK is used as system clock source, then change to FEI/PEI fi
1601:../drivers/fsl_clock.c ****     if (MCG_S_CLKST_VAL == kMCG_ClkOutStatInt)
 5583              		.loc 2 1601 9
 5584 0014 654B     		ldr	r3, .L385
 5585 0016 9B79     		ldrb	r3, [r3, #6]
 5586 0018 DBB2     		uxtb	r3, r3
 5587 001a 9B08     		lsrs	r3, r3, #2
 5588 001c 0322     		movs	r2, #3
 5589 001e 1340     		ands	r3, r2
 5590              		.loc 2 1601 8
 5591 0020 012B     		cmp	r3, #1
 5592 0022 0FD1     		bne	.L363
1602:../drivers/fsl_clock.c ****     {
1603:../drivers/fsl_clock.c ****         MCG->C2 &= ~MCG_C2_LP_MASK; /* Disable lowpower. */
 5593              		.loc 2 1603 17
 5594 0024 614B     		ldr	r3, .L385
 5595 0026 5B78     		ldrb	r3, [r3, #1]
 5596 0028 DBB2     		uxtb	r3, r3
 5597 002a 604A     		ldr	r2, .L385
 5598 002c 0221     		movs	r1, #2
 5599 002e 8B43     		bics	r3, r1
 5600 0030 DBB2     		uxtb	r3, r3
 5601 0032 5370     		strb	r3, [r2, #1]
1604:../drivers/fsl_clock.c **** 
1605:../drivers/fsl_clock.c ****         {
1606:../drivers/fsl_clock.c ****             CLOCK_SetFeiMode(config->dmx32, config->drs, CLOCK_FllStableDelay);
 5602              		.loc 2 1606 13
 5603 0034 7B68     		ldr	r3, [r7, #4]
 5604 0036 9879     		ldrb	r0, [r3, #6]
 5605 0038 7B68     		ldr	r3, [r7, #4]
 5606 003a 5B79     		ldrb	r3, [r3, #5]
 5607 003c 5C4A     		ldr	r2, .L385+4
 5608 003e 1900     		movs	r1, r3
 5609 0040 FFF7FEFF 		bl	CLOCK_SetFeiMode
 5610              	.L363:
1607:../drivers/fsl_clock.c ****         }
1608:../drivers/fsl_clock.c ****     }
1609:../drivers/fsl_clock.c **** 
1610:../drivers/fsl_clock.c ****     /* Configure MCGIRCLK. */
1611:../drivers/fsl_clock.c ****     CLOCK_SetInternalRefClkConfig(config->irclkEnableMode, config->ircs, config->fcrdiv);
 5611              		.loc 2 1611 5
 5612 0044 7B68     		ldr	r3, [r7, #4]
 5613 0046 5878     		ldrb	r0, [r3, #1]
 5614 0048 7B68     		ldr	r3, [r7, #4]
 5615 004a 9978     		ldrb	r1, [r3, #2]
 5616 004c 7B68     		ldr	r3, [r7, #4]
 5617 004e DB78     		ldrb	r3, [r3, #3]
 5618 0050 1A00     		movs	r2, r3
 5619 0052 FFF7FEFF 		bl	CLOCK_SetInternalRefClkConfig
1612:../drivers/fsl_clock.c **** 
1613:../drivers/fsl_clock.c ****     next_mode = CLOCK_GetMode();
 5620              		.loc 2 1613 17
 5621 0056 1723     		movs	r3, #23
 5622 0058 FC18     		adds	r4, r7, r3
 5623 005a FFF7FEFF 		bl	CLOCK_GetMode
 5624 005e 0300     		movs	r3, r0
 5625 0060 2370     		strb	r3, [r4]
 5626              	.L381:
1614:../drivers/fsl_clock.c **** 
1615:../drivers/fsl_clock.c ****     do
1616:../drivers/fsl_clock.c ****     {
1617:../drivers/fsl_clock.c ****         next_mode = mcgModeMatrix[next_mode][config->mcgMode];
 5627              		.loc 2 1617 45
 5628 0062 1724     		movs	r4, #23
 5629 0064 3B19     		adds	r3, r7, r4
 5630 0066 1A78     		ldrb	r2, [r3]
 5631              		.loc 2 1617 52
 5632 0068 7B68     		ldr	r3, [r7, #4]
 5633 006a 1B78     		ldrb	r3, [r3]
 5634 006c 1800     		movs	r0, r3
 5635              		.loc 2 1617 19
 5636 006e 3B19     		adds	r3, r7, r4
 5637 0070 5049     		ldr	r1, .L385+8
 5638 0072 D200     		lsls	r2, r2, #3
 5639 0074 8A18     		adds	r2, r1, r2
 5640 0076 125C     		ldrb	r2, [r2, r0]
 5641 0078 1A70     		strb	r2, [r3]
1618:../drivers/fsl_clock.c **** 
1619:../drivers/fsl_clock.c ****         switch (next_mode)
 5642              		.loc 2 1619 9
 5643 007a 3B19     		adds	r3, r7, r4
 5644 007c 1B78     		ldrb	r3, [r3]
 5645 007e 072B     		cmp	r3, #7
 5646 0080 6CD8     		bhi	.L384
 5647 0082 9A00     		lsls	r2, r3, #2
 5648 0084 4C4B     		ldr	r3, .L385+12
 5649 0086 D318     		adds	r3, r2, r3
 5650 0088 1B68     		ldr	r3, [r3]
 5651 008a 9F46     		mov	pc, r3
 5652              		.section	.rodata.CLOCK_SetMcgConfig,"a",%progbits
 5653              		.align	2
 5654              	.L366:
 5655 0000 8C000000 		.word	.L373
 5656 0004 BA000000 		.word	.L372
 5657 0008 E8000000 		.word	.L371
 5658 000c A2000000 		.word	.L370
 5659 0010 D0000000 		.word	.L369
 5660 0014 F2000000 		.word	.L368
 5661 0018 FC000000 		.word	.L367
 5662 001c 52010000 		.word	.L365
 5663              		.section	.text.CLOCK_SetMcgConfig
 5664              	.L373:
1620:../drivers/fsl_clock.c ****         {
1621:../drivers/fsl_clock.c ****             case kMCG_ModeFEI:
1622:../drivers/fsl_clock.c ****                 status = CLOCK_SetFeiMode(config->dmx32, config->drs, CLOCK_FllStableDelay);
 5665              		.loc 2 1622 26
 5666 008c 7B68     		ldr	r3, [r7, #4]
 5667 008e 9879     		ldrb	r0, [r3, #6]
 5668 0090 7B68     		ldr	r3, [r7, #4]
 5669 0092 5B79     		ldrb	r3, [r3, #5]
 5670 0094 464A     		ldr	r2, .L385+4
 5671 0096 1900     		movs	r1, r3
 5672 0098 FFF7FEFF 		bl	CLOCK_SetFeiMode
 5673 009c 0300     		movs	r3, r0
 5674 009e 3B61     		str	r3, [r7, #16]
1623:../drivers/fsl_clock.c ****                 break;
 5675              		.loc 2 1623 17
 5676 00a0 5DE0     		b	.L374
 5677              	.L370:
1624:../drivers/fsl_clock.c ****             case kMCG_ModeFEE:
1625:../drivers/fsl_clock.c ****                 status = CLOCK_SetFeeMode(config->frdiv, config->dmx32, config->drs, CLOCK_FllStabl
 5678              		.loc 2 1625 26
 5679 00a2 7B68     		ldr	r3, [r7, #4]
 5680 00a4 1879     		ldrb	r0, [r3, #4]
 5681 00a6 7B68     		ldr	r3, [r7, #4]
 5682 00a8 9979     		ldrb	r1, [r3, #6]
 5683 00aa 7B68     		ldr	r3, [r7, #4]
 5684 00ac 5A79     		ldrb	r2, [r3, #5]
 5685 00ae 404B     		ldr	r3, .L385+4
 5686 00b0 FFF7FEFF 		bl	CLOCK_SetFeeMode
 5687 00b4 0300     		movs	r3, r0
 5688 00b6 3B61     		str	r3, [r7, #16]
1626:../drivers/fsl_clock.c ****                 break;
 5689              		.loc 2 1626 17
 5690 00b8 51E0     		b	.L374
 5691              	.L372:
1627:../drivers/fsl_clock.c ****             case kMCG_ModeFBI:
1628:../drivers/fsl_clock.c ****                 status = CLOCK_SetFbiMode(config->dmx32, config->drs, (void (*)(void))0);
 5692              		.loc 2 1628 26
 5693 00ba 7B68     		ldr	r3, [r7, #4]
 5694 00bc 9879     		ldrb	r0, [r3, #6]
 5695 00be 7B68     		ldr	r3, [r7, #4]
 5696 00c0 5B79     		ldrb	r3, [r3, #5]
 5697 00c2 0022     		movs	r2, #0
 5698 00c4 1900     		movs	r1, r3
 5699 00c6 FFF7FEFF 		bl	CLOCK_SetFbiMode
 5700 00ca 0300     		movs	r3, r0
 5701 00cc 3B61     		str	r3, [r7, #16]
1629:../drivers/fsl_clock.c ****                 break;
 5702              		.loc 2 1629 17
 5703 00ce 46E0     		b	.L374
 5704              	.L369:
1630:../drivers/fsl_clock.c ****             case kMCG_ModeFBE:
1631:../drivers/fsl_clock.c ****                 status = CLOCK_SetFbeMode(config->frdiv, config->dmx32, config->drs, (void (*)(void
 5705              		.loc 2 1631 26
 5706 00d0 7B68     		ldr	r3, [r7, #4]
 5707 00d2 1879     		ldrb	r0, [r3, #4]
 5708 00d4 7B68     		ldr	r3, [r7, #4]
 5709 00d6 9979     		ldrb	r1, [r3, #6]
 5710 00d8 7B68     		ldr	r3, [r7, #4]
 5711 00da 5A79     		ldrb	r2, [r3, #5]
 5712 00dc 0023     		movs	r3, #0
 5713 00de FFF7FEFF 		bl	CLOCK_SetFbeMode
 5714 00e2 0300     		movs	r3, r0
 5715 00e4 3B61     		str	r3, [r7, #16]
1632:../drivers/fsl_clock.c ****                 break;
 5716              		.loc 2 1632 17
 5717 00e6 3AE0     		b	.L374
 5718              	.L371:
1633:../drivers/fsl_clock.c ****             case kMCG_ModeBLPI:
1634:../drivers/fsl_clock.c ****                 status = CLOCK_SetBlpiMode();
 5719              		.loc 2 1634 26
 5720 00e8 FFF7FEFF 		bl	CLOCK_SetBlpiMode
 5721 00ec 0300     		movs	r3, r0
 5722 00ee 3B61     		str	r3, [r7, #16]
1635:../drivers/fsl_clock.c ****                 break;
 5723              		.loc 2 1635 17
 5724 00f0 35E0     		b	.L374
 5725              	.L368:
1636:../drivers/fsl_clock.c ****             case kMCG_ModeBLPE:
1637:../drivers/fsl_clock.c ****                 status = CLOCK_SetBlpeMode();
 5726              		.loc 2 1637 26
 5727 00f2 FFF7FEFF 		bl	CLOCK_SetBlpeMode
 5728 00f6 0300     		movs	r3, r0
 5729 00f8 3B61     		str	r3, [r7, #16]
1638:../drivers/fsl_clock.c ****                 break;
 5730              		.loc 2 1638 17
 5731 00fa 30E0     		b	.L374
 5732              	.L367:
1639:../drivers/fsl_clock.c ****             case kMCG_ModePBE:
1640:../drivers/fsl_clock.c ****                 /* If target mode is not PBE or PEE, then only need to set CLKS = EXT here. */
1641:../drivers/fsl_clock.c ****                 if ((kMCG_ModePEE == config->mcgMode) || (kMCG_ModePBE == config->mcgMode))
 5733              		.loc 2 1641 44
 5734 00fc 7B68     		ldr	r3, [r7, #4]
 5735 00fe 1B78     		ldrb	r3, [r3]
 5736              		.loc 2 1641 20
 5737 0100 072B     		cmp	r3, #7
 5738 0102 03D0     		beq	.L375
 5739              		.loc 2 1641 81 discriminator 1
 5740 0104 7B68     		ldr	r3, [r7, #4]
 5741 0106 1B78     		ldrb	r3, [r3]
 5742              		.loc 2 1641 55 discriminator 1
 5743 0108 062B     		cmp	r3, #6
 5744 010a 0CD1     		bne	.L376
 5745              	.L375:
1642:../drivers/fsl_clock.c ****                 {
1643:../drivers/fsl_clock.c ****                     {
1644:../drivers/fsl_clock.c ****                         status = CLOCK_SetPbeMode(pllcs, &config->pll0Config);
 5746              		.loc 2 1644 34
 5747 010c 7B68     		ldr	r3, [r7, #4]
 5748 010e DA1D     		adds	r2, r3, #7
 5749 0110 0F23     		movs	r3, #15
 5750 0112 FB18     		adds	r3, r7, r3
 5751 0114 1B78     		ldrb	r3, [r3]
 5752 0116 1100     		movs	r1, r2
 5753 0118 1800     		movs	r0, r3
 5754 011a FFF7FEFF 		bl	CLOCK_SetPbeMode
 5755 011e 0300     		movs	r3, r0
 5756 0120 3B61     		str	r3, [r7, #16]
 5757              		.loc 2 1644 32
 5758 0122 C046     		nop
1645:../drivers/fsl_clock.c ****                     }
1646:../drivers/fsl_clock.c ****                 }
1647:../drivers/fsl_clock.c ****                 else
1648:../drivers/fsl_clock.c ****                 {
1649:../drivers/fsl_clock.c ****                     MCG->C1 = ((MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcExternal))
1650:../drivers/fsl_clock.c ****                     while (MCG_S_CLKST_VAL != kMCG_ClkOutStatExt)
1651:../drivers/fsl_clock.c ****                     {
1652:../drivers/fsl_clock.c ****                     }
1653:../drivers/fsl_clock.c ****                 }
1654:../drivers/fsl_clock.c ****                 break;
 5759              		.loc 2 1654 17
 5760 0124 1BE0     		b	.L374
 5761              	.L376:
1649:../drivers/fsl_clock.c ****                     while (MCG_S_CLKST_VAL != kMCG_ClkOutStatExt)
 5762              		.loc 2 1649 36
 5763 0126 214B     		ldr	r3, .L385
 5764 0128 1B78     		ldrb	r3, [r3]
 5765 012a DBB2     		uxtb	r3, r3
1649:../drivers/fsl_clock.c ****                     while (MCG_S_CLKST_VAL != kMCG_ClkOutStatExt)
 5766              		.loc 2 1649 41
 5767 012c 3F22     		movs	r2, #63
 5768 012e 1340     		ands	r3, r2
 5769 0130 DBB2     		uxtb	r3, r3
1649:../drivers/fsl_clock.c ****                     while (MCG_S_CLKST_VAL != kMCG_ClkOutStatExt)
 5770              		.loc 2 1649 24
 5771 0132 1E49     		ldr	r1, .L385
1649:../drivers/fsl_clock.c ****                     while (MCG_S_CLKST_VAL != kMCG_ClkOutStatExt)
 5772              		.loc 2 1649 62
 5773 0134 8022     		movs	r2, #128
 5774 0136 5242     		rsbs	r2, r2, #0
 5775 0138 1343     		orrs	r3, r2
 5776 013a DBB2     		uxtb	r3, r3
1649:../drivers/fsl_clock.c ****                     while (MCG_S_CLKST_VAL != kMCG_ClkOutStatExt)
 5777              		.loc 2 1649 29
 5778 013c 0B70     		strb	r3, [r1]
1650:../drivers/fsl_clock.c ****                     {
 5779              		.loc 2 1650 27
 5780 013e C046     		nop
 5781              	.L378:
1650:../drivers/fsl_clock.c ****                     {
 5782              		.loc 2 1650 28 discriminator 1
 5783 0140 1A4B     		ldr	r3, .L385
 5784 0142 9B79     		ldrb	r3, [r3, #6]
 5785 0144 DBB2     		uxtb	r3, r3
 5786 0146 9B08     		lsrs	r3, r3, #2
 5787 0148 0322     		movs	r2, #3
 5788 014a 1340     		ands	r3, r2
1650:../drivers/fsl_clock.c ****                     {
 5789              		.loc 2 1650 27 discriminator 1
 5790 014c 022B     		cmp	r3, #2
 5791 014e F7D1     		bne	.L378
 5792              		.loc 2 1654 17
 5793 0150 05E0     		b	.L374
 5794              	.L365:
1655:../drivers/fsl_clock.c ****             case kMCG_ModePEE:
1656:../drivers/fsl_clock.c ****                 status = CLOCK_SetPeeMode();
 5795              		.loc 2 1656 26
 5796 0152 FFF7FEFF 		bl	CLOCK_SetPeeMode
 5797 0156 0300     		movs	r3, r0
 5798 0158 3B61     		str	r3, [r7, #16]
1657:../drivers/fsl_clock.c ****                 break;
 5799              		.loc 2 1657 17
 5800 015a 00E0     		b	.L374
 5801              	.L384:
1658:../drivers/fsl_clock.c ****             default:
1659:../drivers/fsl_clock.c ****                 break;
 5802              		.loc 2 1659 17
 5803 015c C046     		nop
 5804              	.L374:
1660:../drivers/fsl_clock.c ****         }
1661:../drivers/fsl_clock.c ****         if (kStatus_Success != status)
 5805              		.loc 2 1661 12
 5806 015e 3B69     		ldr	r3, [r7, #16]
 5807 0160 002B     		cmp	r3, #0
 5808 0162 01D0     		beq	.L379
1662:../drivers/fsl_clock.c ****         {
1663:../drivers/fsl_clock.c ****             return status;
 5809              		.loc 2 1663 20
 5810 0164 3B69     		ldr	r3, [r7, #16]
 5811 0166 1CE0     		b	.L380
 5812              	.L379:
1664:../drivers/fsl_clock.c ****         }
1665:../drivers/fsl_clock.c ****     } while (next_mode != config->mcgMode);
 5813              		.loc 2 1665 33
 5814 0168 7B68     		ldr	r3, [r7, #4]
 5815 016a 1B78     		ldrb	r3, [r3]
 5816              		.loc 2 1665 5
 5817 016c 1722     		movs	r2, #23
 5818 016e BA18     		adds	r2, r7, r2
 5819 0170 1278     		ldrb	r2, [r2]
 5820 0172 9A42     		cmp	r2, r3
 5821 0174 00D0     		beq	.LCB4796
 5822 0176 74E7     		b	.L381	@long jump
 5823              	.LCB4796:
1666:../drivers/fsl_clock.c **** 
1667:../drivers/fsl_clock.c ****     if (config->pll0Config.enableMode & kMCG_PllEnableIndependent)
 5824              		.loc 2 1667 27
 5825 0178 7B68     		ldr	r3, [r7, #4]
 5826 017a DB79     		ldrb	r3, [r3, #7]
 5827              		.loc 2 1667 39
 5828 017c 1A00     		movs	r2, r3
 5829 017e 4023     		movs	r3, #64
 5830 0180 1340     		ands	r3, r2
 5831              		.loc 2 1667 8
 5832 0182 05D0     		beq	.L382
1668:../drivers/fsl_clock.c ****     {
1669:../drivers/fsl_clock.c ****         CLOCK_EnablePll0(&config->pll0Config);
 5833              		.loc 2 1669 9
 5834 0184 7B68     		ldr	r3, [r7, #4]
 5835 0186 0733     		adds	r3, r3, #7
 5836 0188 1800     		movs	r0, r3
 5837 018a FFF7FEFF 		bl	CLOCK_EnablePll0
 5838 018e 07E0     		b	.L383
 5839              	.L382:
1670:../drivers/fsl_clock.c ****     }
1671:../drivers/fsl_clock.c ****     else
1672:../drivers/fsl_clock.c ****     {
1673:../drivers/fsl_clock.c ****         MCG->C5 &= ~(uint32_t)kMCG_PllEnableIndependent;
 5840              		.loc 2 1673 17
 5841 0190 064B     		ldr	r3, .L385
 5842 0192 1B79     		ldrb	r3, [r3, #4]
 5843 0194 DBB2     		uxtb	r3, r3
 5844 0196 054A     		ldr	r2, .L385
 5845 0198 4021     		movs	r1, #64
 5846 019a 8B43     		bics	r3, r1
 5847 019c DBB2     		uxtb	r3, r3
 5848 019e 1371     		strb	r3, [r2, #4]
 5849              	.L383:
1674:../drivers/fsl_clock.c ****     }
1675:../drivers/fsl_clock.c ****     return kStatus_Success;
 5850              		.loc 2 1675 12
 5851 01a0 0023     		movs	r3, #0
 5852              	.L380:
1676:../drivers/fsl_clock.c **** }
 5853              		.loc 2 1676 1
 5854 01a2 1800     		movs	r0, r3
 5855 01a4 BD46     		mov	sp, r7
 5856 01a6 07B0     		add	sp, sp, #28
 5857              		@ sp needed
 5858 01a8 90BD     		pop	{r4, r7, pc}
 5859              	.L386:
 5860 01aa C046     		.align	2
 5861              	.L385:
 5862 01ac 00400640 		.word	1074151424
 5863 01b0 00000000 		.word	CLOCK_FllStableDelay
 5864 01b4 00000000 		.word	mcgModeMatrix
 5865 01b8 00000000 		.word	.L366
 5866              		.cfi_endproc
 5867              	.LFE105:
 5869              		.section	.rodata.fllFactorTable.5210,"a"
 5870              		.align	2
 5873              	fllFactorTable.5210:
 5874 0000 8002     		.short	640
 5875 0002 DC02     		.short	732
 5876 0004 0005     		.short	1280
 5877 0006 B805     		.short	1464
 5878 0008 8007     		.short	1920
 5879 000a 9508     		.short	2197
 5880 000c 000A     		.short	2560
 5881 000e 710B     		.short	2929
 5882              		.section	.rodata.trimRange.5302,"a"
 5883              		.align	2
 5886              	trimRange.5302:
 5887 0000 127A0000 		.word	31250
 5888 0004 97980000 		.word	39063
 5889 0008 C0C62D00 		.word	3000000
 5890 000c 404B4C00 		.word	5000000
 5891              		.text
 5892              	.Letext0:
 5893              		.file 4 "/usr/local/mcuxpressoide-11.2.0_4120/ide/plugins/com.nxp.mcuxpresso.tools.linux_11.2.0.20
 5894              		.file 5 "/usr/local/mcuxpressoide-11.2.0_4120/ide/plugins/com.nxp.mcuxpresso.tools.linux_11.2.0.20
 5895              		.file 6 "/home/arpit/studies/pes/Blinkenlights/CMSIS/system_MKL25Z4.h"
 5896              		.file 7 "/home/arpit/studies/pes/Blinkenlights/CMSIS/MKL25Z4.h"
 5897              		.file 8 "../drivers/fsl_common.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 fsl_clock.c
     /tmp/cceLPfvH.s:16     .text.CLOCK_EnableClock:0000000000000000 $t
     /tmp/cceLPfvH.s:23     .text.CLOCK_EnableClock:0000000000000000 CLOCK_EnableClock
     /tmp/cceLPfvH.s:70     .text.CLOCK_EnableClock:0000000000000030 $d
     /tmp/cceLPfvH.s:75     .text.CLOCK_DisableClock:0000000000000000 $t
     /tmp/cceLPfvH.s:81     .text.CLOCK_DisableClock:0000000000000000 CLOCK_DisableClock
     /tmp/cceLPfvH.s:130    .text.CLOCK_DisableClock:0000000000000034 $d
     /tmp/cceLPfvH.s:135    .text.CLOCK_SetEr32kClock:0000000000000000 $t
     /tmp/cceLPfvH.s:141    .text.CLOCK_SetEr32kClock:0000000000000000 CLOCK_SetEr32kClock
     /tmp/cceLPfvH.s:184    .text.CLOCK_SetEr32kClock:000000000000002c $d
     /tmp/cceLPfvH.s:190    .text.CLOCK_SetPllFllSelClock:0000000000000000 $t
     /tmp/cceLPfvH.s:196    .text.CLOCK_SetPllFllSelClock:0000000000000000 CLOCK_SetPllFllSelClock
     /tmp/cceLPfvH.s:240    .text.CLOCK_SetPllFllSelClock:000000000000002c $d
     /tmp/cceLPfvH.s:247    .text.OSC_SetExtRefClkConfig:0000000000000000 $t
     /tmp/cceLPfvH.s:253    .text.OSC_SetExtRefClkConfig:0000000000000000 OSC_SetExtRefClkConfig
     /tmp/cceLPfvH.s:306    .text.OSC_SetCapLoad:0000000000000000 $t
     /tmp/cceLPfvH.s:312    .text.OSC_SetCapLoad:0000000000000000 OSC_SetCapLoad
     /tmp/cceLPfvH.s:366    .data.s_slowIrcFreq:0000000000000000 $d
     /tmp/cceLPfvH.s:369    .data.s_slowIrcFreq:0000000000000000 s_slowIrcFreq
     /tmp/cceLPfvH.s:372    .data.s_fastIrcFreq:0000000000000000 $d
     /tmp/cceLPfvH.s:375    .data.s_fastIrcFreq:0000000000000000 s_fastIrcFreq
     /tmp/cceLPfvH.s:382    .bss.g_xtal0Freq:0000000000000000 g_xtal0Freq
     /tmp/cceLPfvH.s:379    .bss.g_xtal0Freq:0000000000000000 $d
     /tmp/cceLPfvH.s:389    .bss.g_xtal32Freq:0000000000000000 g_xtal32Freq
     /tmp/cceLPfvH.s:386    .bss.g_xtal32Freq:0000000000000000 $d
     /tmp/cceLPfvH.s:392    .text.CLOCK_FllStableDelay:0000000000000000 $t
     /tmp/cceLPfvH.s:399    .text.CLOCK_FllStableDelay:0000000000000000 CLOCK_FllStableDelay
     /tmp/cceLPfvH.s:452    .text.CLOCK_FllStableDelay:0000000000000024 $d
     /tmp/cceLPfvH.s:457    .rodata.CLOCK_GetMcgExtClkFreq.str1.4:0000000000000000 $d
     /tmp/cceLPfvH.s:461    .text.CLOCK_GetMcgExtClkFreq:0000000000000000 $t
     /tmp/cceLPfvH.s:467    .text.CLOCK_GetMcgExtClkFreq:0000000000000000 CLOCK_GetMcgExtClkFreq
     /tmp/cceLPfvH.s:500    .text.CLOCK_GetMcgExtClkFreq:0000000000000020 $d
     /tmp/cceLPfvH.s:507    .text.CLOCK_GetFllExtRefClkFreq:0000000000000000 $t
     /tmp/cceLPfvH.s:513    .text.CLOCK_GetFllExtRefClkFreq:0000000000000000 CLOCK_GetFllExtRefClkFreq
     /tmp/cceLPfvH.s:639    .text.CLOCK_GetFllExtRefClkFreq:00000000000000a4 $d
     /tmp/cceLPfvH.s:644    .text.CLOCK_GetInternalRefClkSelectFreq:0000000000000000 $t
     /tmp/cceLPfvH.s:650    .text.CLOCK_GetInternalRefClkSelectFreq:0000000000000000 CLOCK_GetInternalRefClkSelectFreq
     /tmp/cceLPfvH.s:698    .text.CLOCK_GetInternalRefClkSelectFreq:0000000000000034 $d
     /tmp/cceLPfvH.s:705    .text.CLOCK_GetFllRefClkFreq:0000000000000000 $t
     /tmp/cceLPfvH.s:711    .text.CLOCK_GetFllRefClkFreq:0000000000000000 CLOCK_GetFllRefClkFreq
     /tmp/cceLPfvH.s:750    .text.CLOCK_GetFllRefClkFreq:0000000000000024 $d
     /tmp/cceLPfvH.s:756    .text.CLOCK_GetPll0RefFreq:0000000000000000 $t
     /tmp/cceLPfvH.s:762    .text.CLOCK_GetPll0RefFreq:0000000000000000 CLOCK_GetPll0RefFreq
     /tmp/cceLPfvH.s:786    .text.CLOCK_GetOscRangeFromFreq:0000000000000000 $t
     /tmp/cceLPfvH.s:792    .text.CLOCK_GetOscRangeFromFreq:0000000000000000 CLOCK_GetOscRangeFromFreq
     /tmp/cceLPfvH.s:850    .text.CLOCK_GetOscRangeFromFreq:0000000000000044 $d
     /tmp/cceLPfvH.s:856    .rodata.CLOCK_GetOsc0ErClkFreq.str1.4:0000000000000000 $d
     /tmp/cceLPfvH.s:860    .text.CLOCK_GetOsc0ErClkFreq:0000000000000000 $t
     /tmp/cceLPfvH.s:867    .text.CLOCK_GetOsc0ErClkFreq:0000000000000000 CLOCK_GetOsc0ErClkFreq
     /tmp/cceLPfvH.s:914    .text.CLOCK_GetOsc0ErClkFreq:0000000000000030 $d
     /tmp/cceLPfvH.s:921    .rodata.CLOCK_GetEr32kClkFreq.str1.4:0000000000000000 $d
     /tmp/cceLPfvH.s:925    .text.CLOCK_GetEr32kClkFreq:0000000000000000 $t
     /tmp/cceLPfvH.s:932    .text.CLOCK_GetEr32kClkFreq:0000000000000000 CLOCK_GetEr32kClkFreq
     /tmp/cceLPfvH.s:1024   .text.CLOCK_GetEr32kClkFreq:000000000000006c $d
     /tmp/cceLPfvH.s:1031   .text.CLOCK_GetPllFllSelClkFreq:0000000000000000 $t
     /tmp/cceLPfvH.s:1038   .text.CLOCK_GetPllFllSelClkFreq:0000000000000000 CLOCK_GetPllFllSelClkFreq
     /tmp/cceLPfvH.s:1801   .text.CLOCK_GetFllFreq:0000000000000000 CLOCK_GetFllFreq
     /tmp/cceLPfvH.s:2020   .text.CLOCK_GetPll0Freq:0000000000000000 CLOCK_GetPll0Freq
     /tmp/cceLPfvH.s:1100   .text.CLOCK_GetPllFllSelClkFreq:0000000000000044 $d
     /tmp/cceLPfvH.s:1106   .text.CLOCK_GetPlatClkFreq:0000000000000000 $t
     /tmp/cceLPfvH.s:1113   .text.CLOCK_GetPlatClkFreq:0000000000000000 CLOCK_GetPlatClkFreq
     /tmp/cceLPfvH.s:1700   .text.CLOCK_GetOutClkFreq:0000000000000000 CLOCK_GetOutClkFreq
     /tmp/cceLPfvH.s:1149   .text.CLOCK_GetPlatClkFreq:0000000000000024 $d
     /tmp/cceLPfvH.s:1155   .text.CLOCK_GetFlashClkFreq:0000000000000000 $t
     /tmp/cceLPfvH.s:1162   .text.CLOCK_GetFlashClkFreq:0000000000000000 CLOCK_GetFlashClkFreq
     /tmp/cceLPfvH.s:1220   .text.CLOCK_GetFlashClkFreq:0000000000000048 $d
     /tmp/cceLPfvH.s:1226   .text.CLOCK_GetBusClkFreq:0000000000000000 $t
     /tmp/cceLPfvH.s:1233   .text.CLOCK_GetBusClkFreq:0000000000000000 CLOCK_GetBusClkFreq
     /tmp/cceLPfvH.s:1291   .text.CLOCK_GetBusClkFreq:0000000000000048 $d
     /tmp/cceLPfvH.s:1297   .text.CLOCK_GetCoreSysClkFreq:0000000000000000 $t
     /tmp/cceLPfvH.s:1304   .text.CLOCK_GetCoreSysClkFreq:0000000000000000 CLOCK_GetCoreSysClkFreq
     /tmp/cceLPfvH.s:1340   .text.CLOCK_GetCoreSysClkFreq:0000000000000024 $d
     /tmp/cceLPfvH.s:1346   .text.CLOCK_GetFreq:0000000000000000 $t
     /tmp/cceLPfvH.s:1353   .text.CLOCK_GetFreq:0000000000000000 CLOCK_GetFreq
     /tmp/cceLPfvH.s:1381   .rodata.CLOCK_GetFreq:0000000000000000 $d
     /tmp/cceLPfvH.s:1961   .text.CLOCK_GetFixedFreqClkFreq:0000000000000000 CLOCK_GetFixedFreqClkFreq
     /tmp/cceLPfvH.s:1911   .text.CLOCK_GetInternalRefClkFreq:0000000000000000 CLOCK_GetInternalRefClkFreq
     /tmp/cceLPfvH.s:1528   .text.CLOCK_GetFreq:00000000000000d4 $d
     /tmp/cceLPfvH.s:1535   .text.CLOCK_SetSimConfig:0000000000000000 $t
     /tmp/cceLPfvH.s:1542   .text.CLOCK_SetSimConfig:0000000000000000 CLOCK_SetSimConfig
     /tmp/cceLPfvH.s:1586   .text.CLOCK_SetSimConfig:0000000000000030 $d
     /tmp/cceLPfvH.s:1592   .text.CLOCK_EnableUsbfs0Clock:0000000000000000 $t
     /tmp/cceLPfvH.s:1599   .text.CLOCK_EnableUsbfs0Clock:0000000000000000 CLOCK_EnableUsbfs0Clock
     /tmp/cceLPfvH.s:1683   .text.CLOCK_EnableUsbfs0Clock:000000000000006c $d
     /tmp/cceLPfvH.s:1693   .text.CLOCK_GetOutClkFreq:0000000000000000 $t
     /tmp/cceLPfvH.s:1789   .text.CLOCK_GetOutClkFreq:0000000000000074 $d
     /tmp/cceLPfvH.s:1794   .text.CLOCK_GetFllFreq:0000000000000000 $t
     /tmp/cceLPfvH.s:1898   .text.CLOCK_GetFllFreq:000000000000007c $d
     /tmp/cceLPfvH.s:5873   .rodata.fllFactorTable.5210:0000000000000000 fllFactorTable.5210
     /tmp/cceLPfvH.s:1904   .text.CLOCK_GetInternalRefClkFreq:0000000000000000 $t
     /tmp/cceLPfvH.s:1949   .text.CLOCK_GetInternalRefClkFreq:0000000000000024 $d
     /tmp/cceLPfvH.s:1954   .text.CLOCK_GetFixedFreqClkFreq:0000000000000000 $t
     /tmp/cceLPfvH.s:2009   .rodata.CLOCK_GetPll0Freq.str1.4:0000000000000000 $d
     /tmp/cceLPfvH.s:2013   .text.CLOCK_GetPll0Freq:0000000000000000 $t
     /tmp/cceLPfvH.s:2103   .text.CLOCK_GetPll0Freq:0000000000000068 $d
     /tmp/cceLPfvH.s:2109   .text.CLOCK_SetExternalRefClkConfig:0000000000000000 $t
     /tmp/cceLPfvH.s:2116   .text.CLOCK_SetExternalRefClkConfig:0000000000000000 CLOCK_SetExternalRefClkConfig
     /tmp/cceLPfvH.s:2145   .text.CLOCK_SetInternalRefClkConfig:0000000000000000 $t
     /tmp/cceLPfvH.s:2152   .text.CLOCK_SetInternalRefClkConfig:0000000000000000 CLOCK_SetInternalRefClkConfig
     /tmp/cceLPfvH.s:2364   .text.CLOCK_SetInternalRefClkConfig:0000000000000120 $d
     /tmp/cceLPfvH.s:2369   .text.CLOCK_CalcPllDiv:0000000000000000 $t
     /tmp/cceLPfvH.s:2376   .text.CLOCK_CalcPllDiv:0000000000000000 CLOCK_CalcPllDiv
     /tmp/cceLPfvH.s:2669   .text.CLOCK_CalcPllDiv:00000000000001ac $d
     /tmp/cceLPfvH.s:2678   .rodata.CLOCK_EnablePll0.str1.4:0000000000000000 $d
     /tmp/cceLPfvH.s:2682   .text.CLOCK_EnablePll0:0000000000000000 $t
     /tmp/cceLPfvH.s:2689   .text.CLOCK_EnablePll0:0000000000000000 CLOCK_EnablePll0
     /tmp/cceLPfvH.s:2795   .text.CLOCK_EnablePll0:000000000000008c $d
     /tmp/cceLPfvH.s:2801   .text.CLOCK_SetOsc0MonitorMode:0000000000000000 $t
     /tmp/cceLPfvH.s:2808   .text.CLOCK_SetOsc0MonitorMode:0000000000000000 CLOCK_SetOsc0MonitorMode
     /tmp/cceLPfvH.s:2897   .text.CLOCK_SetOsc0MonitorMode:000000000000007c $d
     /tmp/cceLPfvH.s:2902   .text.CLOCK_SetPll0MonitorMode:0000000000000000 $t
     /tmp/cceLPfvH.s:2909   .text.CLOCK_SetPll0MonitorMode:0000000000000000 CLOCK_SetPll0MonitorMode
     /tmp/cceLPfvH.s:3005   .text.CLOCK_SetPll0MonitorMode:0000000000000080 $d
     /tmp/cceLPfvH.s:3010   .text.CLOCK_GetStatusFlags:0000000000000000 $t
     /tmp/cceLPfvH.s:3017   .text.CLOCK_GetStatusFlags:0000000000000000 CLOCK_GetStatusFlags
     /tmp/cceLPfvH.s:3106   .text.CLOCK_GetStatusFlags:0000000000000068 $d
     /tmp/cceLPfvH.s:3111   .text.CLOCK_ClearStatusFlags:0000000000000000 $t
     /tmp/cceLPfvH.s:3118   .text.CLOCK_ClearStatusFlags:0000000000000000 CLOCK_ClearStatusFlags
     /tmp/cceLPfvH.s:3170   .text.CLOCK_ClearStatusFlags:0000000000000038 $d
     /tmp/cceLPfvH.s:3175   .text.CLOCK_InitOsc0:0000000000000000 $t
     /tmp/cceLPfvH.s:3182   .text.CLOCK_InitOsc0:0000000000000000 CLOCK_InitOsc0
     /tmp/cceLPfvH.s:3288   .text.CLOCK_InitOsc0:000000000000008c $d
     /tmp/cceLPfvH.s:3294   .text.CLOCK_DeinitOsc0:0000000000000000 $t
     /tmp/cceLPfvH.s:3301   .text.CLOCK_DeinitOsc0:0000000000000000 CLOCK_DeinitOsc0
     /tmp/cceLPfvH.s:3335   .text.CLOCK_DeinitOsc0:0000000000000020 $d
     /tmp/cceLPfvH.s:3341   .text.CLOCK_TrimInternalRefClk:0000000000000000 $t
     /tmp/cceLPfvH.s:3348   .text.CLOCK_TrimInternalRefClk:0000000000000000 CLOCK_TrimInternalRefClk
     /tmp/cceLPfvH.s:3582   .text.CLOCK_TrimInternalRefClk:0000000000000140 $d
     /tmp/cceLPfvH.s:5886   .rodata.trimRange.5302:0000000000000000 trimRange.5302
     /tmp/cceLPfvH.s:3596   .text.CLOCK_GetMode:0000000000000000 $t
     /tmp/cceLPfvH.s:3603   .text.CLOCK_GetMode:0000000000000000 CLOCK_GetMode
     /tmp/cceLPfvH.s:3776   .text.CLOCK_GetMode:00000000000000e4 $d
     /tmp/cceLPfvH.s:3781   .text.CLOCK_SetFeiMode:0000000000000000 $t
     /tmp/cceLPfvH.s:3788   .text.CLOCK_SetFeiMode:0000000000000000 CLOCK_SetFeiMode
     /tmp/cceLPfvH.s:3950   .text.CLOCK_SetFeiMode:00000000000000d8 $d
     /tmp/cceLPfvH.s:3955   .text.CLOCK_SetFeeMode:0000000000000000 $t
     /tmp/cceLPfvH.s:3962   .text.CLOCK_SetFeeMode:0000000000000000 CLOCK_SetFeeMode
     /tmp/cceLPfvH.s:4179   .text.CLOCK_SetFeeMode:0000000000000128 $d
     /tmp/cceLPfvH.s:4184   .text.CLOCK_SetFbiMode:0000000000000000 $t
     /tmp/cceLPfvH.s:4191   .text.CLOCK_SetFbiMode:0000000000000000 CLOCK_SetFbiMode
     /tmp/cceLPfvH.s:4363   .text.CLOCK_SetFbiMode:00000000000000ec $d
     /tmp/cceLPfvH.s:4368   .text.CLOCK_SetFbeMode:0000000000000000 $t
     /tmp/cceLPfvH.s:4375   .text.CLOCK_SetFbeMode:0000000000000000 CLOCK_SetFbeMode
     /tmp/cceLPfvH.s:4610   .text.CLOCK_SetFbeMode:0000000000000148 $d
     /tmp/cceLPfvH.s:4615   .text.CLOCK_SetBlpiMode:0000000000000000 $t
     /tmp/cceLPfvH.s:4622   .text.CLOCK_SetBlpiMode:0000000000000000 CLOCK_SetBlpiMode
     /tmp/cceLPfvH.s:4653   .text.CLOCK_SetBlpiMode:000000000000001c $d
     /tmp/cceLPfvH.s:4658   .text.CLOCK_SetBlpeMode:0000000000000000 $t
     /tmp/cceLPfvH.s:4665   .text.CLOCK_SetBlpeMode:0000000000000000 CLOCK_SetBlpeMode
     /tmp/cceLPfvH.s:4696   .text.CLOCK_SetBlpeMode:000000000000001c $d
     /tmp/cceLPfvH.s:4701   .rodata.CLOCK_SetPbeMode.str1.4:0000000000000000 $d
     /tmp/cceLPfvH.s:4705   .text.CLOCK_SetPbeMode:0000000000000000 $t
     /tmp/cceLPfvH.s:4712   .text.CLOCK_SetPbeMode:0000000000000000 CLOCK_SetPbeMode
     /tmp/cceLPfvH.s:4838   .text.CLOCK_SetPbeMode:00000000000000a8 $d
     /tmp/cceLPfvH.s:4844   .text.CLOCK_SetPeeMode:0000000000000000 $t
     /tmp/cceLPfvH.s:4851   .text.CLOCK_SetPeeMode:0000000000000000 CLOCK_SetPeeMode
     /tmp/cceLPfvH.s:4898   .text.CLOCK_SetPeeMode:0000000000000030 $d
     /tmp/cceLPfvH.s:4903   .text.CLOCK_ExternalModeToFbeModeQuick:0000000000000000 $t
     /tmp/cceLPfvH.s:4910   .text.CLOCK_ExternalModeToFbeModeQuick:0000000000000000 CLOCK_ExternalModeToFbeModeQuick
     /tmp/cceLPfvH.s:4993   .text.CLOCK_ExternalModeToFbeModeQuick:0000000000000068 $d
     /tmp/cceLPfvH.s:4998   .text.CLOCK_InternalModeToFbiModeQuick:0000000000000000 $t
     /tmp/cceLPfvH.s:5005   .text.CLOCK_InternalModeToFbiModeQuick:0000000000000000 CLOCK_InternalModeToFbiModeQuick
     /tmp/cceLPfvH.s:5065   .text.CLOCK_InternalModeToFbiModeQuick:0000000000000044 $d
     /tmp/cceLPfvH.s:5070   .text.CLOCK_BootToFeiMode:0000000000000000 $t
     /tmp/cceLPfvH.s:5077   .text.CLOCK_BootToFeiMode:0000000000000000 CLOCK_BootToFeiMode
     /tmp/cceLPfvH.s:5117   .text.CLOCK_BootToFeeMode:0000000000000000 $t
     /tmp/cceLPfvH.s:5124   .text.CLOCK_BootToFeeMode:0000000000000000 CLOCK_BootToFeeMode
     /tmp/cceLPfvH.s:5182   .text.CLOCK_BootToBlpiMode:0000000000000000 $t
     /tmp/cceLPfvH.s:5189   .text.CLOCK_BootToBlpiMode:0000000000000000 CLOCK_BootToBlpiMode
     /tmp/cceLPfvH.s:5274   .text.CLOCK_BootToBlpiMode:0000000000000074 $d
     /tmp/cceLPfvH.s:5279   .text.CLOCK_BootToBlpeMode:0000000000000000 $t
     /tmp/cceLPfvH.s:5286   .text.CLOCK_BootToBlpeMode:0000000000000000 CLOCK_BootToBlpeMode
     /tmp/cceLPfvH.s:5383   .text.CLOCK_BootToBlpeMode:0000000000000078 $d
     /tmp/cceLPfvH.s:5388   .rodata.CLOCK_BootToPeeMode.str1.4:0000000000000000 $d
     /tmp/cceLPfvH.s:5392   .text.CLOCK_BootToPeeMode:0000000000000000 $t
     /tmp/cceLPfvH.s:5399   .text.CLOCK_BootToPeeMode:0000000000000000 CLOCK_BootToPeeMode
     /tmp/cceLPfvH.s:5477   .text.CLOCK_BootToPeeMode:0000000000000068 $d
     /tmp/cceLPfvH.s:5483   .rodata.mcgModeMatrix:0000000000000000 $d
     /tmp/cceLPfvH.s:5486   .rodata.mcgModeMatrix:0000000000000000 mcgModeMatrix
     /tmp/cceLPfvH.s:5552   .text.CLOCK_SetMcgConfig:0000000000000000 $t
     /tmp/cceLPfvH.s:5559   .text.CLOCK_SetMcgConfig:0000000000000000 CLOCK_SetMcgConfig
     /tmp/cceLPfvH.s:5653   .rodata.CLOCK_SetMcgConfig:0000000000000000 $d
     /tmp/cceLPfvH.s:5862   .text.CLOCK_SetMcgConfig:00000000000001ac $d
     /tmp/cceLPfvH.s:5870   .rodata.fllFactorTable.5210:0000000000000000 $d
     /tmp/cceLPfvH.s:5883   .rodata.trimRange.5302:0000000000000000 $d
                           .group:0000000000000000 wm4.0.b17fa403cb9718989e7a4b461e73e1c9
                           .group:0000000000000000 wm4.redlib_version.h.16.f905717e4b3a91dcbdbb631865150df4
                           .group:0000000000000000 wm4.assert.h.25.5fa7b1099c5f353f7f0154f84a745cec
                           .group:0000000000000000 wm4.stdbool.h.15.fddf1cb2402fd739d8e2516677869231
                           .group:0000000000000000 wm4.libconfigarm.h.19.34723c94cbd19598192aa6b1e87fca41
                           .group:0000000000000000 wm4.stdint.h.31.58198de4ea930fb897655479091e17c7
                           .group:0000000000000000 wm4.fsl_device_registers.h.32.0bd0fc1949c4d5ee8778d13f693b6d67
                           .group:0000000000000000 wm4.MKL25Z4.h.103.6fa60f7365436a291410ac7ae38d8851
                           .group:0000000000000000 wm4.core_cm0plus.h.42.7e68c73109133db28e6113a0ee252d6f
                           .group:0000000000000000 wm4.cmsis_gcc.h.36.5bb14fd68ce7855540fcfe2d9305ae16
                           .group:0000000000000000 wm4.core_cm0plus.h.175.8e2cbb335a2ae70828db295817e11b6e
                           .group:0000000000000000 wm4.system_MKL25Z4.h.107.b43986f939b1bf0ee0f9aa04879788f4
                           .group:0000000000000000 wm4.MKL25Z4.h.379.376a3f36380a1b2f1e4cdc95287bb342
                           .group:0000000000000000 wm4.MKL25Z4_features.h.84.30fd6c6f11c9d2ffea2189829de10275
                           .group:0000000000000000 wm4.fsl_common.h.55.f0a989f874fed9062f996a5c92215a0e
                           .group:0000000000000000 wm4.fsl_common.h.162.37daaf5dee6e1f72e10ac988afa1643d
                           .group:0000000000000000 wm4.fsl_clock.h.61.86ace3515ab77fa85db71e2d42e7d189

UNDEFINED SYMBOLS
__assertion_failed
__aeabi_uidiv
