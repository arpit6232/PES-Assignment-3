   1              		.cpu cortex-m0plus
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 6
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"fsl_uart.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.NVIC_EnableIRQ,"ax",%progbits
  16              		.align	1
  17              		.arch armv6s-m
  18              		.syntax unified
  19              		.code	16
  20              		.thumb_func
  21              		.fpu softvfp
  23              	NVIC_EnableIRQ:
  24              	.LFB25:
  25              		.file 1 "/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h"
   1:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**************************************************************************//**
   2:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  * @file     core_cm0plus.h
   3:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  * @brief    CMSIS Cortex-M0+ Core Peripheral Access Layer Header File
   4:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  * @version  V4.30
   5:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  * @date     20. October 2015
   6:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  ******************************************************************************/
   7:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* Copyright (c) 2009 - 2015 ARM LIMITED
   8:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
   9:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    All rights reserved.
  10:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    Redistribution and use in source and binary forms, with or without
  11:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    modification, are permitted provided that the following conditions are met:
  12:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    - Redistributions of source code must retain the above copyright
  13:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****      notice, this list of conditions and the following disclaimer.
  14:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    - Redistributions in binary form must reproduce the above copyright
  15:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****      notice, this list of conditions and the following disclaimer in the
  16:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****      documentation and/or other materials provided with the distribution.
  17:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    - Neither the name of ARM nor the names of its contributors may be used
  18:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****      to endorse or promote products derived from this software without
  19:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****      specific prior written permission.
  20:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    *
  21:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  25:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    POSSIBILITY OF SUCH DAMAGE.
  32:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    ---------------------------------------------------------------------------*/
  33:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  34:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  35:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #if   defined ( __ICCARM__ )
  36:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  #pragma system_include         /* treat file as system include file for MISRA check */
  37:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  38:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #pragma clang system_header   /* treat file as system include file */
  39:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #endif
  40:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  41:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #ifndef __CORE_CM0PLUS_H_GENERIC
  42:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define __CORE_CM0PLUS_H_GENERIC
  43:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  44:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #include <stdint.h>
  45:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  46:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #ifdef __cplusplus
  47:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  extern "C" {
  48:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #endif
  49:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  50:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
  51:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  52:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   CMSIS violates the following MISRA-C:2004 rules:
  53:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  54:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  55:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****      Function definitions in header files are used to allow 'inlining'.
  56:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  57:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  58:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****      Unions are used for effective representation of core registers.
  59:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  60:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  61:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****      Function-like macros are used to allow more efficient code.
  62:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
  63:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  64:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  65:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /*******************************************************************************
  66:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  *                 CMSIS definitions
  67:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  ******************************************************************************/
  68:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
  69:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \ingroup Cortex-M0+
  70:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   @{
  71:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
  72:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  73:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /*  CMSIS CM0+ definitions */
  74:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION_MAIN (0x04U)                                   /*!< [31:16] CMSIS H
  75:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION_SUB  (0x1EU)                                   /*!< [15:0]  CMSIS H
  76:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) | \
  77:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****                                        __CM0PLUS_CMSIS_VERSION_SUB           ) /*!< CMSIS HAL versi
  78:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  79:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define __CORTEX_M                (0x00U)                                      /*!< Cortex-M Core *
  80:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  81:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  82:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #if   defined ( __CC_ARM )
  83:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __ASM            __asm                                      /*!< asm keyword for ARM Comp
  84:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __INLINE         __inline                                   /*!< inline keyword for ARM C
  85:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __STATIC_INLINE  static __inline
  86:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  87:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  88:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __ASM            __asm                                      /*!< asm keyword for ARM Comp
  89:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __INLINE         __inline                                   /*!< inline keyword for ARM C
  90:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __STATIC_INLINE  static __inline
  91:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  92:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #elif defined ( __GNUC__ )
  93:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __ASM            __asm                                      /*!< asm keyword for GNU Comp
  94:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __INLINE         inline                                     /*!< inline keyword for GNU C
  95:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __STATIC_INLINE  static inline
  96:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
  97:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #elif defined ( __ICCARM__ )
  98:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __ASM            __asm                                      /*!< asm keyword for IAR Comp
  99:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __INLINE         inline                                     /*!< inline keyword for IAR C
 100:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __STATIC_INLINE  static inline
 101:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 102:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #elif defined ( __TMS470__ )
 103:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __ASM            __asm                                      /*!< asm keyword for TI CCS C
 104:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __STATIC_INLINE  static inline
 105:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 106:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #elif defined ( __TASKING__ )
 107:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __ASM            __asm                                      /*!< asm keyword for TASKING 
 108:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __INLINE         inline                                     /*!< inline keyword for TASKI
 109:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __STATIC_INLINE  static inline
 110:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 111:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #elif defined ( __CSMC__ )
 112:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __packed
 113:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __ASM            _asm                                      /*!< asm keyword for COSMIC Co
 114:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __INLINE         inline                                    /*!< inline keyword for COSMIC
 115:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define __STATIC_INLINE  static inline
 116:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 117:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #else
 118:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #error Unknown compiler
 119:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #endif
 120:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 121:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /** __FPU_USED indicates whether an FPU is used or not.
 122:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     This core does not support an FPU at all
 123:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** */
 124:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define __FPU_USED       0U
 125:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 126:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #if defined ( __CC_ARM )
 127:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #if defined __TARGET_FPU_VFP
 128:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 129:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #endif
 130:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 131:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
 132:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #if defined __ARM_PCS_VFP
 133:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 134:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #endif
 135:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 136:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #elif defined ( __GNUC__ )
 137:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
 138:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 139:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #endif
 140:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 141:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #elif defined ( __ICCARM__ )
 142:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #if defined __ARMVFP__
 143:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 144:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #endif
 145:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 146:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #elif defined ( __TMS470__ )
 147:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #if defined __TI_VFP_SUPPORT__
 148:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 149:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #endif
 150:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 151:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #elif defined ( __TASKING__ )
 152:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #if defined __FPU_VFP__
 153:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 154:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #endif
 155:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 156:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #elif defined ( __CSMC__ )
 157:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #if ( __CSMC__ & 0x400U)
 158:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 159:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #endif
 160:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 161:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #endif
 162:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 163:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #include "core_cmInstr.h"                /* Core Instruction Access */
 164:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #include "core_cmFunc.h"                 /* Core Function Access */
 165:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 166:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 167:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** }
 168:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #endif
 169:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 170:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #endif /* __CORE_CM0PLUS_H_GENERIC */
 171:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 172:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #ifndef __CMSIS_GENERIC
 173:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 174:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #ifndef __CORE_CM0PLUS_H_DEPENDANT
 175:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define __CORE_CM0PLUS_H_DEPENDANT
 176:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 177:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 178:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  extern "C" {
 179:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #endif
 180:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 181:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* check device defines and use defaults */
 182:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #if defined __CHECK_DEVICE_DEFINES
 183:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #ifndef __CM0PLUS_REV
 184:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #define __CM0PLUS_REV             0x0000U
 185:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #warning "__CM0PLUS_REV not defined in device header file; using default!"
 186:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #endif
 187:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 188:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #ifndef __MPU_PRESENT
 189:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #define __MPU_PRESENT             0U
 190:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #warning "__MPU_PRESENT not defined in device header file; using default!"
 191:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #endif
 192:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 193:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #ifndef __VTOR_PRESENT
 194:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #define __VTOR_PRESENT            0U
 195:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #warning "__VTOR_PRESENT not defined in device header file; using default!"
 196:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #endif
 197:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 198:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #ifndef __NVIC_PRIO_BITS
 199:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #define __NVIC_PRIO_BITS          2U
 200:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 201:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #endif
 202:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 203:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #ifndef __Vendor_SysTickConfig
 204:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #define __Vendor_SysTickConfig    0U
 205:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 206:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #endif
 207:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #endif
 208:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 209:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* IO definitions (access restrictions to peripheral registers) */
 210:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 211:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 212:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 213:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     <strong>IO Type Qualifiers</strong> are used
 214:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     \li to specify the access to peripheral variables.
 215:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     \li for automatic generation of peripheral register debug information.
 216:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** */
 217:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #ifdef __cplusplus
 218:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 219:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #else
 220:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
 221:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #endif
 222:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 223:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 224:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 225:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* following defines should be used for structure members */
 226:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 227:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 228:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 229:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 230:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /*@} end of group Cortex-M0+ */
 231:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 232:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 233:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 234:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /*******************************************************************************
 235:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  *                 Register Abstraction
 236:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   Core Register contain:
 237:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   - Core Register
 238:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   - Core NVIC Register
 239:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   - Core SCB Register
 240:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   - Core SysTick Register
 241:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   - Core MPU Register
 242:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  ******************************************************************************/
 243:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 244:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \defgroup CMSIS_core_register Defines and Type Definitions
 245:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief Type definitions and defines for Cortex-M processor based devices.
 246:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** */
 247:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 248:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 249:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 250:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_CORE  Status and Control Registers
 251:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief      Core Register type definitions.
 252:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   @{
 253:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 254:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 255:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 256:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief  Union type to access the Application Program Status Register (APSR).
 257:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 258:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** typedef union
 259:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** {
 260:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   struct
 261:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   {
 262:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
 263:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 264:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 265:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 266:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 267:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 268:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 269:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** } APSR_Type;
 270:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 271:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* APSR Register Definitions */
 272:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 273:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 274:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 275:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 276:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 277:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 278:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
 279:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 280:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 281:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 282:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 283:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 284:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 285:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 286:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief  Union type to access the Interrupt Program Status Register (IPSR).
 287:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 288:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** typedef union
 289:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** {
 290:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   struct
 291:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   {
 292:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 293:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 294:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 295:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 296:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** } IPSR_Type;
 297:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 298:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* IPSR Register Definitions */
 299:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 300:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 301:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 302:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 303:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 304:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 305:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 306:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** typedef union
 307:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** {
 308:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   struct
 309:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   {
 310:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 311:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
 312:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
 313:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
 314:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 315:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 316:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 317:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 318:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 319:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 320:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** } xPSR_Type;
 321:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 322:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* xPSR Register Definitions */
 323:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 324:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 325:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 326:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
 327:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 328:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 329:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 330:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 331:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 332:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 333:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 334:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 335:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
 336:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 337:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 338:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 339:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 340:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 341:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 342:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 343:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief  Union type to access the Control Registers (CONTROL).
 344:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 345:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** typedef union
 346:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** {
 347:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   struct
 348:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   {
 349:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
 350:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 351:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****     uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
 352:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   } b;                                   /*!< Structure used for bit  access */
 353:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   uint32_t w;                            /*!< Type      used for word access */
 354:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** } CONTROL_Type;
 355:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 356:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* CONTROL Register Definitions */
 357:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 358:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 359:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 360:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define CONTROL_nPRIV_Pos                   0U                                            /*!< CONT
 361:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONT
 362:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 363:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_CORE */
 364:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 365:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 366:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 367:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 368:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 369:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief      Type definitions for the NVIC Registers
 370:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   @{
 371:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 372:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 373:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 374:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 375:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 376:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** typedef struct
 377:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** {
 378:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
 379:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****         uint32_t RESERVED0[31U];
 380:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 381:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****         uint32_t RSERVED1[31U];
 382:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 383:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****         uint32_t RESERVED2[31U];
 384:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 385:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****         uint32_t RESERVED3[31U];
 386:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****         uint32_t RESERVED4[64U];
 387:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
 388:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** }  NVIC_Type;
 389:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 390:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_NVIC */
 391:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 392:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 393:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 394:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 395:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \defgroup CMSIS_SCB     System Control Block (SCB)
 396:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief    Type definitions for the System Control Block Registers
 397:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   @{
 398:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 399:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 400:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 401:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief  Structure type to access the System Control Block (SCB).
 402:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 403:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** typedef struct
 404:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** {
 405:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 406:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 407:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #if (__VTOR_PRESENT == 1U)
 408:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
 409:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #else
 410:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****         uint32_t RESERVED0;
 411:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #endif
 412:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 413:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
 414:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 415:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****         uint32_t RESERVED1;
 416:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registe
 417:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
 418:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** } SCB_Type;
 419:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 420:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* SCB CPUID Register Definitions */
 421:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 422:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 423:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 424:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 425:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 426:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 427:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 428:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 429:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 430:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 431:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 432:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 433:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 434:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 435:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 436:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* SCB Interrupt Control State Register Definitions */
 437:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
 438:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 439:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 440:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 441:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 442:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 443:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 444:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 445:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 446:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 447:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 448:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 449:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 450:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 451:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 452:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 453:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 454:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 455:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 456:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 457:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 458:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
 459:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 460:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 461:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 462:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 463:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 464:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #if (__VTOR_PRESENT == 1U)
 465:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* SCB Interrupt Control State Register Definitions */
 466:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_VTOR_TBLOFF_Pos                 8U                                            /*!< SCB 
 467:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_VTOR_TBLOFF_Msk                (0xFFFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB 
 468:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #endif
 469:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 470:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 471:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 472:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 473:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 474:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 475:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 476:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 477:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 478:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 479:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 480:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
 481:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 482:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 483:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 484:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 485:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 486:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* SCB System Control Register Definitions */
 487:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 488:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 489:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 490:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 491:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 492:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 493:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 494:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 495:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 496:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* SCB Configuration Control Register Definitions */
 497:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 498:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 499:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 500:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
 501:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 502:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 503:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* SCB System Handler Control and State Register Definitions */
 504:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
 505:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 506:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 507:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_SCB */
 508:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 509:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 510:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 511:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 512:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 513:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief    Type definitions for the System Timer Registers.
 514:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   @{
 515:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 516:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 517:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 518:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief  Structure type to access the System Timer (SysTick).
 519:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 520:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** typedef struct
 521:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** {
 522:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 523:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 524:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 525:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 526:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** } SysTick_Type;
 527:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 528:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* SysTick Control / Status Register Definitions */
 529:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 530:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 531:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 532:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 533:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 534:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 535:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
 536:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 537:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 538:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 539:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 540:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 541:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* SysTick Reload Register Definitions */
 542:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 543:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 544:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 545:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* SysTick Current Register Definitions */
 546:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 547:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 548:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 549:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* SysTick Calibration Register Definitions */
 550:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 551:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 552:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 553:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 554:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 555:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 556:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 557:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 558:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 559:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_SysTick */
 560:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 561:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #if (__MPU_PRESENT == 1U)
 562:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 563:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 564:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
 565:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief    Type definitions for the Memory Protection Unit (MPU)
 566:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   @{
 567:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 568:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 569:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 570:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief  Structure type to access the Memory Protection Unit (MPU).
 571:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 572:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** typedef struct
 573:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** {
 574:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
 575:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
 576:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
 577:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register
 578:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Re
 579:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** } MPU_Type;
 580:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 581:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* MPU Type Register Definitions */
 582:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU 
 583:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU 
 584:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 585:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU 
 586:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU 
 587:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 588:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU 
 589:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU 
 590:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 591:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* MPU Control Register Definitions */
 592:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU 
 593:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU 
 594:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 595:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU 
 596:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU 
 597:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 598:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU 
 599:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU 
 600:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 601:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* MPU Region Number Register Definitions */
 602:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU 
 603:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU 
 604:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 605:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* MPU Region Base Address Register Definitions */
 606:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RBAR_ADDR_Pos                   8U                                            /*!< MPU 
 607:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RBAR_ADDR_Msk                  (0xFFFFFFUL << MPU_RBAR_ADDR_Pos)              /*!< MPU 
 608:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 609:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU 
 610:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU 
 611:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 612:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU 
 613:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU 
 614:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 615:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* MPU Region Attribute and Size Register Definitions */
 616:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU 
 617:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU 
 618:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 619:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_XN_Pos                    28U                                            /*!< MPU 
 620:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU 
 621:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 622:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_AP_Pos                    24U                                            /*!< MPU 
 623:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU 
 624:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 625:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU 
 626:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU 
 627:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 628:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_S_Pos                     18U                                            /*!< MPU 
 629:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU 
 630:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 631:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_C_Pos                     17U                                            /*!< MPU 
 632:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU 
 633:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 634:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_B_Pos                     16U                                            /*!< MPU 
 635:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU 
 636:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 637:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU 
 638:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU 
 639:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 640:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU 
 641:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU 
 642:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 643:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU 
 644:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU 
 645:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 646:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_MPU */
 647:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #endif
 648:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 649:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 650:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 651:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_core_register
 652:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
 653:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief    Cortex-M0+ Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible ov
 654:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****             Therefore they are not covered by the Cortex-M0+ header file.
 655:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   @{
 656:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 657:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_CoreDebug */
 658:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 659:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 660:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 661:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 662:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_core_bitfield     Core register bit field macros
 663:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
 664:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   @{
 665:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 666:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 667:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 668:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief   Mask and shift a bit field value for use in a register bit range.
 669:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \param[in] field  Name of the register bit field.
 670:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \param[in] value  Value of the bit field.
 671:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \return           Masked and shifted value.
 672:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** */
 673:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define _VAL2FLD(field, value)    ((value << field ## _Pos) & field ## _Msk)
 674:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 675:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 676:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief     Mask and shift a register value to extract a bit filed value.
 677:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \param[in] field  Name of the register bit field.
 678:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \param[in] value  Value of register.
 679:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \return           Masked and shifted bit field value.
 680:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** */
 681:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define _FLD2VAL(field, value)    ((value & field ## _Msk) >> field ## _Pos)
 682:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 683:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /*@} end of group CMSIS_core_bitfield */
 684:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 685:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 686:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 687:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \ingroup    CMSIS_core_register
 688:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \defgroup   CMSIS_core_base     Core Definitions
 689:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief      Definitions for base addresses, unions, and structures.
 690:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   @{
 691:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 692:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 693:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* Memory mapping of Cortex-M0+ Hardware */
 694:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
 695:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
 696:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
 697:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
 698:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 699:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
 700:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
 701:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
 702:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 703:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #if (__MPU_PRESENT == 1U)
 704:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit *
 705:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit *
 706:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #endif
 707:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 708:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /*@} */
 709:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 710:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 711:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 712:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /*******************************************************************************
 713:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  *                Hardware Abstraction Layer
 714:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   Core Function Interface contains:
 715:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   - Core NVIC Functions
 716:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   - Core SysTick Functions
 717:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   - Core Register Access Functions
 718:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  ******************************************************************************/
 719:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 720:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
 721:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** */
 722:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 723:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 724:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 725:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* ##########################   NVIC functions  #################################### */
 726:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 727:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \ingroup  CMSIS_Core_FunctionInterface
 728:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \defgroup CMSIS_Core_NVICFunctions NVIC Functions
 729:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief    Functions that manage interrupts and exceptions via the NVIC.
 730:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   @{
 731:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 732:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 733:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* Interrupt Priorities are WORD accessible only under ARMv6M                   */
 734:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /* The following MACROS handle generation of the register offset and byte masks */
 735:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
 736:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
 737:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** #define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
 738:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 739:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** 
 740:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** /**
 741:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \brief   Enable External Interrupt
 742:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \details Enables a device-specific interrupt in the NVIC interrupt controller.
 743:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   \param [in]      IRQn  External interrupt number. Value cannot be negative.
 744:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****  */
 745:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
 746:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** {
  26              		.loc 1 746 1
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 8
  29              		@ frame_needed = 1, uses_anonymous_args = 0
  30 0000 80B5     		push	{r7, lr}
  31              		.cfi_def_cfa_offset 8
  32              		.cfi_offset 7, -8
  33              		.cfi_offset 14, -4
  34 0002 82B0     		sub	sp, sp, #8
  35              		.cfi_def_cfa_offset 16
  36 0004 00AF     		add	r7, sp, #0
  37              		.cfi_def_cfa_register 7
  38 0006 0200     		movs	r2, r0
  39 0008 FB1D     		adds	r3, r7, #7
  40 000a 1A70     		strb	r2, [r3]
 747:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h ****   NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
  41              		.loc 1 747 65
  42 000c FB1D     		adds	r3, r7, #7
  43 000e 1B78     		ldrb	r3, [r3]
  44 0010 1A00     		movs	r2, r3
  45 0012 1F23     		movs	r3, #31
  46 0014 1A40     		ands	r2, r3
  47              		.loc 1 747 7
  48 0016 044B     		ldr	r3, .L2
  49              		.loc 1 747 35
  50 0018 0121     		movs	r1, #1
  51 001a 9140     		lsls	r1, r1, r2
  52 001c 0A00     		movs	r2, r1
  53              		.loc 1 747 18
  54 001e 1A60     		str	r2, [r3]
 748:/home/arpit/studies/pes/Blinkenlights/CMSIS/core_cm0plus.h **** }
  55              		.loc 1 748 1
  56 0020 C046     		nop
  57 0022 BD46     		mov	sp, r7
  58 0024 02B0     		add	sp, sp, #8
  59              		@ sp needed
  60 0026 80BD     		pop	{r7, pc}
  61              	.L3:
  62              		.align	2
  63              	.L2:
  64 0028 00E100E0 		.word	-536813312
  65              		.cfi_endproc
  66              	.LFE25:
  68              		.section	.text.CLOCK_EnableClock,"ax",%progbits
  69              		.align	1
  70              		.syntax unified
  71              		.code	16
  72              		.thumb_func
  73              		.fpu softvfp
  75              	CLOCK_EnableClock:
  76              	.LFB34:
  77              		.file 2 "../drivers/fsl_clock.h"
   1:../drivers/fsl_clock.h **** /*
   2:../drivers/fsl_clock.h ****  * Copyright (c) 2015, Freescale Semiconductor, Inc.
   3:../drivers/fsl_clock.h ****  * Copyright (c) 2016 - 2017 , NXP
   4:../drivers/fsl_clock.h ****  * All rights reserved.
   5:../drivers/fsl_clock.h ****  *
   6:../drivers/fsl_clock.h ****  * Redistribution and use in source and binary forms, with or without modification,
   7:../drivers/fsl_clock.h ****  * are permitted provided that the following conditions are met:
   8:../drivers/fsl_clock.h ****  *
   9:../drivers/fsl_clock.h ****  * o Redistributions of source code must retain the above copyright notice, this list
  10:../drivers/fsl_clock.h ****  *   of conditions and the following disclaimer.
  11:../drivers/fsl_clock.h ****  *
  12:../drivers/fsl_clock.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  13:../drivers/fsl_clock.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  14:../drivers/fsl_clock.h ****  *   other materials provided with the distribution.
  15:../drivers/fsl_clock.h ****  *
  16:../drivers/fsl_clock.h ****  * o Neither the name of copyright holder nor the names of its
  17:../drivers/fsl_clock.h ****  *   contributors may be used to endorse or promote products derived from this
  18:../drivers/fsl_clock.h ****  *   software without specific prior written permission.
  19:../drivers/fsl_clock.h ****  *
  20:../drivers/fsl_clock.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  21:../drivers/fsl_clock.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  22:../drivers/fsl_clock.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  23:../drivers/fsl_clock.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  24:../drivers/fsl_clock.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  25:../drivers/fsl_clock.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  26:../drivers/fsl_clock.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  27:../drivers/fsl_clock.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  28:../drivers/fsl_clock.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  29:../drivers/fsl_clock.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  30:../drivers/fsl_clock.h ****  */
  31:../drivers/fsl_clock.h **** 
  32:../drivers/fsl_clock.h **** #ifndef _FSL_CLOCK_H_
  33:../drivers/fsl_clock.h **** #define _FSL_CLOCK_H_
  34:../drivers/fsl_clock.h **** 
  35:../drivers/fsl_clock.h **** #include "fsl_common.h"
  36:../drivers/fsl_clock.h **** 
  37:../drivers/fsl_clock.h **** /*! @addtogroup clock */
  38:../drivers/fsl_clock.h **** /*! @{ */
  39:../drivers/fsl_clock.h **** 
  40:../drivers/fsl_clock.h **** /*! @file */
  41:../drivers/fsl_clock.h **** 
  42:../drivers/fsl_clock.h **** /*******************************************************************************
  43:../drivers/fsl_clock.h ****  * Configurations
  44:../drivers/fsl_clock.h ****  ******************************************************************************/
  45:../drivers/fsl_clock.h **** 
  46:../drivers/fsl_clock.h **** /*! @brief Configures whether to check a parameter in a function.
  47:../drivers/fsl_clock.h ****  *
  48:../drivers/fsl_clock.h ****  * Some MCG settings must be changed with conditions, for example:
  49:../drivers/fsl_clock.h ****  *  1. MCGIRCLK settings, such as the source, divider, and the trim value should not change when
  50:../drivers/fsl_clock.h ****  *     MCGIRCLK is used as a system clock source.
  51:../drivers/fsl_clock.h ****  *  2. MCG_C7[OSCSEL] should not be changed  when the external reference clock is used
  52:../drivers/fsl_clock.h ****  *     as a system clock source. For example, in FBE/BLPE/PBE modes.
  53:../drivers/fsl_clock.h ****  *  3. The users should only switch between the supported clock modes.
  54:../drivers/fsl_clock.h ****  *
  55:../drivers/fsl_clock.h ****  * MCG functions check the parameter and MCG status before setting, if not allowed
  56:../drivers/fsl_clock.h ****  * to change, the functions return error. The parameter checking increases code size,
  57:../drivers/fsl_clock.h ****  * if code size is a critical requirement, change #MCG_CONFIG_CHECK_PARAM to 0 to
  58:../drivers/fsl_clock.h ****  * disable parameter checking.
  59:../drivers/fsl_clock.h ****  */
  60:../drivers/fsl_clock.h **** #ifndef MCG_CONFIG_CHECK_PARAM
  61:../drivers/fsl_clock.h **** #define MCG_CONFIG_CHECK_PARAM 0U
  62:../drivers/fsl_clock.h **** #endif
  63:../drivers/fsl_clock.h **** 
  64:../drivers/fsl_clock.h **** /*! @brief Configure whether driver controls clock
  65:../drivers/fsl_clock.h ****  *
  66:../drivers/fsl_clock.h ****  * When set to 0, peripheral drivers will enable clock in initialize function
  67:../drivers/fsl_clock.h ****  * and disable clock in de-initialize function. When set to 1, peripheral
  68:../drivers/fsl_clock.h ****  * driver will not control the clock, application could contol the clock out of
  69:../drivers/fsl_clock.h ****  * the driver.
  70:../drivers/fsl_clock.h ****  *
  71:../drivers/fsl_clock.h ****  * @note All drivers share this feature switcher. If it is set to 1, application
  72:../drivers/fsl_clock.h ****  * should handle clock enable and disable for all drivers.
  73:../drivers/fsl_clock.h ****  */
  74:../drivers/fsl_clock.h **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL))
  75:../drivers/fsl_clock.h **** #define FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL 0
  76:../drivers/fsl_clock.h **** #endif
  77:../drivers/fsl_clock.h **** 
  78:../drivers/fsl_clock.h **** /*******************************************************************************
  79:../drivers/fsl_clock.h ****  * Definitions
  80:../drivers/fsl_clock.h ****  ******************************************************************************/
  81:../drivers/fsl_clock.h **** 
  82:../drivers/fsl_clock.h **** /*! @name Driver version */
  83:../drivers/fsl_clock.h **** /*@{*/
  84:../drivers/fsl_clock.h **** /*! @brief CLOCK driver version 2.2.1. */
  85:../drivers/fsl_clock.h **** #define FSL_CLOCK_DRIVER_VERSION (MAKE_VERSION(2, 2, 1))
  86:../drivers/fsl_clock.h **** /*@}*/
  87:../drivers/fsl_clock.h **** 
  88:../drivers/fsl_clock.h **** /*! @brief External XTAL0 (OSC0) clock frequency.
  89:../drivers/fsl_clock.h ****  *
  90:../drivers/fsl_clock.h ****  * The XTAL0/EXTAL0 (OSC0) clock frequency in Hz. When the clock is set up, use the
  91:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal0Freq to set the value in the clock driver. For example,
  92:../drivers/fsl_clock.h ****  * if XTAL0 is 8 MHz:
  93:../drivers/fsl_clock.h ****  * @code
  94:../drivers/fsl_clock.h ****  * CLOCK_InitOsc0(...); // Set up the OSC0
  95:../drivers/fsl_clock.h ****  * CLOCK_SetXtal0Freq(80000000); // Set the XTAL0 value to the clock driver.
  96:../drivers/fsl_clock.h ****  * @endcode
  97:../drivers/fsl_clock.h ****  *
  98:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where only one core needs to set up the
  99:../drivers/fsl_clock.h ****  * OSC0 using the CLOCK_InitOsc0. All other cores need to call the CLOCK_SetXtal0Freq
 100:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
 101:../drivers/fsl_clock.h ****  */
 102:../drivers/fsl_clock.h **** extern uint32_t g_xtal0Freq;
 103:../drivers/fsl_clock.h **** 
 104:../drivers/fsl_clock.h **** /*! @brief External XTAL32/EXTAL32/RTC_CLKIN clock frequency.
 105:../drivers/fsl_clock.h ****  *
 106:../drivers/fsl_clock.h ****  * The XTAL32/EXTAL32/RTC_CLKIN clock frequency in Hz. When the clock is set up, use the
 107:../drivers/fsl_clock.h ****  * function CLOCK_SetXtal32Freq to set the value in the clock driver.
 108:../drivers/fsl_clock.h ****  *
 109:../drivers/fsl_clock.h ****  * This is important for the multicore platforms where only one core needs to set up
 110:../drivers/fsl_clock.h ****  * the clock. All other cores need to call the CLOCK_SetXtal32Freq
 111:../drivers/fsl_clock.h ****  * to get a valid clock frequency.
 112:../drivers/fsl_clock.h ****  */
 113:../drivers/fsl_clock.h **** extern uint32_t g_xtal32Freq;
 114:../drivers/fsl_clock.h **** 
 115:../drivers/fsl_clock.h **** #if (defined(OSC) && !(defined(OSC0)))
 116:../drivers/fsl_clock.h **** #define OSC0 OSC
 117:../drivers/fsl_clock.h **** #endif
 118:../drivers/fsl_clock.h **** 
 119:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMAMUX. */
 120:../drivers/fsl_clock.h **** #define DMAMUX_CLOCKS  \
 121:../drivers/fsl_clock.h ****     {                  \
 122:../drivers/fsl_clock.h ****         kCLOCK_Dmamux0 \
 123:../drivers/fsl_clock.h ****     }
 124:../drivers/fsl_clock.h **** 
 125:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for RTC. */
 126:../drivers/fsl_clock.h **** #define RTC_CLOCKS  \
 127:../drivers/fsl_clock.h ****     {               \
 128:../drivers/fsl_clock.h ****         kCLOCK_Rtc0 \
 129:../drivers/fsl_clock.h ****     }
 130:../drivers/fsl_clock.h **** 
 131:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for SPI. */
 132:../drivers/fsl_clock.h **** #define SPI_CLOCKS               \
 133:../drivers/fsl_clock.h ****     {                            \
 134:../drivers/fsl_clock.h ****         kCLOCK_Spi0, kCLOCK_Spi1 \
 135:../drivers/fsl_clock.h ****     }
 136:../drivers/fsl_clock.h **** 
 137:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PIT. */
 138:../drivers/fsl_clock.h **** #define PIT_CLOCKS  \
 139:../drivers/fsl_clock.h ****     {               \
 140:../drivers/fsl_clock.h ****         kCLOCK_Pit0 \
 141:../drivers/fsl_clock.h ****     }
 142:../drivers/fsl_clock.h **** 
 143:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for PORT. */
 144:../drivers/fsl_clock.h **** #define PORT_CLOCKS                                                          \
 145:../drivers/fsl_clock.h ****     {                                                                        \
 146:../drivers/fsl_clock.h ****         kCLOCK_PortA, kCLOCK_PortB, kCLOCK_PortC, kCLOCK_PortD, kCLOCK_PortE \
 147:../drivers/fsl_clock.h ****     }
 148:../drivers/fsl_clock.h **** 
 149:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for TSI. */
 150:../drivers/fsl_clock.h **** #define TSI_CLOCKS  \
 151:../drivers/fsl_clock.h ****     {               \
 152:../drivers/fsl_clock.h ****         kCLOCK_Tsi0 \
 153:../drivers/fsl_clock.h ****     }
 154:../drivers/fsl_clock.h **** 
 155:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DAC. */
 156:../drivers/fsl_clock.h **** #define DAC_CLOCKS  \
 157:../drivers/fsl_clock.h ****     {               \
 158:../drivers/fsl_clock.h ****         kCLOCK_Dac0 \
 159:../drivers/fsl_clock.h ****     }
 160:../drivers/fsl_clock.h **** 
 161:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPTMR. */
 162:../drivers/fsl_clock.h **** #define LPTMR_CLOCKS  \
 163:../drivers/fsl_clock.h ****     {                 \
 164:../drivers/fsl_clock.h ****         kCLOCK_Lptmr0 \
 165:../drivers/fsl_clock.h ****     }
 166:../drivers/fsl_clock.h **** 
 167:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for ADC16. */
 168:../drivers/fsl_clock.h **** #define ADC16_CLOCKS \
 169:../drivers/fsl_clock.h ****     {                \
 170:../drivers/fsl_clock.h ****         kCLOCK_Adc0  \
 171:../drivers/fsl_clock.h ****     }
 172:../drivers/fsl_clock.h **** 
 173:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for DMA. */
 174:../drivers/fsl_clock.h **** #define DMA_CLOCKS  \
 175:../drivers/fsl_clock.h ****     {               \
 176:../drivers/fsl_clock.h ****         kCLOCK_Dma0 \
 177:../drivers/fsl_clock.h ****     }
 178:../drivers/fsl_clock.h **** 
 179:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for LPSCI/UART0. */
 180:../drivers/fsl_clock.h **** #define UART0_CLOCKS \
 181:../drivers/fsl_clock.h ****     {                \
 182:../drivers/fsl_clock.h ****         kCLOCK_Uart0 \
 183:../drivers/fsl_clock.h ****     }
 184:../drivers/fsl_clock.h **** 
 185:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for UART. */
 186:../drivers/fsl_clock.h **** #define UART_CLOCKS                                  \
 187:../drivers/fsl_clock.h ****     {                                                \
 188:../drivers/fsl_clock.h ****         kCLOCK_IpInvalid, kCLOCK_Uart1, kCLOCK_Uart2 \
 189:../drivers/fsl_clock.h ****     }
 190:../drivers/fsl_clock.h **** 
 191:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for TPM. */
 192:../drivers/fsl_clock.h **** #define TPM_CLOCKS                            \
 193:../drivers/fsl_clock.h ****     {                                         \
 194:../drivers/fsl_clock.h ****         kCLOCK_Tpm0, kCLOCK_Tpm1, kCLOCK_Tpm2 \
 195:../drivers/fsl_clock.h ****     }
 196:../drivers/fsl_clock.h **** 
 197:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for I2C. */
 198:../drivers/fsl_clock.h **** #define I2C_CLOCKS               \
 199:../drivers/fsl_clock.h ****     {                            \
 200:../drivers/fsl_clock.h ****         kCLOCK_I2c0, kCLOCK_I2c1 \
 201:../drivers/fsl_clock.h ****     }
 202:../drivers/fsl_clock.h **** 
 203:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for FTF. */
 204:../drivers/fsl_clock.h **** #define FTF_CLOCKS  \
 205:../drivers/fsl_clock.h ****     {               \
 206:../drivers/fsl_clock.h ****         kCLOCK_Ftf0 \
 207:../drivers/fsl_clock.h ****     }
 208:../drivers/fsl_clock.h **** 
 209:../drivers/fsl_clock.h **** /*! @brief Clock ip name array for CMP. */
 210:../drivers/fsl_clock.h **** #define CMP_CLOCKS  \
 211:../drivers/fsl_clock.h ****     {               \
 212:../drivers/fsl_clock.h ****         kCLOCK_Cmp0 \
 213:../drivers/fsl_clock.h ****     }
 214:../drivers/fsl_clock.h **** 
 215:../drivers/fsl_clock.h **** /*!
 216:../drivers/fsl_clock.h ****  * @brief LPO clock frequency.
 217:../drivers/fsl_clock.h ****  */
 218:../drivers/fsl_clock.h **** #define LPO_CLK_FREQ 1000U
 219:../drivers/fsl_clock.h **** 
 220:../drivers/fsl_clock.h **** /*! @brief Peripherals clock source definition. */
 221:../drivers/fsl_clock.h **** #define SYS_CLK kCLOCK_CoreSysClk
 222:../drivers/fsl_clock.h **** #define BUS_CLK kCLOCK_BusClk
 223:../drivers/fsl_clock.h **** 
 224:../drivers/fsl_clock.h **** #define I2C0_CLK_SRC BUS_CLK
 225:../drivers/fsl_clock.h **** #define I2C1_CLK_SRC BUS_CLK
 226:../drivers/fsl_clock.h **** #define SPI0_CLK_SRC BUS_CLK
 227:../drivers/fsl_clock.h **** #define SPI1_CLK_SRC SYS_CLK
 228:../drivers/fsl_clock.h **** #define UART1_CLK_SRC BUS_CLK
 229:../drivers/fsl_clock.h **** #define UART2_CLK_SRC BUS_CLK
 230:../drivers/fsl_clock.h **** 
 231:../drivers/fsl_clock.h **** /*! @brief Clock name used to get clock frequency. */
 232:../drivers/fsl_clock.h **** typedef enum _clock_name
 233:../drivers/fsl_clock.h **** {
 234:../drivers/fsl_clock.h **** 
 235:../drivers/fsl_clock.h ****     /* ----------------------------- System layer clock -------------------------------*/
 236:../drivers/fsl_clock.h ****     kCLOCK_CoreSysClk,   /*!< Core/system clock                                         */
 237:../drivers/fsl_clock.h ****     kCLOCK_PlatClk,      /*!< Platform clock                                            */
 238:../drivers/fsl_clock.h ****     kCLOCK_BusClk,       /*!< Bus clock                                                 */
 239:../drivers/fsl_clock.h ****     kCLOCK_FlexBusClk,   /*!< FlexBus clock                                             */
 240:../drivers/fsl_clock.h ****     kCLOCK_FlashClk,     /*!< Flash clock                                               */
 241:../drivers/fsl_clock.h ****     kCLOCK_PllFllSelClk, /*!< The clock after SIM[PLLFLLSEL].                           */
 242:../drivers/fsl_clock.h **** 
 243:../drivers/fsl_clock.h ****     /* ---------------------------------- OSC clock -----------------------------------*/
 244:../drivers/fsl_clock.h ****     kCLOCK_Er32kClk,  /*!< External reference 32K clock (ERCLK32K)                   */
 245:../drivers/fsl_clock.h ****     kCLOCK_Osc0ErClk, /*!< OSC0 external reference clock (OSC0ERCLK)                 */
 246:../drivers/fsl_clock.h **** 
 247:../drivers/fsl_clock.h ****     /* ----------------------------- MCG and MCG-Lite clock ---------------------------*/
 248:../drivers/fsl_clock.h ****     kCLOCK_McgFixedFreqClk,   /*!< MCG fixed frequency clock (MCGFFCLK)                      */
 249:../drivers/fsl_clock.h ****     kCLOCK_McgInternalRefClk, /*!< MCG internal reference clock (MCGIRCLK)                   */
 250:../drivers/fsl_clock.h ****     kCLOCK_McgFllClk,         /*!< MCGFLLCLK                                                 */
 251:../drivers/fsl_clock.h ****     kCLOCK_McgPll0Clk,        /*!< MCGPLL0CLK                                                */
 252:../drivers/fsl_clock.h ****     kCLOCK_McgExtPllClk,      /*!< EXT_PLLCLK                                                */
 253:../drivers/fsl_clock.h **** 
 254:../drivers/fsl_clock.h ****     /* --------------------------------- Other clock ----------------------------------*/
 255:../drivers/fsl_clock.h ****     kCLOCK_LpoClk, /*!< LPO clock                                                 */
 256:../drivers/fsl_clock.h **** 
 257:../drivers/fsl_clock.h **** } clock_name_t;
 258:../drivers/fsl_clock.h **** 
 259:../drivers/fsl_clock.h **** /*! @brief USB clock source definition. */
 260:../drivers/fsl_clock.h **** typedef enum _clock_usb_src
 261:../drivers/fsl_clock.h **** {
 262:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcPll0 = SIM_SOPT2_USBSRC(1U) | SIM_SOPT2_PLLFLLSEL(1U), /*!< Use PLL0.      */
 263:../drivers/fsl_clock.h ****     kCLOCK_UsbSrcExt = SIM_SOPT2_USBSRC(0U)                             /*!< Use USB_CLKIN. */
 264:../drivers/fsl_clock.h **** } clock_usb_src_t;
 265:../drivers/fsl_clock.h **** 
 266:../drivers/fsl_clock.h **** /*------------------------------------------------------------------------------
 267:../drivers/fsl_clock.h **** 
 268:../drivers/fsl_clock.h ****  clock_gate_t definition:
 269:../drivers/fsl_clock.h **** 
 270:../drivers/fsl_clock.h ****  31                              16                              0
 271:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 272:../drivers/fsl_clock.h ****  | SIM_SCGC register offset       |   control bit offset in SCGC |
 273:../drivers/fsl_clock.h ****  -----------------------------------------------------------------
 274:../drivers/fsl_clock.h **** 
 275:../drivers/fsl_clock.h ****  For example, the SDHC clock gate is controlled by SIM_SCGC3[17], the
 276:../drivers/fsl_clock.h ****  SIM_SCGC3 offset in SIM is 0x1030, then kCLOCK_GateSdhc0 is defined as
 277:../drivers/fsl_clock.h **** 
 278:../drivers/fsl_clock.h ****               kCLOCK_GateSdhc0 = (0x1030 << 16) | 17;
 279:../drivers/fsl_clock.h **** 
 280:../drivers/fsl_clock.h **** ------------------------------------------------------------------------------*/
 281:../drivers/fsl_clock.h **** 
 282:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_SHIFT 16U
 283:../drivers/fsl_clock.h **** #define CLK_GATE_REG_OFFSET_MASK 0xFFFF0000U
 284:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_SHIFT 0U
 285:../drivers/fsl_clock.h **** #define CLK_GATE_BIT_SHIFT_MASK 0x0000FFFFU
 286:../drivers/fsl_clock.h **** 
 287:../drivers/fsl_clock.h **** #define CLK_GATE_DEFINE(reg_offset, bit_shift)                                  \
 288:../drivers/fsl_clock.h ****     ((((reg_offset) << CLK_GATE_REG_OFFSET_SHIFT) & CLK_GATE_REG_OFFSET_MASK) | \
 289:../drivers/fsl_clock.h ****      (((bit_shift) << CLK_GATE_BIT_SHIFT_SHIFT) & CLK_GATE_BIT_SHIFT_MASK))
 290:../drivers/fsl_clock.h **** 
 291:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_REG_OFFSET(x) (((x)&CLK_GATE_REG_OFFSET_MASK) >> CLK_GATE_REG_OFFSET_SHIF
 292:../drivers/fsl_clock.h **** #define CLK_GATE_ABSTRACT_BITS_SHIFT(x) (((x)&CLK_GATE_BIT_SHIFT_MASK) >> CLK_GATE_BIT_SHIFT_SHIFT)
 293:../drivers/fsl_clock.h **** 
 294:../drivers/fsl_clock.h **** /*! @brief Clock gate name used for CLOCK_EnableClock/CLOCK_DisableClock. */
 295:../drivers/fsl_clock.h **** typedef enum _clock_ip_name
 296:../drivers/fsl_clock.h **** {
 297:../drivers/fsl_clock.h ****     kCLOCK_IpInvalid = 0U,
 298:../drivers/fsl_clock.h ****     kCLOCK_I2c0 = CLK_GATE_DEFINE(0x1034U, 6U),
 299:../drivers/fsl_clock.h ****     kCLOCK_I2c1 = CLK_GATE_DEFINE(0x1034U, 7U),
 300:../drivers/fsl_clock.h ****     kCLOCK_Uart0 = CLK_GATE_DEFINE(0x1034U, 10U),
 301:../drivers/fsl_clock.h ****     kCLOCK_Uart1 = CLK_GATE_DEFINE(0x1034U, 11U),
 302:../drivers/fsl_clock.h ****     kCLOCK_Uart2 = CLK_GATE_DEFINE(0x1034U, 12U),
 303:../drivers/fsl_clock.h ****     kCLOCK_Usbfs0 = CLK_GATE_DEFINE(0x1034U, 18U),
 304:../drivers/fsl_clock.h ****     kCLOCK_Cmp0 = CLK_GATE_DEFINE(0x1034U, 19U),
 305:../drivers/fsl_clock.h ****     kCLOCK_Spi0 = CLK_GATE_DEFINE(0x1034U, 22U),
 306:../drivers/fsl_clock.h ****     kCLOCK_Spi1 = CLK_GATE_DEFINE(0x1034U, 23U),
 307:../drivers/fsl_clock.h **** 
 308:../drivers/fsl_clock.h ****     kCLOCK_Lptmr0 = CLK_GATE_DEFINE(0x1038U, 0U),
 309:../drivers/fsl_clock.h ****     kCLOCK_Tsi0 = CLK_GATE_DEFINE(0x1038U, 5U),
 310:../drivers/fsl_clock.h ****     kCLOCK_PortA = CLK_GATE_DEFINE(0x1038U, 9U),
 311:../drivers/fsl_clock.h ****     kCLOCK_PortB = CLK_GATE_DEFINE(0x1038U, 10U),
 312:../drivers/fsl_clock.h ****     kCLOCK_PortC = CLK_GATE_DEFINE(0x1038U, 11U),
 313:../drivers/fsl_clock.h ****     kCLOCK_PortD = CLK_GATE_DEFINE(0x1038U, 12U),
 314:../drivers/fsl_clock.h ****     kCLOCK_PortE = CLK_GATE_DEFINE(0x1038U, 13U),
 315:../drivers/fsl_clock.h **** 
 316:../drivers/fsl_clock.h ****     kCLOCK_Ftf0 = CLK_GATE_DEFINE(0x103CU, 0U),
 317:../drivers/fsl_clock.h ****     kCLOCK_Dmamux0 = CLK_GATE_DEFINE(0x103CU, 1U),
 318:../drivers/fsl_clock.h ****     kCLOCK_Pit0 = CLK_GATE_DEFINE(0x103CU, 23U),
 319:../drivers/fsl_clock.h ****     kCLOCK_Tpm0 = CLK_GATE_DEFINE(0x103CU, 24U),
 320:../drivers/fsl_clock.h ****     kCLOCK_Tpm1 = CLK_GATE_DEFINE(0x103CU, 25U),
 321:../drivers/fsl_clock.h ****     kCLOCK_Tpm2 = CLK_GATE_DEFINE(0x103CU, 26U),
 322:../drivers/fsl_clock.h ****     kCLOCK_Adc0 = CLK_GATE_DEFINE(0x103CU, 27U),
 323:../drivers/fsl_clock.h ****     kCLOCK_Rtc0 = CLK_GATE_DEFINE(0x103CU, 29U),
 324:../drivers/fsl_clock.h ****     kCLOCK_Dac0 = CLK_GATE_DEFINE(0x103CU, 31U),
 325:../drivers/fsl_clock.h **** 
 326:../drivers/fsl_clock.h ****     kCLOCK_Dma0 = CLK_GATE_DEFINE(0x1040U, 8U),
 327:../drivers/fsl_clock.h **** } clock_ip_name_t;
 328:../drivers/fsl_clock.h **** 
 329:../drivers/fsl_clock.h **** /*!@brief SIM configuration structure for clock setting. */
 330:../drivers/fsl_clock.h **** typedef struct _sim_clock_config
 331:../drivers/fsl_clock.h **** {
 332:../drivers/fsl_clock.h ****     uint8_t pllFllSel;
 333:../drivers/fsl_clock.h ****     uint8_t er32kSrc; /*!< ERCLK32K source selection.   */
 334:../drivers/fsl_clock.h ****     uint32_t clkdiv1; /*!< SIM_CLKDIV1.                 */
 335:../drivers/fsl_clock.h **** } sim_clock_config_t;
 336:../drivers/fsl_clock.h **** 
 337:../drivers/fsl_clock.h **** /*! @brief OSC work mode. */
 338:../drivers/fsl_clock.h **** typedef enum _osc_mode
 339:../drivers/fsl_clock.h **** {
 340:../drivers/fsl_clock.h ****     kOSC_ModeExt = 0U, /*!< Use an external clock.   */
 341:../drivers/fsl_clock.h **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
 342:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS_MASK, /*!< Oscillator low power. */
 343:../drivers/fsl_clock.h **** #else
 344:../drivers/fsl_clock.h ****     kOSC_ModeOscLowPower = MCG_C2_EREFS0_MASK, /*!< Oscillator low power. */
 345:../drivers/fsl_clock.h **** #endif
 346:../drivers/fsl_clock.h ****     kOSC_ModeOscHighGain = 0U
 347:../drivers/fsl_clock.h **** #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
 348:../drivers/fsl_clock.h ****                            |
 349:../drivers/fsl_clock.h ****                            MCG_C2_EREFS_MASK
 350:../drivers/fsl_clock.h **** #else
 351:../drivers/fsl_clock.h ****                            |
 352:../drivers/fsl_clock.h ****                            MCG_C2_EREFS0_MASK
 353:../drivers/fsl_clock.h **** #endif
 354:../drivers/fsl_clock.h **** #if (defined(MCG_C2_HGO_MASK) && !(defined(MCG_C2_HGO0_MASK)))
 355:../drivers/fsl_clock.h ****                            |
 356:../drivers/fsl_clock.h ****                            MCG_C2_HGO_MASK, /*!< Oscillator high gain. */
 357:../drivers/fsl_clock.h **** #else
 358:../drivers/fsl_clock.h ****                            |
 359:../drivers/fsl_clock.h ****                            MCG_C2_HGO0_MASK, /*!< Oscillator high gain. */
 360:../drivers/fsl_clock.h **** #endif
 361:../drivers/fsl_clock.h **** } osc_mode_t;
 362:../drivers/fsl_clock.h **** 
 363:../drivers/fsl_clock.h **** /*! @brief Oscillator capacitor load setting.*/
 364:../drivers/fsl_clock.h **** enum _osc_cap_load
 365:../drivers/fsl_clock.h **** {
 366:../drivers/fsl_clock.h ****     kOSC_Cap2P = OSC_CR_SC2P_MASK,  /*!< 2  pF capacitor load */
 367:../drivers/fsl_clock.h ****     kOSC_Cap4P = OSC_CR_SC4P_MASK,  /*!< 4  pF capacitor load */
 368:../drivers/fsl_clock.h ****     kOSC_Cap8P = OSC_CR_SC8P_MASK,  /*!< 8  pF capacitor load */
 369:../drivers/fsl_clock.h ****     kOSC_Cap16P = OSC_CR_SC16P_MASK /*!< 16 pF capacitor load */
 370:../drivers/fsl_clock.h **** };
 371:../drivers/fsl_clock.h **** 
 372:../drivers/fsl_clock.h **** /*! @brief OSCERCLK enable mode. */
 373:../drivers/fsl_clock.h **** enum _oscer_enable_mode
 374:../drivers/fsl_clock.h **** {
 375:../drivers/fsl_clock.h ****     kOSC_ErClkEnable = OSC_CR_ERCLKEN_MASK,       /*!< Enable.              */
 376:../drivers/fsl_clock.h ****     kOSC_ErClkEnableInStop = OSC_CR_EREFSTEN_MASK /*!< Enable in stop mode. */
 377:../drivers/fsl_clock.h **** };
 378:../drivers/fsl_clock.h **** 
 379:../drivers/fsl_clock.h **** /*! @brief OSC configuration for OSCERCLK. */
 380:../drivers/fsl_clock.h **** typedef struct _oscer_config
 381:../drivers/fsl_clock.h **** {
 382:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< OSCERCLK enable mode. OR'ed value of @ref _oscer_enable_mode. */
 383:../drivers/fsl_clock.h **** 
 384:../drivers/fsl_clock.h **** } oscer_config_t;
 385:../drivers/fsl_clock.h **** 
 386:../drivers/fsl_clock.h **** /*!
 387:../drivers/fsl_clock.h ****  * @brief OSC Initialization Configuration Structure
 388:../drivers/fsl_clock.h ****  *
 389:../drivers/fsl_clock.h ****  * Defines the configuration data structure to initialize the OSC.
 390:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 391:../drivers/fsl_clock.h ****  * according to the board setting:
 392:../drivers/fsl_clock.h ****  * 1. freq: The external frequency.
 393:../drivers/fsl_clock.h ****  * 2. workMode: The OSC module mode.
 394:../drivers/fsl_clock.h ****  */
 395:../drivers/fsl_clock.h **** typedef struct _osc_config
 396:../drivers/fsl_clock.h **** {
 397:../drivers/fsl_clock.h ****     uint32_t freq;              /*!< External clock frequency.    */
 398:../drivers/fsl_clock.h ****     uint8_t capLoad;            /*!< Capacitor load setting.      */
 399:../drivers/fsl_clock.h ****     osc_mode_t workMode;        /*!< OSC work mode setting.       */
 400:../drivers/fsl_clock.h ****     oscer_config_t oscerConfig; /*!< Configuration for OSCERCLK.  */
 401:../drivers/fsl_clock.h **** } osc_config_t;
 402:../drivers/fsl_clock.h **** 
 403:../drivers/fsl_clock.h **** /*! @brief MCG FLL reference clock source select. */
 404:../drivers/fsl_clock.h **** typedef enum _mcg_fll_src
 405:../drivers/fsl_clock.h **** {
 406:../drivers/fsl_clock.h ****     kMCG_FllSrcExternal, /*!< External reference clock is selected          */
 407:../drivers/fsl_clock.h ****     kMCG_FllSrcInternal  /*!< The slow internal reference clock is selected */
 408:../drivers/fsl_clock.h **** } mcg_fll_src_t;
 409:../drivers/fsl_clock.h **** 
 410:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock select */
 411:../drivers/fsl_clock.h **** typedef enum _mcg_irc_mode
 412:../drivers/fsl_clock.h **** {
 413:../drivers/fsl_clock.h ****     kMCG_IrcSlow, /*!< Slow internal reference clock selected */
 414:../drivers/fsl_clock.h ****     kMCG_IrcFast  /*!< Fast internal reference clock selected */
 415:../drivers/fsl_clock.h **** } mcg_irc_mode_t;
 416:../drivers/fsl_clock.h **** 
 417:../drivers/fsl_clock.h **** /*! @brief MCG DCO Maximum Frequency with 32.768 kHz Reference */
 418:../drivers/fsl_clock.h **** typedef enum _mcg_dmx32
 419:../drivers/fsl_clock.h **** {
 420:../drivers/fsl_clock.h ****     kMCG_Dmx32Default, /*!< DCO has a default range of 25% */
 421:../drivers/fsl_clock.h ****     kMCG_Dmx32Fine     /*!< DCO is fine-tuned for maximum frequency with 32.768 kHz reference */
 422:../drivers/fsl_clock.h **** } mcg_dmx32_t;
 423:../drivers/fsl_clock.h **** 
 424:../drivers/fsl_clock.h **** /*! @brief MCG DCO range select */
 425:../drivers/fsl_clock.h **** typedef enum _mcg_drs
 426:../drivers/fsl_clock.h **** {
 427:../drivers/fsl_clock.h ****     kMCG_DrsLow,     /*!< Low frequency range       */
 428:../drivers/fsl_clock.h ****     kMCG_DrsMid,     /*!< Mid frequency range       */
 429:../drivers/fsl_clock.h ****     kMCG_DrsMidHigh, /*!< Mid-High frequency range  */
 430:../drivers/fsl_clock.h ****     kMCG_DrsHigh     /*!< High frequency range      */
 431:../drivers/fsl_clock.h **** } mcg_drs_t;
 432:../drivers/fsl_clock.h **** 
 433:../drivers/fsl_clock.h **** /*! @brief MCG PLL reference clock select */
 434:../drivers/fsl_clock.h **** typedef enum _mcg_pll_ref_src
 435:../drivers/fsl_clock.h **** {
 436:../drivers/fsl_clock.h ****     kMCG_PllRefOsc0, /*!< Selects OSC0 as PLL reference clock                 */
 437:../drivers/fsl_clock.h ****     kMCG_PllRefOsc1  /*!< Selects OSC1 as PLL reference clock                 */
 438:../drivers/fsl_clock.h **** } mcg_pll_ref_src_t;
 439:../drivers/fsl_clock.h **** 
 440:../drivers/fsl_clock.h **** /*! @brief MCGOUT clock source. */
 441:../drivers/fsl_clock.h **** typedef enum _mcg_clkout_src
 442:../drivers/fsl_clock.h **** {
 443:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcOut,      /*!< Output of the FLL is selected (reset default)  */
 444:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcInternal, /*!< Internal reference clock is selected           */
 445:../drivers/fsl_clock.h ****     kMCG_ClkOutSrcExternal, /*!< External reference clock is selected           */
 446:../drivers/fsl_clock.h **** } mcg_clkout_src_t;
 447:../drivers/fsl_clock.h **** 
 448:../drivers/fsl_clock.h **** /*! @brief MCG Automatic Trim Machine Select */
 449:../drivers/fsl_clock.h **** typedef enum _mcg_atm_select
 450:../drivers/fsl_clock.h **** {
 451:../drivers/fsl_clock.h ****     kMCG_AtmSel32k, /*!< 32 kHz Internal Reference Clock selected  */
 452:../drivers/fsl_clock.h ****     kMCG_AtmSel4m   /*!< 4 MHz Internal Reference Clock selected   */
 453:../drivers/fsl_clock.h **** } mcg_atm_select_t;
 454:../drivers/fsl_clock.h **** 
 455:../drivers/fsl_clock.h **** /*! @brief MCG OSC Clock Select */
 456:../drivers/fsl_clock.h **** typedef enum _mcg_oscsel
 457:../drivers/fsl_clock.h **** {
 458:../drivers/fsl_clock.h ****     kMCG_OscselOsc, /*!< Selects System Oscillator (OSCCLK) */
 459:../drivers/fsl_clock.h ****     kMCG_OscselRtc, /*!< Selects 32 kHz RTC Oscillator      */
 460:../drivers/fsl_clock.h **** } mcg_oscsel_t;
 461:../drivers/fsl_clock.h **** 
 462:../drivers/fsl_clock.h **** /*! @brief MCG PLLCS select */
 463:../drivers/fsl_clock.h **** typedef enum _mcg_pll_clk_select
 464:../drivers/fsl_clock.h **** {
 465:../drivers/fsl_clock.h ****     kMCG_PllClkSelPll0, /*!< PLL0 output clock is selected  */
 466:../drivers/fsl_clock.h ****     kMCG_PllClkSelPll1  /* PLL1 output clock is selected    */
 467:../drivers/fsl_clock.h **** } mcg_pll_clk_select_t;
 468:../drivers/fsl_clock.h **** 
 469:../drivers/fsl_clock.h **** /*! @brief MCG clock monitor mode. */
 470:../drivers/fsl_clock.h **** typedef enum _mcg_monitor_mode
 471:../drivers/fsl_clock.h **** {
 472:../drivers/fsl_clock.h ****     kMCG_MonitorNone, /*!< Clock monitor is disabled.         */
 473:../drivers/fsl_clock.h ****     kMCG_MonitorInt,  /*!< Trigger interrupt when clock lost. */
 474:../drivers/fsl_clock.h ****     kMCG_MonitorReset /*!< System reset when clock lost.      */
 475:../drivers/fsl_clock.h **** } mcg_monitor_mode_t;
 476:../drivers/fsl_clock.h **** 
 477:../drivers/fsl_clock.h **** /*! @brief MCG status. */
 478:../drivers/fsl_clock.h **** enum _mcg_status
 479:../drivers/fsl_clock.h **** {
 480:../drivers/fsl_clock.h ****     kStatus_MCG_ModeUnreachable = MAKE_STATUS(kStatusGroup_MCG, 0),       /*!< Can't switch to targ
 481:../drivers/fsl_clock.h ****     kStatus_MCG_ModeInvalid = MAKE_STATUS(kStatusGroup_MCG, 1),           /*!< Current mode invalid
 482:../drivers/fsl_clock.h ****                                                                                function. */
 483:../drivers/fsl_clock.h ****     kStatus_MCG_AtmBusClockInvalid = MAKE_STATUS(kStatusGroup_MCG, 2),    /*!< Invalid bus clock fo
 484:../drivers/fsl_clock.h ****     kStatus_MCG_AtmDesiredFreqInvalid = MAKE_STATUS(kStatusGroup_MCG, 3), /*!< Invalid desired freq
 485:../drivers/fsl_clock.h ****     kStatus_MCG_AtmIrcUsed = MAKE_STATUS(kStatusGroup_MCG, 4),            /*!< IRC is used when usi
 486:../drivers/fsl_clock.h ****     kStatus_MCG_AtmHardwareFail = MAKE_STATUS(kStatusGroup_MCG, 5),       /*!< Hardware fail occurs
 487:../drivers/fsl_clock.h ****     kStatus_MCG_SourceUsed = MAKE_STATUS(kStatusGroup_MCG, 6)             /*!< Can't change the clo
 488:../drivers/fsl_clock.h ****                                                                                it is in use. */
 489:../drivers/fsl_clock.h **** };
 490:../drivers/fsl_clock.h **** 
 491:../drivers/fsl_clock.h **** /*! @brief MCG status flags. */
 492:../drivers/fsl_clock.h **** enum _mcg_status_flags_t
 493:../drivers/fsl_clock.h **** {
 494:../drivers/fsl_clock.h ****     kMCG_Osc0LostFlag = (1U << 0U), /*!< OSC0 lost.         */
 495:../drivers/fsl_clock.h ****     kMCG_Osc0InitFlag = (1U << 1U), /*!< OSC0 crystal initialized. */
 496:../drivers/fsl_clock.h ****     kMCG_Pll0LostFlag = (1U << 5U), /*!< PLL0 lost.         */
 497:../drivers/fsl_clock.h ****     kMCG_Pll0LockFlag = (1U << 6U), /*!< PLL0 locked.       */
 498:../drivers/fsl_clock.h **** };
 499:../drivers/fsl_clock.h **** 
 500:../drivers/fsl_clock.h **** /*! @brief MCG internal reference clock (MCGIRCLK) enable mode definition. */
 501:../drivers/fsl_clock.h **** enum _mcg_irclk_enable_mode
 502:../drivers/fsl_clock.h **** {
 503:../drivers/fsl_clock.h ****     kMCG_IrclkEnable = MCG_C1_IRCLKEN_MASK,       /*!< MCGIRCLK enable.              */
 504:../drivers/fsl_clock.h ****     kMCG_IrclkEnableInStop = MCG_C1_IREFSTEN_MASK /*!< MCGIRCLK enable in stop mode. */
 505:../drivers/fsl_clock.h **** };
 506:../drivers/fsl_clock.h **** 
 507:../drivers/fsl_clock.h **** /*! @brief MCG PLL clock enable mode definition. */
 508:../drivers/fsl_clock.h **** enum _mcg_pll_enable_mode
 509:../drivers/fsl_clock.h **** {
 510:../drivers/fsl_clock.h ****     kMCG_PllEnableIndependent = MCG_C5_PLLCLKEN0_MASK, /*!< MCGPLLCLK enable independent of the
 511:../drivers/fsl_clock.h ****                                                            MCG clock mode. Generally, the PLL
 512:../drivers/fsl_clock.h ****                                                            is disabled in FLL modes
 513:../drivers/fsl_clock.h ****                                                            (FEI/FBI/FEE/FBE). Setting the PLL clock
 514:../drivers/fsl_clock.h ****                                                            enable independent, enables the
 515:../drivers/fsl_clock.h ****                                                            PLL in the FLL modes.          */
 516:../drivers/fsl_clock.h ****     kMCG_PllEnableInStop = MCG_C5_PLLSTEN0_MASK        /*!< MCGPLLCLK enable in STOP mode. */
 517:../drivers/fsl_clock.h **** };
 518:../drivers/fsl_clock.h **** 
 519:../drivers/fsl_clock.h **** /*! @brief MCG mode definitions */
 520:../drivers/fsl_clock.h **** typedef enum _mcg_mode
 521:../drivers/fsl_clock.h **** {
 522:../drivers/fsl_clock.h ****     kMCG_ModeFEI = 0U, /*!< FEI   - FLL Engaged Internal         */
 523:../drivers/fsl_clock.h ****     kMCG_ModeFBI,      /*!< FBI   - FLL Bypassed Internal        */
 524:../drivers/fsl_clock.h ****     kMCG_ModeBLPI,     /*!< BLPI  - Bypassed Low Power Internal  */
 525:../drivers/fsl_clock.h ****     kMCG_ModeFEE,      /*!< FEE   - FLL Engaged External         */
 526:../drivers/fsl_clock.h ****     kMCG_ModeFBE,      /*!< FBE   - FLL Bypassed External        */
 527:../drivers/fsl_clock.h ****     kMCG_ModeBLPE,     /*!< BLPE  - Bypassed Low Power External  */
 528:../drivers/fsl_clock.h ****     kMCG_ModePBE,      /*!< PBE   - PLL Bypassed External        */
 529:../drivers/fsl_clock.h ****     kMCG_ModePEE,      /*!< PEE   - PLL Engaged External         */
 530:../drivers/fsl_clock.h ****     kMCG_ModeError     /*!< Unknown mode                         */
 531:../drivers/fsl_clock.h **** } mcg_mode_t;
 532:../drivers/fsl_clock.h **** 
 533:../drivers/fsl_clock.h **** /*! @brief MCG PLL configuration. */
 534:../drivers/fsl_clock.h **** typedef struct _mcg_pll_config
 535:../drivers/fsl_clock.h **** {
 536:../drivers/fsl_clock.h ****     uint8_t enableMode; /*!< Enable mode. OR'ed value of @ref _mcg_pll_enable_mode. */
 537:../drivers/fsl_clock.h ****     uint8_t prdiv;      /*!< Reference divider PRDIV.    */
 538:../drivers/fsl_clock.h ****     uint8_t vdiv;       /*!< VCO divider VDIV.           */
 539:../drivers/fsl_clock.h **** } mcg_pll_config_t;
 540:../drivers/fsl_clock.h **** 
 541:../drivers/fsl_clock.h **** /*! @brief MCG mode change configuration structure
 542:../drivers/fsl_clock.h ****  *
 543:../drivers/fsl_clock.h ****  * When porting to a new board, set the following members
 544:../drivers/fsl_clock.h ****  * according to the board setting:
 545:../drivers/fsl_clock.h ****  * 1. frdiv: If the FLL uses the external reference clock, set this
 546:../drivers/fsl_clock.h ****  *    value to ensure that the external reference clock divided by frdiv is
 547:../drivers/fsl_clock.h ****  *    in the 31.25 kHz to 39.0625 kHz range.
 548:../drivers/fsl_clock.h ****  * 2. The PLL reference clock divider PRDIV: PLL reference clock frequency after
 549:../drivers/fsl_clock.h ****  *    PRDIV should be in the FSL_FEATURE_MCG_PLL_REF_MIN to
 550:../drivers/fsl_clock.h ****  *    FSL_FEATURE_MCG_PLL_REF_MAX range.
 551:../drivers/fsl_clock.h ****  */
 552:../drivers/fsl_clock.h **** typedef struct _mcg_config
 553:../drivers/fsl_clock.h **** {
 554:../drivers/fsl_clock.h ****     mcg_mode_t mcgMode; /*!< MCG mode.                   */
 555:../drivers/fsl_clock.h **** 
 556:../drivers/fsl_clock.h ****     /* ----------------------- MCGIRCCLK settings ------------------------ */
 557:../drivers/fsl_clock.h ****     uint8_t irclkEnableMode; /*!< MCGIRCLK enable mode.       */
 558:../drivers/fsl_clock.h ****     mcg_irc_mode_t ircs;     /*!< Source, MCG_C2[IRCS].       */
 559:../drivers/fsl_clock.h ****     uint8_t fcrdiv;          /*!< Divider, MCG_SC[FCRDIV].    */
 560:../drivers/fsl_clock.h **** 
 561:../drivers/fsl_clock.h ****     /* ------------------------ MCG FLL settings ------------------------- */
 562:../drivers/fsl_clock.h ****     uint8_t frdiv;     /*!< Divider MCG_C1[FRDIV].      */
 563:../drivers/fsl_clock.h ****     mcg_drs_t drs;     /*!< DCO range MCG_C4[DRST_DRS]. */
 564:../drivers/fsl_clock.h ****     mcg_dmx32_t dmx32; /*!< MCG_C4[DMX32].              */
 565:../drivers/fsl_clock.h **** 
 566:../drivers/fsl_clock.h ****     /* ------------------------ MCG PLL settings ------------------------- */
 567:../drivers/fsl_clock.h ****     mcg_pll_config_t pll0Config; /*!< MCGPLL0CLK configuration.   */
 568:../drivers/fsl_clock.h **** 
 569:../drivers/fsl_clock.h **** } mcg_config_t;
 570:../drivers/fsl_clock.h **** 
 571:../drivers/fsl_clock.h **** /*******************************************************************************
 572:../drivers/fsl_clock.h ****  * API
 573:../drivers/fsl_clock.h ****  ******************************************************************************/
 574:../drivers/fsl_clock.h **** 
 575:../drivers/fsl_clock.h **** #if defined(__cplusplus)
 576:../drivers/fsl_clock.h **** extern "C" {
 577:../drivers/fsl_clock.h **** #endif /* __cplusplus */
 578:../drivers/fsl_clock.h **** 
 579:../drivers/fsl_clock.h **** /*!
 580:../drivers/fsl_clock.h ****  * @brief Enable the clock for specific IP.
 581:../drivers/fsl_clock.h ****  *
 582:../drivers/fsl_clock.h ****  * @param name  Which clock to enable, see \ref clock_ip_name_t.
 583:../drivers/fsl_clock.h ****  */
 584:../drivers/fsl_clock.h **** static inline void CLOCK_EnableClock(clock_ip_name_t name)
 585:../drivers/fsl_clock.h **** {
  78              		.loc 2 585 1
  79              		.cfi_startproc
  80              		@ args = 0, pretend = 0, frame = 16
  81              		@ frame_needed = 1, uses_anonymous_args = 0
  82 0000 80B5     		push	{r7, lr}
  83              		.cfi_def_cfa_offset 8
  84              		.cfi_offset 7, -8
  85              		.cfi_offset 14, -4
  86 0002 84B0     		sub	sp, sp, #16
  87              		.cfi_def_cfa_offset 24
  88 0004 00AF     		add	r7, sp, #0
  89              		.cfi_def_cfa_register 7
  90 0006 7860     		str	r0, [r7, #4]
 586:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
  91              		.loc 2 586 35
  92 0008 7B68     		ldr	r3, [r7, #4]
  93 000a 1B0C     		lsrs	r3, r3, #16
  94              		.loc 2 586 14
  95 000c 084A     		ldr	r2, .L5
  96 000e 9446     		mov	ip, r2
  97 0010 6344     		add	r3, r3, ip
  98 0012 FB60     		str	r3, [r7, #12]
 587:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) |= (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
  99              		.loc 2 587 37
 100 0014 FB68     		ldr	r3, [r7, #12]
 101 0016 1968     		ldr	r1, [r3]
 102              		.loc 2 587 47
 103 0018 7B68     		ldr	r3, [r7, #4]
 104 001a 1B04     		lsls	r3, r3, #16
 105 001c 1B0C     		lsrs	r3, r3, #16
 106              		.loc 2 587 44
 107 001e 0122     		movs	r2, #1
 108 0020 9A40     		lsls	r2, r2, r3
 109              		.loc 2 587 37
 110 0022 FB68     		ldr	r3, [r7, #12]
 111 0024 0A43     		orrs	r2, r1
 112 0026 1A60     		str	r2, [r3]
 588:../drivers/fsl_clock.h **** }
 113              		.loc 2 588 1
 114 0028 C046     		nop
 115 002a BD46     		mov	sp, r7
 116 002c 04B0     		add	sp, sp, #16
 117              		@ sp needed
 118 002e 80BD     		pop	{r7, pc}
 119              	.L6:
 120              		.align	2
 121              	.L5:
 122 0030 00700440 		.word	1074032640
 123              		.cfi_endproc
 124              	.LFE34:
 126              		.section	.text.CLOCK_DisableClock,"ax",%progbits
 127              		.align	1
 128              		.syntax unified
 129              		.code	16
 130              		.thumb_func
 131              		.fpu softvfp
 133              	CLOCK_DisableClock:
 134              	.LFB35:
 589:../drivers/fsl_clock.h **** 
 590:../drivers/fsl_clock.h **** /*!
 591:../drivers/fsl_clock.h ****  * @brief Disable the clock for specific IP.
 592:../drivers/fsl_clock.h ****  *
 593:../drivers/fsl_clock.h ****  * @param name  Which clock to disable, see \ref clock_ip_name_t.
 594:../drivers/fsl_clock.h ****  */
 595:../drivers/fsl_clock.h **** static inline void CLOCK_DisableClock(clock_ip_name_t name)
 596:../drivers/fsl_clock.h **** {
 135              		.loc 2 596 1
 136              		.cfi_startproc
 137              		@ args = 0, pretend = 0, frame = 16
 138              		@ frame_needed = 1, uses_anonymous_args = 0
 139 0000 80B5     		push	{r7, lr}
 140              		.cfi_def_cfa_offset 8
 141              		.cfi_offset 7, -8
 142              		.cfi_offset 14, -4
 143 0002 84B0     		sub	sp, sp, #16
 144              		.cfi_def_cfa_offset 24
 145 0004 00AF     		add	r7, sp, #0
 146              		.cfi_def_cfa_register 7
 147 0006 7860     		str	r0, [r7, #4]
 597:../drivers/fsl_clock.h ****     uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
 148              		.loc 2 597 35
 149 0008 7B68     		ldr	r3, [r7, #4]
 150 000a 1B0C     		lsrs	r3, r3, #16
 151              		.loc 2 597 14
 152 000c 094A     		ldr	r2, .L8
 153 000e 9446     		mov	ip, r2
 154 0010 6344     		add	r3, r3, ip
 155 0012 FB60     		str	r3, [r7, #12]
 598:../drivers/fsl_clock.h ****     (*(volatile uint32_t *)regAddr) &= ~(1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
 156              		.loc 2 598 37
 157 0014 FB68     		ldr	r3, [r7, #12]
 158 0016 1A68     		ldr	r2, [r3]
 159              		.loc 2 598 48
 160 0018 7B68     		ldr	r3, [r7, #4]
 161 001a 1B04     		lsls	r3, r3, #16
 162 001c 1B0C     		lsrs	r3, r3, #16
 163              		.loc 2 598 45
 164 001e 0121     		movs	r1, #1
 165 0020 9940     		lsls	r1, r1, r3
 166 0022 0B00     		movs	r3, r1
 167              		.loc 2 598 40
 168 0024 D943     		mvns	r1, r3
 169              		.loc 2 598 37
 170 0026 FB68     		ldr	r3, [r7, #12]
 171 0028 0A40     		ands	r2, r1
 172 002a 1A60     		str	r2, [r3]
 599:../drivers/fsl_clock.h **** }
 173              		.loc 2 599 1
 174 002c C046     		nop
 175 002e BD46     		mov	sp, r7
 176 0030 04B0     		add	sp, sp, #16
 177              		@ sp needed
 178 0032 80BD     		pop	{r7, pc}
 179              	.L9:
 180              		.align	2
 181              	.L8:
 182 0034 00700440 		.word	1074032640
 183              		.cfi_endproc
 184              	.LFE35:
 186              		.section	.text.EnableIRQ,"ax",%progbits
 187              		.align	1
 188              		.syntax unified
 189              		.code	16
 190              		.thumb_func
 191              		.fpu softvfp
 193              	EnableIRQ:
 194              	.LFB52:
 195              		.file 3 "../drivers/fsl_common.h"
   1:../drivers/fsl_common.h **** /*
   2:../drivers/fsl_common.h ****  * Copyright (c) 2015-2016, Freescale Semiconductor, Inc.
   3:../drivers/fsl_common.h ****  * Copyright 2016-2017 NXP
   4:../drivers/fsl_common.h ****  *
   5:../drivers/fsl_common.h ****  * Redistribution and use in source and binary forms, with or without modification,
   6:../drivers/fsl_common.h ****  * are permitted provided that the following conditions are met:
   7:../drivers/fsl_common.h ****  *
   8:../drivers/fsl_common.h ****  * o Redistributions of source code must retain the above copyright notice, this list
   9:../drivers/fsl_common.h ****  *   of conditions and the following disclaimer.
  10:../drivers/fsl_common.h ****  *
  11:../drivers/fsl_common.h ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  12:../drivers/fsl_common.h ****  *   list of conditions and the following disclaimer in the documentation and/or
  13:../drivers/fsl_common.h ****  *   other materials provided with the distribution.
  14:../drivers/fsl_common.h ****  *
  15:../drivers/fsl_common.h ****  * o Neither the name of the copyright holder nor the names of its
  16:../drivers/fsl_common.h ****  *   contributors may be used to endorse or promote products derived from this
  17:../drivers/fsl_common.h ****  *   software without specific prior written permission.
  18:../drivers/fsl_common.h ****  *
  19:../drivers/fsl_common.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  20:../drivers/fsl_common.h ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  21:../drivers/fsl_common.h ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  22:../drivers/fsl_common.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  23:../drivers/fsl_common.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  24:../drivers/fsl_common.h ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  25:../drivers/fsl_common.h ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  26:../drivers/fsl_common.h ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27:../drivers/fsl_common.h ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  28:../drivers/fsl_common.h ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29:../drivers/fsl_common.h ****  */
  30:../drivers/fsl_common.h **** 
  31:../drivers/fsl_common.h **** #ifndef _FSL_COMMON_H_
  32:../drivers/fsl_common.h **** #define _FSL_COMMON_H_
  33:../drivers/fsl_common.h **** 
  34:../drivers/fsl_common.h **** #include <assert.h>
  35:../drivers/fsl_common.h **** #include <stdbool.h>
  36:../drivers/fsl_common.h **** #include <stdint.h>
  37:../drivers/fsl_common.h **** #include <string.h>
  38:../drivers/fsl_common.h **** 
  39:../drivers/fsl_common.h **** #if defined(__ICCARM__)
  40:../drivers/fsl_common.h **** #include <stddef.h>
  41:../drivers/fsl_common.h **** #endif
  42:../drivers/fsl_common.h **** 
  43:../drivers/fsl_common.h **** #include "fsl_device_registers.h"
  44:../drivers/fsl_common.h **** 
  45:../drivers/fsl_common.h **** /*!
  46:../drivers/fsl_common.h ****  * @addtogroup ksdk_common
  47:../drivers/fsl_common.h ****  * @{
  48:../drivers/fsl_common.h ****  */
  49:../drivers/fsl_common.h **** 
  50:../drivers/fsl_common.h **** /*******************************************************************************
  51:../drivers/fsl_common.h ****  * Definitions
  52:../drivers/fsl_common.h ****  ******************************************************************************/
  53:../drivers/fsl_common.h **** 
  54:../drivers/fsl_common.h **** /*! @brief Construct a status code value from a group and code number. */
  55:../drivers/fsl_common.h **** #define MAKE_STATUS(group, code) ((((group)*100) + (code)))
  56:../drivers/fsl_common.h **** 
  57:../drivers/fsl_common.h **** /*! @brief Construct the version number for drivers. */
  58:../drivers/fsl_common.h **** #define MAKE_VERSION(major, minor, bugfix) (((major) << 16) | ((minor) << 8) | (bugfix))
  59:../drivers/fsl_common.h **** 
  60:../drivers/fsl_common.h **** /* Debug console type definition. */
  61:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_NONE 0U     /*!< No debug console.             */
  62:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_UART 1U     /*!< Debug console base on UART.   */
  63:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_LPUART 2U   /*!< Debug console base on LPUART. */
  64:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_LPSCI 3U    /*!< Debug console base on LPSCI.  */
  65:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_USBCDC 4U   /*!< Debug console base on USBCDC. */
  66:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_FLEXCOMM 5U /*!< Debug console base on USBCDC. */
  67:../drivers/fsl_common.h **** #define DEBUG_CONSOLE_DEVICE_TYPE_IUART 6U    /*!< Debug console base on i.MX UART. */
  68:../drivers/fsl_common.h **** 
  69:../drivers/fsl_common.h **** /*! @brief Status group numbers. */
  70:../drivers/fsl_common.h **** enum _status_groups
  71:../drivers/fsl_common.h **** {
  72:../drivers/fsl_common.h ****     kStatusGroup_Generic = 0,                 /*!< Group number for generic status codes. */
  73:../drivers/fsl_common.h ****     kStatusGroup_FLASH = 1,                   /*!< Group number for FLASH status codes. */
  74:../drivers/fsl_common.h ****     kStatusGroup_LPSPI = 4,                   /*!< Group number for LPSPI status codes. */
  75:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_SPI = 5,              /*!< Group number for FLEXIO SPI status codes. */
  76:../drivers/fsl_common.h ****     kStatusGroup_DSPI = 6,                    /*!< Group number for DSPI status codes. */
  77:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_UART = 7,             /*!< Group number for FLEXIO UART status codes. */
  78:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_I2C = 8,              /*!< Group number for FLEXIO I2C status codes. */
  79:../drivers/fsl_common.h ****     kStatusGroup_LPI2C = 9,                   /*!< Group number for LPI2C status codes. */
  80:../drivers/fsl_common.h ****     kStatusGroup_UART = 10,                   /*!< Group number for UART status codes. */
  81:../drivers/fsl_common.h ****     kStatusGroup_I2C = 11,                    /*!< Group number for UART status codes. */
  82:../drivers/fsl_common.h ****     kStatusGroup_LPSCI = 12,                  /*!< Group number for LPSCI status codes. */
  83:../drivers/fsl_common.h ****     kStatusGroup_LPUART = 13,                 /*!< Group number for LPUART status codes. */
  84:../drivers/fsl_common.h ****     kStatusGroup_SPI = 14,                    /*!< Group number for SPI status code.*/
  85:../drivers/fsl_common.h ****     kStatusGroup_XRDC = 15,                   /*!< Group number for XRDC status code.*/
  86:../drivers/fsl_common.h ****     kStatusGroup_SEMA42 = 16,                 /*!< Group number for SEMA42 status code.*/
  87:../drivers/fsl_common.h ****     kStatusGroup_SDHC = 17,                   /*!< Group number for SDHC status code */
  88:../drivers/fsl_common.h ****     kStatusGroup_SDMMC = 18,                  /*!< Group number for SDMMC status code */
  89:../drivers/fsl_common.h ****     kStatusGroup_SAI = 19,                    /*!< Group number for SAI status code */
  90:../drivers/fsl_common.h ****     kStatusGroup_MCG = 20,                    /*!< Group number for MCG status codes. */
  91:../drivers/fsl_common.h ****     kStatusGroup_SCG = 21,                    /*!< Group number for SCG status codes. */
  92:../drivers/fsl_common.h ****     kStatusGroup_SDSPI = 22,                  /*!< Group number for SDSPI status codes. */
  93:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_I2S = 23,             /*!< Group number for FLEXIO I2S status codes */
  94:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_MCULCD = 24,          /*!< Group number for FLEXIO LCD status codes */
  95:../drivers/fsl_common.h ****     kStatusGroup_FLASHIAP = 25,               /*!< Group number for FLASHIAP status codes */
  96:../drivers/fsl_common.h ****     kStatusGroup_FLEXCOMM_I2C = 26,           /*!< Group number for FLEXCOMM I2C status codes */
  97:../drivers/fsl_common.h ****     kStatusGroup_I2S = 27,                    /*!< Group number for I2S status codes */
  98:../drivers/fsl_common.h ****     kStatusGroup_IUART = 28,                  /*!< Group number for IUART status codes */
  99:../drivers/fsl_common.h ****     kStatusGroup_SDRAMC = 35,                 /*!< Group number for SDRAMC status codes. */
 100:../drivers/fsl_common.h ****     kStatusGroup_POWER = 39,                  /*!< Group number for POWER status codes. */
 101:../drivers/fsl_common.h ****     kStatusGroup_ENET = 40,                   /*!< Group number for ENET status codes. */
 102:../drivers/fsl_common.h ****     kStatusGroup_PHY = 41,                    /*!< Group number for PHY status codes. */
 103:../drivers/fsl_common.h ****     kStatusGroup_TRGMUX = 42,                 /*!< Group number for TRGMUX status codes. */
 104:../drivers/fsl_common.h ****     kStatusGroup_SMARTCARD = 43,              /*!< Group number for SMARTCARD status codes. */
 105:../drivers/fsl_common.h ****     kStatusGroup_LMEM = 44,                   /*!< Group number for LMEM status codes. */
 106:../drivers/fsl_common.h ****     kStatusGroup_QSPI = 45,                   /*!< Group number for QSPI status codes. */
 107:../drivers/fsl_common.h ****     kStatusGroup_DMA = 50,                    /*!< Group number for DMA status codes. */
 108:../drivers/fsl_common.h ****     kStatusGroup_EDMA = 51,                   /*!< Group number for EDMA status codes. */
 109:../drivers/fsl_common.h ****     kStatusGroup_DMAMGR = 52,                 /*!< Group number for DMAMGR status codes. */
 110:../drivers/fsl_common.h ****     kStatusGroup_FLEXCAN = 53,                /*!< Group number for FlexCAN status codes. */
 111:../drivers/fsl_common.h ****     kStatusGroup_LTC = 54,                    /*!< Group number for LTC status codes. */
 112:../drivers/fsl_common.h ****     kStatusGroup_FLEXIO_CAMERA = 55,          /*!< Group number for FLEXIO CAMERA status codes. */
 113:../drivers/fsl_common.h ****     kStatusGroup_LPC_SPI = 56,                /*!< Group number for LPC_SPI status codes. */
 114:../drivers/fsl_common.h ****     kStatusGroup_LPC_USART = 57,              /*!< Group number for LPC_USART status codes. */
 115:../drivers/fsl_common.h ****     kStatusGroup_DMIC = 58,                   /*!< Group number for DMIC status codes. */
 116:../drivers/fsl_common.h ****     kStatusGroup_SDIF = 59,                   /*!< Group number for SDIF status codes.*/
 117:../drivers/fsl_common.h ****     kStatusGroup_SPIFI = 60,                  /*!< Group number for SPIFI status codes. */
 118:../drivers/fsl_common.h ****     kStatusGroup_OTP = 61,                    /*!< Group number for OTP status codes. */
 119:../drivers/fsl_common.h ****     kStatusGroup_MCAN = 62,                   /*!< Group number for MCAN status codes. */
 120:../drivers/fsl_common.h ****     kStatusGroup_CAAM = 63,                   /*!< Group number for CAAM status codes. */
 121:../drivers/fsl_common.h ****     kStatusGroup_ECSPI = 64,                  /*!< Group number for ECSPI status codes. */
 122:../drivers/fsl_common.h ****     kStatusGroup_USDHC = 65,                  /*!< Group number for USDHC status codes.*/
 123:../drivers/fsl_common.h ****     kStatusGroup_ESAI = 69,                   /*!< Group number for ESAI status codes. */
 124:../drivers/fsl_common.h ****     kStatusGroup_FLEXSPI = 70,                /*!< Group number for FLEXSPI status codes. */
 125:../drivers/fsl_common.h ****     kStatusGroup_NOTIFIER = 98,               /*!< Group number for NOTIFIER status codes. */
 126:../drivers/fsl_common.h ****     kStatusGroup_DebugConsole = 99,           /*!< Group number for debug console status codes. */
 127:../drivers/fsl_common.h ****     kStatusGroup_ApplicationRangeStart = 100, /*!< Starting number for application groups. */
 128:../drivers/fsl_common.h **** };
 129:../drivers/fsl_common.h **** 
 130:../drivers/fsl_common.h **** /*! @brief Generic status return codes. */
 131:../drivers/fsl_common.h **** enum _generic_status
 132:../drivers/fsl_common.h **** {
 133:../drivers/fsl_common.h ****     kStatus_Success = MAKE_STATUS(kStatusGroup_Generic, 0),
 134:../drivers/fsl_common.h ****     kStatus_Fail = MAKE_STATUS(kStatusGroup_Generic, 1),
 135:../drivers/fsl_common.h ****     kStatus_ReadOnly = MAKE_STATUS(kStatusGroup_Generic, 2),
 136:../drivers/fsl_common.h ****     kStatus_OutOfRange = MAKE_STATUS(kStatusGroup_Generic, 3),
 137:../drivers/fsl_common.h ****     kStatus_InvalidArgument = MAKE_STATUS(kStatusGroup_Generic, 4),
 138:../drivers/fsl_common.h ****     kStatus_Timeout = MAKE_STATUS(kStatusGroup_Generic, 5),
 139:../drivers/fsl_common.h ****     kStatus_NoTransferInProgress = MAKE_STATUS(kStatusGroup_Generic, 6),
 140:../drivers/fsl_common.h **** };
 141:../drivers/fsl_common.h **** 
 142:../drivers/fsl_common.h **** /*! @brief Type used for all status and error return values. */
 143:../drivers/fsl_common.h **** typedef int32_t status_t;
 144:../drivers/fsl_common.h **** 
 145:../drivers/fsl_common.h **** /*
 146:../drivers/fsl_common.h ****  * The fsl_clock.h is included here because it needs MAKE_VERSION/MAKE_STATUS/status_t
 147:../drivers/fsl_common.h ****  * defined in previous of this file.
 148:../drivers/fsl_common.h ****  */
 149:../drivers/fsl_common.h **** #include "fsl_clock.h"
 150:../drivers/fsl_common.h **** 
 151:../drivers/fsl_common.h **** /*
 152:../drivers/fsl_common.h ****  * Chip level peripheral reset API, for MCUs that implement peripheral reset control external to a 
 153:../drivers/fsl_common.h ****  */
 154:../drivers/fsl_common.h **** #if ((defined(FSL_FEATURE_SOC_SYSCON_COUNT) && (FSL_FEATURE_SOC_SYSCON_COUNT > 0)) || \
 155:../drivers/fsl_common.h ****      (defined(FSL_FEATURE_SOC_ASYNC_SYSCON_COUNT) && (FSL_FEATURE_SOC_ASYNC_SYSCON_COUNT > 0)))
 156:../drivers/fsl_common.h **** #include "fsl_reset.h"
 157:../drivers/fsl_common.h **** #endif
 158:../drivers/fsl_common.h **** 
 159:../drivers/fsl_common.h **** /*! @name Min/max macros */
 160:../drivers/fsl_common.h **** /* @{ */
 161:../drivers/fsl_common.h **** #if !defined(MIN)
 162:../drivers/fsl_common.h **** #define MIN(a, b) ((a) < (b) ? (a) : (b))
 163:../drivers/fsl_common.h **** #endif
 164:../drivers/fsl_common.h **** 
 165:../drivers/fsl_common.h **** #if !defined(MAX)
 166:../drivers/fsl_common.h **** #define MAX(a, b) ((a) > (b) ? (a) : (b))
 167:../drivers/fsl_common.h **** #endif
 168:../drivers/fsl_common.h **** /* @} */
 169:../drivers/fsl_common.h **** 
 170:../drivers/fsl_common.h **** /*! @brief Computes the number of elements in an array. */
 171:../drivers/fsl_common.h **** #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
 172:../drivers/fsl_common.h **** 
 173:../drivers/fsl_common.h **** /*! @name UINT16_MAX/UINT32_MAX value */
 174:../drivers/fsl_common.h **** /* @{ */
 175:../drivers/fsl_common.h **** #if !defined(UINT16_MAX)
 176:../drivers/fsl_common.h **** #define UINT16_MAX ((uint16_t)-1)
 177:../drivers/fsl_common.h **** #endif
 178:../drivers/fsl_common.h **** 
 179:../drivers/fsl_common.h **** #if !defined(UINT32_MAX)
 180:../drivers/fsl_common.h **** #define UINT32_MAX ((uint32_t)-1)
 181:../drivers/fsl_common.h **** #endif
 182:../drivers/fsl_common.h **** /* @} */
 183:../drivers/fsl_common.h **** 
 184:../drivers/fsl_common.h **** /*! @name Timer utilities */
 185:../drivers/fsl_common.h **** /* @{ */
 186:../drivers/fsl_common.h **** /*! Macro to convert a microsecond period to raw count value */
 187:../drivers/fsl_common.h **** #define USEC_TO_COUNT(us, clockFreqInHz) (uint64_t)((uint64_t)us * clockFreqInHz / 1000000U)
 188:../drivers/fsl_common.h **** /*! Macro to convert a raw count value to microsecond */
 189:../drivers/fsl_common.h **** #define COUNT_TO_USEC(count, clockFreqInHz) (uint64_t)((uint64_t)count * 1000000U / clockFreqInHz)
 190:../drivers/fsl_common.h **** 
 191:../drivers/fsl_common.h **** /*! Macro to convert a millisecond period to raw count value */
 192:../drivers/fsl_common.h **** #define MSEC_TO_COUNT(ms, clockFreqInHz) (uint64_t)((uint64_t)ms * clockFreqInHz / 1000U)
 193:../drivers/fsl_common.h **** /*! Macro to convert a raw count value to millisecond */
 194:../drivers/fsl_common.h **** #define COUNT_TO_MSEC(count, clockFreqInHz) (uint64_t)((uint64_t)count * 1000U / clockFreqInHz)
 195:../drivers/fsl_common.h **** /* @} */
 196:../drivers/fsl_common.h **** 
 197:../drivers/fsl_common.h **** /*******************************************************************************
 198:../drivers/fsl_common.h ****  * API
 199:../drivers/fsl_common.h ****  ******************************************************************************/
 200:../drivers/fsl_common.h **** 
 201:../drivers/fsl_common.h **** #if defined(__cplusplus)
 202:../drivers/fsl_common.h **** extern "C" {
 203:../drivers/fsl_common.h **** #endif
 204:../drivers/fsl_common.h **** 
 205:../drivers/fsl_common.h **** /*!
 206:../drivers/fsl_common.h ****  * @brief Enable specific interrupt.
 207:../drivers/fsl_common.h ****  *
 208:../drivers/fsl_common.h ****  * Enable the interrupt not routed from intmux.
 209:../drivers/fsl_common.h ****  *
 210:../drivers/fsl_common.h ****  * @param interrupt The IRQ number.
 211:../drivers/fsl_common.h ****  */
 212:../drivers/fsl_common.h **** static inline void EnableIRQ(IRQn_Type interrupt)
 213:../drivers/fsl_common.h **** {
 196              		.loc 3 213 1
 197              		.cfi_startproc
 198              		@ args = 0, pretend = 0, frame = 8
 199              		@ frame_needed = 1, uses_anonymous_args = 0
 200 0000 80B5     		push	{r7, lr}
 201              		.cfi_def_cfa_offset 8
 202              		.cfi_offset 7, -8
 203              		.cfi_offset 14, -4
 204 0002 82B0     		sub	sp, sp, #8
 205              		.cfi_def_cfa_offset 16
 206 0004 00AF     		add	r7, sp, #0
 207              		.cfi_def_cfa_register 7
 208 0006 0200     		movs	r2, r0
 209 0008 FB1D     		adds	r3, r7, #7
 210 000a 1A70     		strb	r2, [r3]
 214:../drivers/fsl_common.h ****     if (NotAvail_IRQn == interrupt)
 211              		.loc 3 214 8
 212 000c FB1D     		adds	r3, r7, #7
 213 000e 1B78     		ldrb	r3, [r3]
 214 0010 5BB2     		sxtb	r3, r3
 215 0012 8033     		adds	r3, r3, #128
 216 0014 06D0     		beq	.L13
 215:../drivers/fsl_common.h ****     {
 216:../drivers/fsl_common.h ****         return;
 217:../drivers/fsl_common.h ****     }
 218:../drivers/fsl_common.h **** 
 219:../drivers/fsl_common.h **** #if defined(FSL_FEATURE_SOC_INTMUX_COUNT) && (FSL_FEATURE_SOC_INTMUX_COUNT > 0)
 220:../drivers/fsl_common.h ****     if (interrupt < FSL_FEATURE_INTMUX_IRQ_START_INDEX)
 221:../drivers/fsl_common.h **** #endif
 222:../drivers/fsl_common.h ****     {
 223:../drivers/fsl_common.h **** #if defined(__GIC_PRIO_BITS)
 224:../drivers/fsl_common.h ****         GIC_EnableIRQ(interrupt);
 225:../drivers/fsl_common.h **** #else
 226:../drivers/fsl_common.h ****         NVIC_EnableIRQ(interrupt);
 217              		.loc 3 226 9
 218 0016 FB1D     		adds	r3, r7, #7
 219 0018 1B78     		ldrb	r3, [r3]
 220 001a 5BB2     		sxtb	r3, r3
 221 001c 1800     		movs	r0, r3
 222 001e FFF7FEFF 		bl	NVIC_EnableIRQ
 223 0022 00E0     		b	.L10
 224              	.L13:
 216:../drivers/fsl_common.h ****     }
 225              		.loc 3 216 9
 226 0024 C046     		nop
 227              	.L10:
 227:../drivers/fsl_common.h **** #endif
 228:../drivers/fsl_common.h ****     }
 229:../drivers/fsl_common.h **** }
 228              		.loc 3 229 1
 229 0026 BD46     		mov	sp, r7
 230 0028 02B0     		add	sp, sp, #8
 231              		@ sp needed
 232 002a 80BD     		pop	{r7, pc}
 233              		.cfi_endproc
 234              	.LFE52:
 236              		.section	.bss.s_uartHandle,"aw",%nobits
 237              		.align	2
 240              	s_uartHandle:
 241 0000 00000000 		.space	12
 241      00000000 
 241      00000000 
 242              		.section	.rodata.s_uartBases,"a"
 243              		.align	2
 246              	s_uartBases:
 247 0000 00000000 		.word	0
 248 0004 00B00640 		.word	1074180096
 249 0008 00C00640 		.word	1074184192
 250              		.section	.rodata.s_uartIRQ,"a"
 251              		.align	2
 254              	s_uartIRQ:
 255 0000 80       		.byte	-128
 256 0001 0D       		.byte	13
 257 0002 0E       		.byte	14
 258              		.section	.rodata.s_uartClock,"a"
 259              		.align	2
 262              	s_uartClock:
 263 0000 00000000 		.word	0
 264 0004 0B003410 		.word	271843339
 265 0008 0C003410 		.word	271843340
 266              		.section	.bss.s_uartIsr,"aw",%nobits
 267              		.align	2
 270              	s_uartIsr:
 271 0000 00000000 		.space	4
 272              		.section	.rodata.UART_GetInstance.str1.4,"aMS",%progbits,1
 273              		.align	2
 274              	.LC1:
 275 0000 2E66736C 		.ascii	".fsl_uart.c:169 : instance < uartArrayCount\000"
 275      5F756172 
 275      742E633A 
 275      31363920 
 275      3A20696E 
 276              		.section	.text.UART_GetInstance,"ax",%progbits
 277              		.align	1
 278              		.global	UART_GetInstance
 279              		.syntax unified
 280              		.code	16
 281              		.thumb_func
 282              		.fpu softvfp
 284              	UART_GetInstance:
 285              	.LFB63:
 286              		.file 4 "../drivers/fsl_uart.c"
   1:../drivers/fsl_uart.c **** /*
   2:../drivers/fsl_uart.c ****  * Copyright (c) 2015-2016, Freescale Semiconductor, Inc.
   3:../drivers/fsl_uart.c ****  * Copyright 2016-2017 NXP
   4:../drivers/fsl_uart.c ****  *
   5:../drivers/fsl_uart.c ****  * Redistribution and use in source and binary forms, with or without modification,
   6:../drivers/fsl_uart.c ****  * are permitted provided that the following conditions are met:
   7:../drivers/fsl_uart.c ****  *
   8:../drivers/fsl_uart.c ****  * o Redistributions of source code must retain the above copyright notice, this list
   9:../drivers/fsl_uart.c ****  *   of conditions and the following disclaimer.
  10:../drivers/fsl_uart.c ****  *
  11:../drivers/fsl_uart.c ****  * o Redistributions in binary form must reproduce the above copyright notice, this
  12:../drivers/fsl_uart.c ****  *   list of conditions and the following disclaimer in the documentation and/or
  13:../drivers/fsl_uart.c ****  *   other materials provided with the distribution.
  14:../drivers/fsl_uart.c ****  *
  15:../drivers/fsl_uart.c ****  * o Neither the name of the copyright holder nor the names of its
  16:../drivers/fsl_uart.c ****  *   contributors may be used to endorse or promote products derived from this
  17:../drivers/fsl_uart.c ****  *   software without specific prior written permission.
  18:../drivers/fsl_uart.c ****  *
  19:../drivers/fsl_uart.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  20:../drivers/fsl_uart.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  21:../drivers/fsl_uart.c ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  22:../drivers/fsl_uart.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  23:../drivers/fsl_uart.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  24:../drivers/fsl_uart.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  25:../drivers/fsl_uart.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  26:../drivers/fsl_uart.c ****  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27:../drivers/fsl_uart.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  28:../drivers/fsl_uart.c ****  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29:../drivers/fsl_uart.c ****  */
  30:../drivers/fsl_uart.c **** 
  31:../drivers/fsl_uart.c **** #include "fsl_uart.h"
  32:../drivers/fsl_uart.c **** 
  33:../drivers/fsl_uart.c **** /*******************************************************************************
  34:../drivers/fsl_uart.c ****  * Definitions
  35:../drivers/fsl_uart.c ****  ******************************************************************************/
  36:../drivers/fsl_uart.c **** 
  37:../drivers/fsl_uart.c **** /* UART transfer state. */
  38:../drivers/fsl_uart.c **** enum _uart_tansfer_states
  39:../drivers/fsl_uart.c **** {
  40:../drivers/fsl_uart.c ****     kUART_TxIdle,         /* TX idle. */
  41:../drivers/fsl_uart.c ****     kUART_TxBusy,         /* TX busy. */
  42:../drivers/fsl_uart.c ****     kUART_RxIdle,         /* RX idle. */
  43:../drivers/fsl_uart.c ****     kUART_RxBusy,         /* RX busy. */
  44:../drivers/fsl_uart.c ****     kUART_RxFramingError, /* Rx framing error */
  45:../drivers/fsl_uart.c ****     kUART_RxParityError   /* Rx parity error */
  46:../drivers/fsl_uart.c **** };
  47:../drivers/fsl_uart.c **** 
  48:../drivers/fsl_uart.c **** /* Typedef for interrupt handler. */
  49:../drivers/fsl_uart.c **** typedef void (*uart_isr_t)(UART_Type *base, uart_handle_t *handle);
  50:../drivers/fsl_uart.c **** 
  51:../drivers/fsl_uart.c **** /*******************************************************************************
  52:../drivers/fsl_uart.c ****  * Prototypes
  53:../drivers/fsl_uart.c ****  ******************************************************************************/
  54:../drivers/fsl_uart.c **** 
  55:../drivers/fsl_uart.c **** /*!
  56:../drivers/fsl_uart.c ****  * @brief Get the UART instance from peripheral base address.
  57:../drivers/fsl_uart.c ****  *
  58:../drivers/fsl_uart.c ****  * @param base UART peripheral base address.
  59:../drivers/fsl_uart.c ****  * @return UART instance.
  60:../drivers/fsl_uart.c ****  */
  61:../drivers/fsl_uart.c **** uint32_t UART_GetInstance(UART_Type *base);
  62:../drivers/fsl_uart.c **** 
  63:../drivers/fsl_uart.c **** /*!
  64:../drivers/fsl_uart.c ****  * @brief Get the length of received data in RX ring buffer.
  65:../drivers/fsl_uart.c ****  *
  66:../drivers/fsl_uart.c ****  * @param handle UART handle pointer.
  67:../drivers/fsl_uart.c ****  * @return Length of received data in RX ring buffer.
  68:../drivers/fsl_uart.c ****  */
  69:../drivers/fsl_uart.c **** static size_t UART_TransferGetRxRingBufferLength(uart_handle_t *handle);
  70:../drivers/fsl_uart.c **** 
  71:../drivers/fsl_uart.c **** /*!
  72:../drivers/fsl_uart.c ****  * @brief Check whether the RX ring buffer is full.
  73:../drivers/fsl_uart.c ****  *
  74:../drivers/fsl_uart.c ****  * @param handle UART handle pointer.
  75:../drivers/fsl_uart.c ****  * @retval true  RX ring buffer is full.
  76:../drivers/fsl_uart.c ****  * @retval false RX ring buffer is not full.
  77:../drivers/fsl_uart.c ****  */
  78:../drivers/fsl_uart.c **** static bool UART_TransferIsRxRingBufferFull(uart_handle_t *handle);
  79:../drivers/fsl_uart.c **** 
  80:../drivers/fsl_uart.c **** /*!
  81:../drivers/fsl_uart.c ****  * @brief Read RX register using non-blocking method.
  82:../drivers/fsl_uart.c ****  *
  83:../drivers/fsl_uart.c ****  * This function reads data from the TX register directly, upper layer must make
  84:../drivers/fsl_uart.c ****  * sure the RX register is full or TX FIFO has data before calling this function.
  85:../drivers/fsl_uart.c ****  *
  86:../drivers/fsl_uart.c ****  * @param base UART peripheral base address.
  87:../drivers/fsl_uart.c ****  * @param data Start addresss of the buffer to store the received data.
  88:../drivers/fsl_uart.c ****  * @param length Size of the buffer.
  89:../drivers/fsl_uart.c ****  */
  90:../drivers/fsl_uart.c **** static void UART_ReadNonBlocking(UART_Type *base, uint8_t *data, size_t length);
  91:../drivers/fsl_uart.c **** 
  92:../drivers/fsl_uart.c **** /*!
  93:../drivers/fsl_uart.c ****  * @brief Write to TX register using non-blocking method.
  94:../drivers/fsl_uart.c ****  *
  95:../drivers/fsl_uart.c ****  * This function writes data to the TX register directly, upper layer must make
  96:../drivers/fsl_uart.c ****  * sure the TX register is empty or TX FIFO has empty room before calling this function.
  97:../drivers/fsl_uart.c ****  *
  98:../drivers/fsl_uart.c ****  * @note This function does not check whether all the data has been sent out to bus,
  99:../drivers/fsl_uart.c ****  * so before disable TX, check kUART_TransmissionCompleteFlag to ensure the TX is
 100:../drivers/fsl_uart.c ****  * finished.
 101:../drivers/fsl_uart.c ****  *
 102:../drivers/fsl_uart.c ****  * @param base UART peripheral base address.
 103:../drivers/fsl_uart.c ****  * @param data Start addresss of the data to write.
 104:../drivers/fsl_uart.c ****  * @param length Size of the buffer to be sent.
 105:../drivers/fsl_uart.c ****  */
 106:../drivers/fsl_uart.c **** static void UART_WriteNonBlocking(UART_Type *base, const uint8_t *data, size_t length);
 107:../drivers/fsl_uart.c **** 
 108:../drivers/fsl_uart.c **** /*******************************************************************************
 109:../drivers/fsl_uart.c ****  * Variables
 110:../drivers/fsl_uart.c ****  ******************************************************************************/
 111:../drivers/fsl_uart.c **** /* Array of UART handle. */
 112:../drivers/fsl_uart.c **** #if (defined(UART5))
 113:../drivers/fsl_uart.c **** #define UART_HANDLE_ARRAY_SIZE 6
 114:../drivers/fsl_uart.c **** #else /* UART5 */
 115:../drivers/fsl_uart.c **** #if (defined(UART4))
 116:../drivers/fsl_uart.c **** #define UART_HANDLE_ARRAY_SIZE 5
 117:../drivers/fsl_uart.c **** #else /* UART4 */
 118:../drivers/fsl_uart.c **** #if (defined(UART3))
 119:../drivers/fsl_uart.c **** #define UART_HANDLE_ARRAY_SIZE 4
 120:../drivers/fsl_uart.c **** #else /* UART3 */
 121:../drivers/fsl_uart.c **** #if (defined(UART2))
 122:../drivers/fsl_uart.c **** #define UART_HANDLE_ARRAY_SIZE 3
 123:../drivers/fsl_uart.c **** #else /* UART2 */
 124:../drivers/fsl_uart.c **** #if (defined(UART1))
 125:../drivers/fsl_uart.c **** #define UART_HANDLE_ARRAY_SIZE 2
 126:../drivers/fsl_uart.c **** #else /* UART1 */
 127:../drivers/fsl_uart.c **** #if (defined(UART0))
 128:../drivers/fsl_uart.c **** #define UART_HANDLE_ARRAY_SIZE 1
 129:../drivers/fsl_uart.c **** #else /* UART0 */
 130:../drivers/fsl_uart.c **** #error No UART instance.
 131:../drivers/fsl_uart.c **** #endif /* UART 0 */
 132:../drivers/fsl_uart.c **** #endif /* UART 1 */
 133:../drivers/fsl_uart.c **** #endif /* UART 2 */
 134:../drivers/fsl_uart.c **** #endif /* UART 3 */
 135:../drivers/fsl_uart.c **** #endif /* UART 4 */
 136:../drivers/fsl_uart.c **** #endif /* UART 5 */
 137:../drivers/fsl_uart.c **** static uart_handle_t *s_uartHandle[UART_HANDLE_ARRAY_SIZE];
 138:../drivers/fsl_uart.c **** /* Array of UART peripheral base address. */
 139:../drivers/fsl_uart.c **** static UART_Type *const s_uartBases[] = UART_BASE_PTRS;
 140:../drivers/fsl_uart.c **** 
 141:../drivers/fsl_uart.c **** /* Array of UART IRQ number. */
 142:../drivers/fsl_uart.c **** static const IRQn_Type s_uartIRQ[] = UART_RX_TX_IRQS;
 143:../drivers/fsl_uart.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 144:../drivers/fsl_uart.c **** /* Array of UART clock name. */
 145:../drivers/fsl_uart.c **** static const clock_ip_name_t s_uartClock[] = UART_CLOCKS;
 146:../drivers/fsl_uart.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 147:../drivers/fsl_uart.c **** 
 148:../drivers/fsl_uart.c **** /* UART ISR for transactional APIs. */
 149:../drivers/fsl_uart.c **** static uart_isr_t s_uartIsr;
 150:../drivers/fsl_uart.c **** 
 151:../drivers/fsl_uart.c **** /*******************************************************************************
 152:../drivers/fsl_uart.c ****  * Code
 153:../drivers/fsl_uart.c ****  ******************************************************************************/
 154:../drivers/fsl_uart.c **** 
 155:../drivers/fsl_uart.c **** uint32_t UART_GetInstance(UART_Type *base)
 156:../drivers/fsl_uart.c **** {
 287              		.loc 4 156 1
 288              		.cfi_startproc
 289              		@ args = 0, pretend = 0, frame = 16
 290              		@ frame_needed = 1, uses_anonymous_args = 0
 291 0000 80B5     		push	{r7, lr}
 292              		.cfi_def_cfa_offset 8
 293              		.cfi_offset 7, -8
 294              		.cfi_offset 14, -4
 295 0002 84B0     		sub	sp, sp, #16
 296              		.cfi_def_cfa_offset 24
 297 0004 00AF     		add	r7, sp, #0
 298              		.cfi_def_cfa_register 7
 299 0006 7860     		str	r0, [r7, #4]
 157:../drivers/fsl_uart.c ****     uint32_t instance;
 158:../drivers/fsl_uart.c ****     uint32_t uartArrayCount = (sizeof(s_uartBases) / sizeof(s_uartBases[0]));
 300              		.loc 4 158 14
 301 0008 0323     		movs	r3, #3
 302 000a BB60     		str	r3, [r7, #8]
 159:../drivers/fsl_uart.c **** 
 160:../drivers/fsl_uart.c ****     /* Find the instance index from base address mappings. */
 161:../drivers/fsl_uart.c ****     for (instance = 0; instance < uartArrayCount; instance++)
 303              		.loc 4 161 19
 304 000c 0023     		movs	r3, #0
 305 000e FB60     		str	r3, [r7, #12]
 306              		.loc 4 161 5
 307 0010 09E0     		b	.L15
 308              	.L18:
 162:../drivers/fsl_uart.c ****     {
 163:../drivers/fsl_uart.c ****         if (s_uartBases[instance] == base)
 309              		.loc 4 163 24
 310 0012 0E4B     		ldr	r3, .L22
 311 0014 FA68     		ldr	r2, [r7, #12]
 312 0016 9200     		lsls	r2, r2, #2
 313 0018 D358     		ldr	r3, [r2, r3]
 314              		.loc 4 163 12
 315 001a 7A68     		ldr	r2, [r7, #4]
 316 001c 9A42     		cmp	r2, r3
 317 001e 07D0     		beq	.L21
 161:../drivers/fsl_uart.c ****     {
 318              		.loc 4 161 59 discriminator 2
 319 0020 FB68     		ldr	r3, [r7, #12]
 320 0022 0133     		adds	r3, r3, #1
 321 0024 FB60     		str	r3, [r7, #12]
 322              	.L15:
 161:../drivers/fsl_uart.c ****     {
 323              		.loc 4 161 5 discriminator 1
 324 0026 FA68     		ldr	r2, [r7, #12]
 325 0028 BB68     		ldr	r3, [r7, #8]
 326 002a 9A42     		cmp	r2, r3
 327 002c F1D3     		bcc	.L18
 328 002e 00E0     		b	.L17
 329              	.L21:
 164:../drivers/fsl_uart.c ****         {
 165:../drivers/fsl_uart.c ****             break;
 330              		.loc 4 165 13
 331 0030 C046     		nop
 332              	.L17:
 166:../drivers/fsl_uart.c ****         }
 167:../drivers/fsl_uart.c ****     }
 168:../drivers/fsl_uart.c **** 
 169:../drivers/fsl_uart.c ****     assert(instance < uartArrayCount);
 333              		.loc 4 169 5
 334 0032 FA68     		ldr	r2, [r7, #12]
 335 0034 BB68     		ldr	r3, [r7, #8]
 336 0036 9A42     		cmp	r2, r3
 337 0038 03D3     		bcc	.L19
 338              		.loc 4 169 5 is_stmt 0 discriminator 1
 339 003a 054B     		ldr	r3, .L22+4
 340 003c 1800     		movs	r0, r3
 341 003e FFF7FEFF 		bl	__assertion_failed
 342              	.L19:
 170:../drivers/fsl_uart.c **** 
 171:../drivers/fsl_uart.c ****     return instance;
 343              		.loc 4 171 12 is_stmt 1
 344 0042 FB68     		ldr	r3, [r7, #12]
 172:../drivers/fsl_uart.c **** }
 345              		.loc 4 172 1
 346 0044 1800     		movs	r0, r3
 347 0046 BD46     		mov	sp, r7
 348 0048 04B0     		add	sp, sp, #16
 349              		@ sp needed
 350 004a 80BD     		pop	{r7, pc}
 351              	.L23:
 352              		.align	2
 353              	.L22:
 354 004c 00000000 		.word	s_uartBases
 355 0050 00000000 		.word	.LC1
 356              		.cfi_endproc
 357              	.LFE63:
 359              		.section	.rodata.UART_TransferGetRxRingBufferLength.str1.4,"aMS",%progbits,1
 360              		.align	2
 361              	.LC3:
 362 0000 2E66736C 		.ascii	".fsl_uart.c:176 : handle\000"
 362      5F756172 
 362      742E633A 
 362      31373620 
 362      3A206861 
 363              		.section	.text.UART_TransferGetRxRingBufferLength,"ax",%progbits
 364              		.align	1
 365              		.syntax unified
 366              		.code	16
 367              		.thumb_func
 368              		.fpu softvfp
 370              	UART_TransferGetRxRingBufferLength:
 371              	.LFB64:
 173:../drivers/fsl_uart.c **** 
 174:../drivers/fsl_uart.c **** static size_t UART_TransferGetRxRingBufferLength(uart_handle_t *handle)
 175:../drivers/fsl_uart.c **** {
 372              		.loc 4 175 1
 373              		.cfi_startproc
 374              		@ args = 0, pretend = 0, frame = 16
 375              		@ frame_needed = 1, uses_anonymous_args = 0
 376 0000 80B5     		push	{r7, lr}
 377              		.cfi_def_cfa_offset 8
 378              		.cfi_offset 7, -8
 379              		.cfi_offset 14, -4
 380 0002 84B0     		sub	sp, sp, #16
 381              		.cfi_def_cfa_offset 24
 382 0004 00AF     		add	r7, sp, #0
 383              		.cfi_def_cfa_register 7
 384 0006 7860     		str	r0, [r7, #4]
 176:../drivers/fsl_uart.c ****     assert(handle);
 385              		.loc 4 176 5
 386 0008 7B68     		ldr	r3, [r7, #4]
 387 000a 002B     		cmp	r3, #0
 388 000c 03D1     		bne	.L25
 389              		.loc 4 176 5 is_stmt 0 discriminator 1
 390 000e 134B     		ldr	r3, .L29
 391 0010 1800     		movs	r0, r3
 392 0012 FFF7FEFF 		bl	__assertion_failed
 393              	.L25:
 177:../drivers/fsl_uart.c **** 
 178:../drivers/fsl_uart.c ****     size_t size;
 179:../drivers/fsl_uart.c **** 
 180:../drivers/fsl_uart.c ****     if (handle->rxRingBufferTail > handle->rxRingBufferHead)
 394              		.loc 4 180 15 is_stmt 1
 395 0016 7B68     		ldr	r3, [r7, #4]
 396 0018 5B8C     		ldrh	r3, [r3, #34]
 397 001a 9AB2     		uxth	r2, r3
 398              		.loc 4 180 42
 399 001c 7B68     		ldr	r3, [r7, #4]
 400 001e 1B8C     		ldrh	r3, [r3, #32]
 401 0020 9BB2     		uxth	r3, r3
 402              		.loc 4 180 8
 403 0022 9A42     		cmp	r2, r3
 404 0024 0CD9     		bls	.L26
 181:../drivers/fsl_uart.c ****     {
 182:../drivers/fsl_uart.c ****         size = (size_t)(handle->rxRingBufferHead + handle->rxRingBufferSize - handle->rxRingBufferT
 405              		.loc 4 182 31
 406 0026 7B68     		ldr	r3, [r7, #4]
 407 0028 1B8C     		ldrh	r3, [r3, #32]
 408 002a 9BB2     		uxth	r3, r3
 409 002c 1A00     		movs	r2, r3
 410              		.loc 4 182 58
 411 002e 7B68     		ldr	r3, [r7, #4]
 412 0030 DB69     		ldr	r3, [r3, #28]
 413              		.loc 4 182 50
 414 0032 D318     		adds	r3, r2, r3
 415              		.loc 4 182 85
 416 0034 7A68     		ldr	r2, [r7, #4]
 417 0036 528C     		ldrh	r2, [r2, #34]
 418 0038 92B2     		uxth	r2, r2
 419              		.loc 4 182 14
 420 003a 9B1A     		subs	r3, r3, r2
 421 003c FB60     		str	r3, [r7, #12]
 422 003e 08E0     		b	.L27
 423              	.L26:
 183:../drivers/fsl_uart.c ****     }
 184:../drivers/fsl_uart.c ****     else
 185:../drivers/fsl_uart.c ****     {
 186:../drivers/fsl_uart.c ****         size = (size_t)(handle->rxRingBufferHead - handle->rxRingBufferTail);
 424              		.loc 4 186 31
 425 0040 7B68     		ldr	r3, [r7, #4]
 426 0042 1B8C     		ldrh	r3, [r3, #32]
 427 0044 9BB2     		uxth	r3, r3
 428 0046 1A00     		movs	r2, r3
 429              		.loc 4 186 58
 430 0048 7B68     		ldr	r3, [r7, #4]
 431 004a 5B8C     		ldrh	r3, [r3, #34]
 432 004c 9BB2     		uxth	r3, r3
 433              		.loc 4 186 50
 434 004e D31A     		subs	r3, r2, r3
 435              		.loc 4 186 14
 436 0050 FB60     		str	r3, [r7, #12]
 437              	.L27:
 187:../drivers/fsl_uart.c ****     }
 188:../drivers/fsl_uart.c **** 
 189:../drivers/fsl_uart.c ****     return size;
 438              		.loc 4 189 12
 439 0052 FB68     		ldr	r3, [r7, #12]
 190:../drivers/fsl_uart.c **** }
 440              		.loc 4 190 1
 441 0054 1800     		movs	r0, r3
 442 0056 BD46     		mov	sp, r7
 443 0058 04B0     		add	sp, sp, #16
 444              		@ sp needed
 445 005a 80BD     		pop	{r7, pc}
 446              	.L30:
 447              		.align	2
 448              	.L29:
 449 005c 00000000 		.word	.LC3
 450              		.cfi_endproc
 451              	.LFE64:
 453              		.section	.rodata.UART_TransferIsRxRingBufferFull.str1.4,"aMS",%progbits,1
 454              		.align	2
 455              	.LC5:
 456 0000 2E66736C 		.ascii	".fsl_uart.c:194 : handle\000"
 456      5F756172 
 456      742E633A 
 456      31393420 
 456      3A206861 
 457              		.section	.text.UART_TransferIsRxRingBufferFull,"ax",%progbits
 458              		.align	1
 459              		.syntax unified
 460              		.code	16
 461              		.thumb_func
 462              		.fpu softvfp
 464              	UART_TransferIsRxRingBufferFull:
 465              	.LFB65:
 191:../drivers/fsl_uart.c **** 
 192:../drivers/fsl_uart.c **** static bool UART_TransferIsRxRingBufferFull(uart_handle_t *handle)
 193:../drivers/fsl_uart.c **** {
 466              		.loc 4 193 1
 467              		.cfi_startproc
 468              		@ args = 0, pretend = 0, frame = 16
 469              		@ frame_needed = 1, uses_anonymous_args = 0
 470 0000 80B5     		push	{r7, lr}
 471              		.cfi_def_cfa_offset 8
 472              		.cfi_offset 7, -8
 473              		.cfi_offset 14, -4
 474 0002 84B0     		sub	sp, sp, #16
 475              		.cfi_def_cfa_offset 24
 476 0004 00AF     		add	r7, sp, #0
 477              		.cfi_def_cfa_register 7
 478 0006 7860     		str	r0, [r7, #4]
 194:../drivers/fsl_uart.c ****     assert(handle);
 479              		.loc 4 194 5
 480 0008 7B68     		ldr	r3, [r7, #4]
 481 000a 002B     		cmp	r3, #0
 482 000c 03D1     		bne	.L32
 483              		.loc 4 194 5 is_stmt 0 discriminator 1
 484 000e 0F4B     		ldr	r3, .L36
 485 0010 1800     		movs	r0, r3
 486 0012 FFF7FEFF 		bl	__assertion_failed
 487              	.L32:
 195:../drivers/fsl_uart.c **** 
 196:../drivers/fsl_uart.c ****     bool full;
 197:../drivers/fsl_uart.c **** 
 198:../drivers/fsl_uart.c ****     if (UART_TransferGetRxRingBufferLength(handle) == (handle->rxRingBufferSize - 1U))
 488              		.loc 4 198 9 is_stmt 1
 489 0016 7B68     		ldr	r3, [r7, #4]
 490 0018 1800     		movs	r0, r3
 491 001a FFF7FEFF 		bl	UART_TransferGetRxRingBufferLength
 492 001e 0200     		movs	r2, r0
 493              		.loc 4 198 62
 494 0020 7B68     		ldr	r3, [r7, #4]
 495 0022 DB69     		ldr	r3, [r3, #28]
 496              		.loc 4 198 81
 497 0024 013B     		subs	r3, r3, #1
 498              		.loc 4 198 8
 499 0026 9A42     		cmp	r2, r3
 500 0028 04D1     		bne	.L33
 199:../drivers/fsl_uart.c ****     {
 200:../drivers/fsl_uart.c ****         full = true;
 501              		.loc 4 200 14
 502 002a 0F23     		movs	r3, #15
 503 002c FB18     		adds	r3, r7, r3
 504 002e 0122     		movs	r2, #1
 505 0030 1A70     		strb	r2, [r3]
 506 0032 03E0     		b	.L34
 507              	.L33:
 201:../drivers/fsl_uart.c ****     }
 202:../drivers/fsl_uart.c ****     else
 203:../drivers/fsl_uart.c ****     {
 204:../drivers/fsl_uart.c ****         full = false;
 508              		.loc 4 204 14
 509 0034 0F23     		movs	r3, #15
 510 0036 FB18     		adds	r3, r7, r3
 511 0038 0022     		movs	r2, #0
 512 003a 1A70     		strb	r2, [r3]
 513              	.L34:
 205:../drivers/fsl_uart.c ****     }
 206:../drivers/fsl_uart.c **** 
 207:../drivers/fsl_uart.c ****     return full;
 514              		.loc 4 207 12
 515 003c 0F23     		movs	r3, #15
 516 003e FB18     		adds	r3, r7, r3
 517 0040 1B78     		ldrb	r3, [r3]
 208:../drivers/fsl_uart.c **** }
 518              		.loc 4 208 1
 519 0042 1800     		movs	r0, r3
 520 0044 BD46     		mov	sp, r7
 521 0046 04B0     		add	sp, sp, #16
 522              		@ sp needed
 523 0048 80BD     		pop	{r7, pc}
 524              	.L37:
 525 004a C046     		.align	2
 526              	.L36:
 527 004c 00000000 		.word	.LC5
 528              		.cfi_endproc
 529              	.LFE65:
 531              		.section	.rodata.UART_Init.str1.4,"aMS",%progbits,1
 532              		.align	2
 533              	.LC7:
 534 0000 2E66736C 		.ascii	".fsl_uart.c:212 : config\000"
 534      5F756172 
 534      742E633A 
 534      32313220 
 534      3A20636F 
 535 0019 000000   		.align	2
 536              	.LC9:
 537 001c 2E66736C 		.ascii	".fsl_uart.c:213 : config->baudRate_Bps\000"
 537      5F756172 
 537      742E633A 
 537      32313320 
 537      3A20636F 
 538              		.global	__aeabi_uidiv
 539              		.section	.text.UART_Init,"ax",%progbits
 540              		.align	1
 541              		.global	UART_Init
 542              		.syntax unified
 543              		.code	16
 544              		.thumb_func
 545              		.fpu softvfp
 547              	UART_Init:
 548              	.LFB66:
 209:../drivers/fsl_uart.c **** 
 210:../drivers/fsl_uart.c **** status_t UART_Init(UART_Type *base, const uart_config_t *config, uint32_t srcClock_Hz)
 211:../drivers/fsl_uart.c **** {
 549              		.loc 4 211 1
 550              		.cfi_startproc
 551              		@ args = 0, pretend = 0, frame = 24
 552              		@ frame_needed = 1, uses_anonymous_args = 0
 553 0000 B0B5     		push	{r4, r5, r7, lr}
 554              		.cfi_def_cfa_offset 16
 555              		.cfi_offset 4, -16
 556              		.cfi_offset 5, -12
 557              		.cfi_offset 7, -8
 558              		.cfi_offset 14, -4
 559 0002 86B0     		sub	sp, sp, #24
 560              		.cfi_def_cfa_offset 40
 561 0004 00AF     		add	r7, sp, #0
 562              		.cfi_def_cfa_register 7
 563 0006 F860     		str	r0, [r7, #12]
 564 0008 B960     		str	r1, [r7, #8]
 565 000a 7A60     		str	r2, [r7, #4]
 212:../drivers/fsl_uart.c ****     assert(config);
 566              		.loc 4 212 5
 567 000c BB68     		ldr	r3, [r7, #8]
 568 000e 002B     		cmp	r3, #0
 569 0010 03D1     		bne	.L39
 570              		.loc 4 212 5 is_stmt 0 discriminator 1
 571 0012 6F4B     		ldr	r3, .L48
 572 0014 1800     		movs	r0, r3
 573 0016 FFF7FEFF 		bl	__assertion_failed
 574              	.L39:
 213:../drivers/fsl_uart.c ****     assert(config->baudRate_Bps);
 575              		.loc 4 213 5 is_stmt 1
 576 001a BB68     		ldr	r3, [r7, #8]
 577 001c 1B68     		ldr	r3, [r3]
 578 001e 002B     		cmp	r3, #0
 579 0020 03D1     		bne	.L40
 580              		.loc 4 213 5 is_stmt 0 discriminator 1
 581 0022 6C4B     		ldr	r3, .L48+4
 582 0024 1800     		movs	r0, r3
 583 0026 FFF7FEFF 		bl	__assertion_failed
 584              	.L40:
 214:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
 215:../drivers/fsl_uart.c ****     assert(FSL_FEATURE_UART_FIFO_SIZEn(base) >= config->txFifoWatermark);
 216:../drivers/fsl_uart.c ****     assert(FSL_FEATURE_UART_FIFO_SIZEn(base) >= config->rxFifoWatermark);
 217:../drivers/fsl_uart.c **** #endif
 218:../drivers/fsl_uart.c **** 
 219:../drivers/fsl_uart.c ****     uint16_t sbr = 0;
 585              		.loc 4 219 14 is_stmt 1
 586 002a 1624     		movs	r4, #22
 587 002c 3B19     		adds	r3, r7, r4
 588 002e 0022     		movs	r2, #0
 589 0030 1A80     		strh	r2, [r3]
 220:../drivers/fsl_uart.c ****     uint8_t temp = 0;
 590              		.loc 4 220 13
 591 0032 1523     		movs	r3, #21
 592 0034 FB18     		adds	r3, r7, r3
 593 0036 0022     		movs	r2, #0
 594 0038 1A70     		strb	r2, [r3]
 221:../drivers/fsl_uart.c ****     uint32_t baudDiff = 0;
 595              		.loc 4 221 14
 596 003a 0023     		movs	r3, #0
 597 003c 3B61     		str	r3, [r7, #16]
 222:../drivers/fsl_uart.c **** 
 223:../drivers/fsl_uart.c ****     /* Calculate the baud rate modulo divisor, sbr*/
 224:../drivers/fsl_uart.c ****     sbr = srcClock_Hz / (config->baudRate_Bps * 16);
 598              		.loc 4 224 32
 599 003e BB68     		ldr	r3, [r7, #8]
 600 0040 1B68     		ldr	r3, [r3]
 601              		.loc 4 224 47
 602 0042 1B01     		lsls	r3, r3, #4
 603              		.loc 4 224 23
 604 0044 1900     		movs	r1, r3
 605 0046 7868     		ldr	r0, [r7, #4]
 606 0048 FFF7FEFF 		bl	__aeabi_uidiv
 607              	.LVL0:
 608 004c 0300     		movs	r3, r0
 609 004e 1A00     		movs	r2, r3
 610              		.loc 4 224 9
 611 0050 3B19     		adds	r3, r7, r4
 612 0052 1A80     		strh	r2, [r3]
 225:../drivers/fsl_uart.c ****     /* set sbrTemp to 1 if the sourceClockInHz can not satisfy the desired baud rate */
 226:../drivers/fsl_uart.c ****     if (sbr == 0)
 613              		.loc 4 226 8
 614 0054 3B19     		adds	r3, r7, r4
 615 0056 1B88     		ldrh	r3, [r3]
 616 0058 002B     		cmp	r3, #0
 617 005a 02D1     		bne	.L41
 227:../drivers/fsl_uart.c ****     {
 228:../drivers/fsl_uart.c ****         sbr = 1;
 618              		.loc 4 228 13
 619 005c 3B19     		adds	r3, r7, r4
 620 005e 0122     		movs	r2, #1
 621 0060 1A80     		strh	r2, [r3]
 622              	.L41:
 229:../drivers/fsl_uart.c ****     }
 230:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_F
 231:../drivers/fsl_uart.c ****     /* Determine if a fractional divider is needed to fine tune closer to the
 232:../drivers/fsl_uart.c ****      * desired baud, each value of brfa is in 1/32 increments,
 233:../drivers/fsl_uart.c ****      * hence the multiply-by-32. */
 234:../drivers/fsl_uart.c ****     uint32_t tempBaud = 0;
 235:../drivers/fsl_uart.c **** 
 236:../drivers/fsl_uart.c ****     uint16_t brfa = (2 * srcClock_Hz / (config->baudRate_Bps)) - 32 * sbr;
 237:../drivers/fsl_uart.c **** 
 238:../drivers/fsl_uart.c ****     /* Calculate the baud rate based on the temporary SBR values and BRFA */
 239:../drivers/fsl_uart.c ****     tempBaud = (srcClock_Hz * 2 / ((sbr * 32 + brfa)));
 240:../drivers/fsl_uart.c ****     baudDiff =
 241:../drivers/fsl_uart.c ****         (tempBaud > config->baudRate_Bps) ? (tempBaud - config->baudRate_Bps) : (config->baudRate_B
 242:../drivers/fsl_uart.c **** 
 243:../drivers/fsl_uart.c **** #else
 244:../drivers/fsl_uart.c ****     /* Calculate the baud rate based on the temporary SBR values */
 245:../drivers/fsl_uart.c ****     baudDiff = (srcClock_Hz / (sbr * 16)) - config->baudRate_Bps;
 623              		.loc 4 245 36
 624 0062 1625     		movs	r5, #22
 625 0064 7B19     		adds	r3, r7, r5
 626 0066 1B88     		ldrh	r3, [r3]
 627 0068 1B01     		lsls	r3, r3, #4
 628              		.loc 4 245 29
 629 006a 1900     		movs	r1, r3
 630 006c 7868     		ldr	r0, [r7, #4]
 631 006e FFF7FEFF 		bl	__aeabi_uidiv
 632              	.LVL1:
 633 0072 0300     		movs	r3, r0
 634 0074 1A00     		movs	r2, r3
 635              		.loc 4 245 51
 636 0076 BB68     		ldr	r3, [r7, #8]
 637 0078 1B68     		ldr	r3, [r3]
 638              		.loc 4 245 14
 639 007a D31A     		subs	r3, r2, r3
 640 007c 3B61     		str	r3, [r7, #16]
 246:../drivers/fsl_uart.c **** 
 247:../drivers/fsl_uart.c ****     /* Select the better value between sbr and (sbr + 1) */
 248:../drivers/fsl_uart.c ****     if (baudDiff > (config->baudRate_Bps - (srcClock_Hz / (16 * (sbr + 1)))))
 641              		.loc 4 248 27
 642 007e BB68     		ldr	r3, [r7, #8]
 643 0080 1C68     		ldr	r4, [r3]
 644              		.loc 4 248 70
 645 0082 7B19     		adds	r3, r7, r5
 646 0084 1B88     		ldrh	r3, [r3]
 647 0086 0133     		adds	r3, r3, #1
 648              		.loc 4 248 63
 649 0088 1B01     		lsls	r3, r3, #4
 650              		.loc 4 248 57
 651 008a 1900     		movs	r1, r3
 652 008c 7868     		ldr	r0, [r7, #4]
 653 008e FFF7FEFF 		bl	__aeabi_uidiv
 654              	.LVL2:
 655 0092 0300     		movs	r3, r0
 656              		.loc 4 248 42
 657 0094 E31A     		subs	r3, r4, r3
 658              		.loc 4 248 8
 659 0096 3A69     		ldr	r2, [r7, #16]
 660 0098 9A42     		cmp	r2, r3
 661 009a 11D9     		bls	.L42
 249:../drivers/fsl_uart.c ****     {
 250:../drivers/fsl_uart.c ****         baudDiff = config->baudRate_Bps - (srcClock_Hz / (16 * (sbr + 1)));
 662              		.loc 4 250 26
 663 009c BB68     		ldr	r3, [r7, #8]
 664 009e 1C68     		ldr	r4, [r3]
 665              		.loc 4 250 69
 666 00a0 7B19     		adds	r3, r7, r5
 667 00a2 1B88     		ldrh	r3, [r3]
 668 00a4 0133     		adds	r3, r3, #1
 669              		.loc 4 250 62
 670 00a6 1B01     		lsls	r3, r3, #4
 671              		.loc 4 250 56
 672 00a8 1900     		movs	r1, r3
 673 00aa 7868     		ldr	r0, [r7, #4]
 674 00ac FFF7FEFF 		bl	__aeabi_uidiv
 675              	.LVL3:
 676 00b0 0300     		movs	r3, r0
 677              		.loc 4 250 18
 678 00b2 E31A     		subs	r3, r4, r3
 679 00b4 3B61     		str	r3, [r7, #16]
 251:../drivers/fsl_uart.c ****         sbr++;
 680              		.loc 4 251 12
 681 00b6 7B19     		adds	r3, r7, r5
 682 00b8 1A88     		ldrh	r2, [r3]
 683 00ba 7B19     		adds	r3, r7, r5
 684 00bc 0132     		adds	r2, r2, #1
 685 00be 1A80     		strh	r2, [r3]
 686              	.L42:
 252:../drivers/fsl_uart.c ****     }
 253:../drivers/fsl_uart.c **** #endif
 254:../drivers/fsl_uart.c **** 
 255:../drivers/fsl_uart.c ****     /* next, check to see if actual baud rate is within 3% of desired baud rate
 256:../drivers/fsl_uart.c ****      * based on the calculate SBR value */
 257:../drivers/fsl_uart.c ****     if (baudDiff > ((config->baudRate_Bps / 100) * 3))
 687              		.loc 4 257 28
 688 00c0 BB68     		ldr	r3, [r7, #8]
 689 00c2 1B68     		ldr	r3, [r3]
 690              		.loc 4 257 43
 691 00c4 6421     		movs	r1, #100
 692 00c6 1800     		movs	r0, r3
 693 00c8 FFF7FEFF 		bl	__aeabi_uidiv
 694              	.LVL4:
 695 00cc 0300     		movs	r3, r0
 696 00ce 1A00     		movs	r2, r3
 697              		.loc 4 257 50
 698 00d0 1300     		movs	r3, r2
 699 00d2 5B00     		lsls	r3, r3, #1
 700 00d4 9B18     		adds	r3, r3, r2
 701              		.loc 4 257 8
 702 00d6 3A69     		ldr	r2, [r7, #16]
 703 00d8 9A42     		cmp	r2, r3
 704 00da 01D9     		bls	.L43
 258:../drivers/fsl_uart.c ****     {
 259:../drivers/fsl_uart.c ****         /* Unacceptable baud rate difference of more than 3%*/
 260:../drivers/fsl_uart.c ****         return kStatus_UART_BaudrateNotSupport;
 705              		.loc 4 260 16
 706 00dc 3E4B     		ldr	r3, .L48+8
 707 00de 72E0     		b	.L44
 708              	.L43:
 261:../drivers/fsl_uart.c ****     }
 262:../drivers/fsl_uart.c **** 
 263:../drivers/fsl_uart.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 264:../drivers/fsl_uart.c ****     /* Enable uart clock */
 265:../drivers/fsl_uart.c ****     CLOCK_EnableClock(s_uartClock[UART_GetInstance(base)]);
 709              		.loc 4 265 35
 710 00e0 FB68     		ldr	r3, [r7, #12]
 711 00e2 1800     		movs	r0, r3
 712 00e4 FFF7FEFF 		bl	UART_GetInstance
 713 00e8 0200     		movs	r2, r0
 714              		.loc 4 265 5
 715 00ea 3C4B     		ldr	r3, .L48+12
 716 00ec 9200     		lsls	r2, r2, #2
 717 00ee D358     		ldr	r3, [r2, r3]
 718 00f0 1800     		movs	r0, r3
 719 00f2 FFF7FEFF 		bl	CLOCK_EnableClock
 266:../drivers/fsl_uart.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 267:../drivers/fsl_uart.c **** 
 268:../drivers/fsl_uart.c ****     /* Disable UART TX RX before setting. */
 269:../drivers/fsl_uart.c ****     base->C2 &= ~(UART_C2_TE_MASK | UART_C2_RE_MASK);
 720              		.loc 4 269 14
 721 00f6 FB68     		ldr	r3, [r7, #12]
 722 00f8 DB78     		ldrb	r3, [r3, #3]
 723 00fa DBB2     		uxtb	r3, r3
 724 00fc 0C22     		movs	r2, #12
 725 00fe 9343     		bics	r3, r2
 726 0100 DAB2     		uxtb	r2, r3
 727 0102 FB68     		ldr	r3, [r7, #12]
 728 0104 DA70     		strb	r2, [r3, #3]
 270:../drivers/fsl_uart.c **** 
 271:../drivers/fsl_uart.c ****     /* Write the sbr value to the BDH and BDL registers*/
 272:../drivers/fsl_uart.c ****     base->BDH = (base->BDH & ~UART_BDH_SBR_MASK) | (uint8_t)(sbr >> 8);
 729              		.loc 4 272 22
 730 0106 FB68     		ldr	r3, [r7, #12]
 731 0108 1B78     		ldrb	r3, [r3]
 732 010a DBB2     		uxtb	r3, r3
 733              		.loc 4 272 28
 734 010c 1F22     		movs	r2, #31
 735 010e 9343     		bics	r3, r2
 736 0110 DAB2     		uxtb	r2, r3
 737              		.loc 4 272 52
 738 0112 1621     		movs	r1, #22
 739 0114 7B18     		adds	r3, r7, r1
 740 0116 1B88     		ldrh	r3, [r3]
 741 0118 1B0A     		lsrs	r3, r3, #8
 742 011a 9BB2     		uxth	r3, r3
 743 011c DBB2     		uxtb	r3, r3
 744              		.loc 4 272 50
 745 011e 1343     		orrs	r3, r2
 746 0120 DAB2     		uxtb	r2, r3
 747              		.loc 4 272 15
 748 0122 FB68     		ldr	r3, [r7, #12]
 749 0124 1A70     		strb	r2, [r3]
 273:../drivers/fsl_uart.c ****     base->BDL = (uint8_t)sbr;
 750              		.loc 4 273 17
 751 0126 7B18     		adds	r3, r7, r1
 752 0128 1B88     		ldrh	r3, [r3]
 753 012a DAB2     		uxtb	r2, r3
 754              		.loc 4 273 15
 755 012c FB68     		ldr	r3, [r7, #12]
 756 012e 5A70     		strb	r2, [r3, #1]
 274:../drivers/fsl_uart.c **** 
 275:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_F
 276:../drivers/fsl_uart.c ****     /* Write the brfa value to the register*/
 277:../drivers/fsl_uart.c ****     base->C4 = (base->C4 & ~UART_C4_BRFA_MASK) | (brfa & UART_C4_BRFA_MASK);
 278:../drivers/fsl_uart.c **** #endif
 279:../drivers/fsl_uart.c **** 
 280:../drivers/fsl_uart.c ****     /* Set bit count and parity mode. */
 281:../drivers/fsl_uart.c ****     temp = base->C1 & ~(UART_C1_PE_MASK | UART_C1_PT_MASK | UART_C1_M_MASK);
 757              		.loc 4 281 16
 758 0130 FB68     		ldr	r3, [r7, #12]
 759 0132 9B78     		ldrb	r3, [r3, #2]
 760 0134 DAB2     		uxtb	r2, r3
 761              		.loc 4 281 10
 762 0136 1520     		movs	r0, #21
 763 0138 3B18     		adds	r3, r7, r0
 764 013a 1321     		movs	r1, #19
 765 013c 8A43     		bics	r2, r1
 766 013e 1A70     		strb	r2, [r3]
 282:../drivers/fsl_uart.c **** 
 283:../drivers/fsl_uart.c ****     if (kUART_ParityDisabled != config->parityMode)
 767              		.loc 4 283 39
 768 0140 BB68     		ldr	r3, [r7, #8]
 769 0142 1B79     		ldrb	r3, [r3, #4]
 770              		.loc 4 283 8
 771 0144 002B     		cmp	r3, #0
 772 0146 09D0     		beq	.L45
 284:../drivers/fsl_uart.c ****     {
 285:../drivers/fsl_uart.c ****         temp |= (UART_C1_M_MASK | (uint8_t)config->parityMode);
 773              		.loc 4 285 50
 774 0148 BB68     		ldr	r3, [r7, #8]
 775 014a 1A79     		ldrb	r2, [r3, #4]
 776              		.loc 4 285 14
 777 014c 3B18     		adds	r3, r7, r0
 778 014e 1B78     		ldrb	r3, [r3]
 779 0150 1343     		orrs	r3, r2
 780 0152 DAB2     		uxtb	r2, r3
 781 0154 3B18     		adds	r3, r7, r0
 782 0156 1021     		movs	r1, #16
 783 0158 0A43     		orrs	r2, r1
 784 015a 1A70     		strb	r2, [r3]
 785              	.L45:
 286:../drivers/fsl_uart.c ****     }
 287:../drivers/fsl_uart.c **** 
 288:../drivers/fsl_uart.c ****     base->C1 = temp;
 786              		.loc 4 288 14
 787 015c FB68     		ldr	r3, [r7, #12]
 788 015e 1520     		movs	r0, #21
 789 0160 3A18     		adds	r2, r7, r0
 790 0162 1278     		ldrb	r2, [r2]
 791 0164 9A70     		strb	r2, [r3, #2]
 289:../drivers/fsl_uart.c **** 
 290:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT) && FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_S
 291:../drivers/fsl_uart.c ****     /* Set stop bit per char */
 292:../drivers/fsl_uart.c ****     base->BDH = (base->BDH & ~UART_BDH_SBNS_MASK) | UART_BDH_SBNS((uint8_t)config->stopBitCount);
 792              		.loc 4 292 22
 793 0166 FB68     		ldr	r3, [r7, #12]
 794 0168 1B78     		ldrb	r3, [r3]
 795 016a DBB2     		uxtb	r3, r3
 796              		.loc 4 292 28
 797 016c 2022     		movs	r2, #32
 798 016e 9343     		bics	r3, r2
 799 0170 DAB2     		uxtb	r2, r3
 800              		.loc 4 292 53
 801 0172 BB68     		ldr	r3, [r7, #8]
 802 0174 5B79     		ldrb	r3, [r3, #5]
 803 0176 5B01     		lsls	r3, r3, #5
 804 0178 DBB2     		uxtb	r3, r3
 805 017a 2021     		movs	r1, #32
 806 017c 0B40     		ands	r3, r1
 807 017e DBB2     		uxtb	r3, r3
 808              		.loc 4 292 51
 809 0180 1343     		orrs	r3, r2
 810 0182 DAB2     		uxtb	r2, r3
 811              		.loc 4 292 15
 812 0184 FB68     		ldr	r3, [r7, #12]
 813 0186 1A70     		strb	r2, [r3]
 293:../drivers/fsl_uart.c **** #endif
 294:../drivers/fsl_uart.c **** 
 295:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
 296:../drivers/fsl_uart.c ****     /* Set tx/rx FIFO watermark */
 297:../drivers/fsl_uart.c ****     base->TWFIFO = config->txFifoWatermark;
 298:../drivers/fsl_uart.c ****     base->RWFIFO = config->rxFifoWatermark;
 299:../drivers/fsl_uart.c **** 
 300:../drivers/fsl_uart.c ****     /* Enable tx/rx FIFO */
 301:../drivers/fsl_uart.c ****     base->PFIFO |= (UART_PFIFO_TXFE_MASK | UART_PFIFO_RXFE_MASK);
 302:../drivers/fsl_uart.c **** 
 303:../drivers/fsl_uart.c ****     /* Flush FIFO */
 304:../drivers/fsl_uart.c ****     base->CFIFO |= (UART_CFIFO_TXFLUSH_MASK | UART_CFIFO_RXFLUSH_MASK);
 305:../drivers/fsl_uart.c **** #endif
 306:../drivers/fsl_uart.c **** 
 307:../drivers/fsl_uart.c ****     /* Enable TX/RX base on configure structure. */
 308:../drivers/fsl_uart.c ****     temp = base->C2;
 814              		.loc 4 308 10
 815 0188 3B18     		adds	r3, r7, r0
 816 018a FA68     		ldr	r2, [r7, #12]
 817 018c D278     		ldrb	r2, [r2, #3]
 818 018e 1A70     		strb	r2, [r3]
 309:../drivers/fsl_uart.c **** 
 310:../drivers/fsl_uart.c ****     if (config->enableTx)
 819              		.loc 4 310 15
 820 0190 BB68     		ldr	r3, [r7, #8]
 821 0192 9B79     		ldrb	r3, [r3, #6]
 822              		.loc 4 310 8
 823 0194 002B     		cmp	r3, #0
 824 0196 05D0     		beq	.L46
 311:../drivers/fsl_uart.c ****     {
 312:../drivers/fsl_uart.c ****         temp |= UART_C2_TE_MASK;
 825              		.loc 4 312 14
 826 0198 3B18     		adds	r3, r7, r0
 827 019a 3A18     		adds	r2, r7, r0
 828 019c 1278     		ldrb	r2, [r2]
 829 019e 0821     		movs	r1, #8
 830 01a0 0A43     		orrs	r2, r1
 831 01a2 1A70     		strb	r2, [r3]
 832              	.L46:
 313:../drivers/fsl_uart.c ****     }
 314:../drivers/fsl_uart.c **** 
 315:../drivers/fsl_uart.c ****     if (config->enableRx)
 833              		.loc 4 315 15
 834 01a4 BB68     		ldr	r3, [r7, #8]
 835 01a6 DB79     		ldrb	r3, [r3, #7]
 836              		.loc 4 315 8
 837 01a8 002B     		cmp	r3, #0
 838 01aa 06D0     		beq	.L47
 316:../drivers/fsl_uart.c ****     {
 317:../drivers/fsl_uart.c ****         temp |= UART_C2_RE_MASK;
 839              		.loc 4 317 14
 840 01ac 1522     		movs	r2, #21
 841 01ae BB18     		adds	r3, r7, r2
 842 01b0 BA18     		adds	r2, r7, r2
 843 01b2 1278     		ldrb	r2, [r2]
 844 01b4 0421     		movs	r1, #4
 845 01b6 0A43     		orrs	r2, r1
 846 01b8 1A70     		strb	r2, [r3]
 847              	.L47:
 318:../drivers/fsl_uart.c ****     }
 319:../drivers/fsl_uart.c **** 
 320:../drivers/fsl_uart.c ****     base->C2 = temp;
 848              		.loc 4 320 14
 849 01ba FB68     		ldr	r3, [r7, #12]
 850 01bc 1522     		movs	r2, #21
 851 01be BA18     		adds	r2, r7, r2
 852 01c0 1278     		ldrb	r2, [r2]
 853 01c2 DA70     		strb	r2, [r3, #3]
 321:../drivers/fsl_uart.c **** 
 322:../drivers/fsl_uart.c ****     return kStatus_Success;
 854              		.loc 4 322 12
 855 01c4 0023     		movs	r3, #0
 856              	.L44:
 323:../drivers/fsl_uart.c **** }
 857              		.loc 4 323 1
 858 01c6 1800     		movs	r0, r3
 859 01c8 BD46     		mov	sp, r7
 860 01ca 06B0     		add	sp, sp, #24
 861              		@ sp needed
 862 01cc B0BD     		pop	{r4, r5, r7, pc}
 863              	.L49:
 864 01ce C046     		.align	2
 865              	.L48:
 866 01d0 00000000 		.word	.LC7
 867 01d4 1C000000 		.word	.LC9
 868 01d8 F5030000 		.word	1013
 869 01dc 00000000 		.word	s_uartClock
 870              		.cfi_endproc
 871              	.LFE66:
 873              		.section	.text.UART_Deinit,"ax",%progbits
 874              		.align	1
 875              		.global	UART_Deinit
 876              		.syntax unified
 877              		.code	16
 878              		.thumb_func
 879              		.fpu softvfp
 881              	UART_Deinit:
 882              	.LFB67:
 324:../drivers/fsl_uart.c **** 
 325:../drivers/fsl_uart.c **** void UART_Deinit(UART_Type *base)
 326:../drivers/fsl_uart.c **** {
 883              		.loc 4 326 1
 884              		.cfi_startproc
 885              		@ args = 0, pretend = 0, frame = 8
 886              		@ frame_needed = 1, uses_anonymous_args = 0
 887 0000 80B5     		push	{r7, lr}
 888              		.cfi_def_cfa_offset 8
 889              		.cfi_offset 7, -8
 890              		.cfi_offset 14, -4
 891 0002 82B0     		sub	sp, sp, #8
 892              		.cfi_def_cfa_offset 16
 893 0004 00AF     		add	r7, sp, #0
 894              		.cfi_def_cfa_register 7
 895 0006 7860     		str	r0, [r7, #4]
 327:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
 328:../drivers/fsl_uart.c ****     /* Wait tx FIFO send out*/
 329:../drivers/fsl_uart.c ****     while (0 != base->TCFIFO)
 330:../drivers/fsl_uart.c ****     {
 331:../drivers/fsl_uart.c ****     }
 332:../drivers/fsl_uart.c **** #endif
 333:../drivers/fsl_uart.c ****     /* Wait last char shoft out */
 334:../drivers/fsl_uart.c ****     while (0 == (base->S1 & UART_S1_TC_MASK))
 896              		.loc 4 334 11
 897 0008 C046     		nop
 898              	.L51:
 899              		.loc 4 334 22 discriminator 1
 900 000a 7B68     		ldr	r3, [r7, #4]
 901 000c 1B79     		ldrb	r3, [r3, #4]
 902 000e DBB2     		uxtb	r3, r3
 903              		.loc 4 334 27 discriminator 1
 904 0010 1A00     		movs	r2, r3
 905 0012 4023     		movs	r3, #64
 906 0014 1340     		ands	r3, r2
 907              		.loc 4 334 11 discriminator 1
 908 0016 F8D0     		beq	.L51
 335:../drivers/fsl_uart.c ****     {
 336:../drivers/fsl_uart.c ****     }
 337:../drivers/fsl_uart.c **** 
 338:../drivers/fsl_uart.c ****     /* Disable the module. */
 339:../drivers/fsl_uart.c ****     base->C2 = 0;
 909              		.loc 4 339 14
 910 0018 7B68     		ldr	r3, [r7, #4]
 911 001a 0022     		movs	r2, #0
 912 001c DA70     		strb	r2, [r3, #3]
 340:../drivers/fsl_uart.c **** 
 341:../drivers/fsl_uart.c **** #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
 342:../drivers/fsl_uart.c ****     /* Disable uart clock */
 343:../drivers/fsl_uart.c ****     CLOCK_DisableClock(s_uartClock[UART_GetInstance(base)]);
 913              		.loc 4 343 36
 914 001e 7B68     		ldr	r3, [r7, #4]
 915 0020 1800     		movs	r0, r3
 916 0022 FFF7FEFF 		bl	UART_GetInstance
 917 0026 0200     		movs	r2, r0
 918              		.loc 4 343 5
 919 0028 044B     		ldr	r3, .L52
 920 002a 9200     		lsls	r2, r2, #2
 921 002c D358     		ldr	r3, [r2, r3]
 922 002e 1800     		movs	r0, r3
 923 0030 FFF7FEFF 		bl	CLOCK_DisableClock
 344:../drivers/fsl_uart.c **** #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
 345:../drivers/fsl_uart.c **** }
 924              		.loc 4 345 1
 925 0034 C046     		nop
 926 0036 BD46     		mov	sp, r7
 927 0038 02B0     		add	sp, sp, #8
 928              		@ sp needed
 929 003a 80BD     		pop	{r7, pc}
 930              	.L53:
 931              		.align	2
 932              	.L52:
 933 003c 00000000 		.word	s_uartClock
 934              		.cfi_endproc
 935              	.LFE67:
 937              		.section	.rodata.UART_GetDefaultConfig.str1.4,"aMS",%progbits,1
 938              		.align	2
 939              	.LC13:
 940 0000 2E66736C 		.ascii	".fsl_uart.c:349 : config\000"
 940      5F756172 
 940      742E633A 
 940      33343920 
 940      3A20636F 
 941              		.section	.text.UART_GetDefaultConfig,"ax",%progbits
 942              		.align	1
 943              		.global	UART_GetDefaultConfig
 944              		.syntax unified
 945              		.code	16
 946              		.thumb_func
 947              		.fpu softvfp
 949              	UART_GetDefaultConfig:
 950              	.LFB68:
 346:../drivers/fsl_uart.c **** 
 347:../drivers/fsl_uart.c **** void UART_GetDefaultConfig(uart_config_t *config)
 348:../drivers/fsl_uart.c **** {
 951              		.loc 4 348 1
 952              		.cfi_startproc
 953              		@ args = 0, pretend = 0, frame = 8
 954              		@ frame_needed = 1, uses_anonymous_args = 0
 955 0000 80B5     		push	{r7, lr}
 956              		.cfi_def_cfa_offset 8
 957              		.cfi_offset 7, -8
 958              		.cfi_offset 14, -4
 959 0002 82B0     		sub	sp, sp, #8
 960              		.cfi_def_cfa_offset 16
 961 0004 00AF     		add	r7, sp, #0
 962              		.cfi_def_cfa_register 7
 963 0006 7860     		str	r0, [r7, #4]
 349:../drivers/fsl_uart.c ****     assert(config);
 964              		.loc 4 349 5
 965 0008 7B68     		ldr	r3, [r7, #4]
 966 000a 002B     		cmp	r3, #0
 967 000c 03D1     		bne	.L55
 968              		.loc 4 349 5 is_stmt 0 discriminator 1
 969 000e 0C4B     		ldr	r3, .L56
 970 0010 1800     		movs	r0, r3
 971 0012 FFF7FEFF 		bl	__assertion_failed
 972              	.L55:
 350:../drivers/fsl_uart.c **** 
 351:../drivers/fsl_uart.c ****     config->baudRate_Bps = 115200U;
 973              		.loc 4 351 26 is_stmt 1
 974 0016 7B68     		ldr	r3, [r7, #4]
 975 0018 E122     		movs	r2, #225
 976 001a 5202     		lsls	r2, r2, #9
 977 001c 1A60     		str	r2, [r3]
 352:../drivers/fsl_uart.c ****     config->parityMode = kUART_ParityDisabled;
 978              		.loc 4 352 24
 979 001e 7B68     		ldr	r3, [r7, #4]
 980 0020 0022     		movs	r2, #0
 981 0022 1A71     		strb	r2, [r3, #4]
 353:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT) && FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_S
 354:../drivers/fsl_uart.c ****     config->stopBitCount = kUART_OneStopBit;
 982              		.loc 4 354 26
 983 0024 7B68     		ldr	r3, [r7, #4]
 984 0026 0022     		movs	r2, #0
 985 0028 5A71     		strb	r2, [r3, #5]
 355:../drivers/fsl_uart.c **** #endif
 356:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
 357:../drivers/fsl_uart.c ****     config->txFifoWatermark = 0;
 358:../drivers/fsl_uart.c ****     config->rxFifoWatermark = 1;
 359:../drivers/fsl_uart.c **** #endif
 360:../drivers/fsl_uart.c ****     config->enableTx = false;
 986              		.loc 4 360 22
 987 002a 7B68     		ldr	r3, [r7, #4]
 988 002c 0022     		movs	r2, #0
 989 002e 9A71     		strb	r2, [r3, #6]
 361:../drivers/fsl_uart.c ****     config->enableRx = false;
 990              		.loc 4 361 22
 991 0030 7B68     		ldr	r3, [r7, #4]
 992 0032 0022     		movs	r2, #0
 993 0034 DA71     		strb	r2, [r3, #7]
 362:../drivers/fsl_uart.c **** }
 994              		.loc 4 362 1
 995 0036 C046     		nop
 996 0038 BD46     		mov	sp, r7
 997 003a 02B0     		add	sp, sp, #8
 998              		@ sp needed
 999 003c 80BD     		pop	{r7, pc}
 1000              	.L57:
 1001 003e C046     		.align	2
 1002              	.L56:
 1003 0040 00000000 		.word	.LC13
 1004              		.cfi_endproc
 1005              	.LFE68:
 1007              		.section	.rodata.UART_SetBaudRate.str1.4,"aMS",%progbits,1
 1008              		.align	2
 1009              	.LC15:
 1010 0000 2E66736C 		.ascii	".fsl_uart.c:366 : baudRate_Bps\000"
 1010      5F756172 
 1010      742E633A 
 1010      33363620 
 1010      3A206261 
 1011              		.section	.text.UART_SetBaudRate,"ax",%progbits
 1012              		.align	1
 1013              		.global	UART_SetBaudRate
 1014              		.syntax unified
 1015              		.code	16
 1016              		.thumb_func
 1017              		.fpu softvfp
 1019              	UART_SetBaudRate:
 1020              	.LFB69:
 363:../drivers/fsl_uart.c **** 
 364:../drivers/fsl_uart.c **** status_t UART_SetBaudRate(UART_Type *base, uint32_t baudRate_Bps, uint32_t srcClock_Hz)
 365:../drivers/fsl_uart.c **** {
 1021              		.loc 4 365 1
 1022              		.cfi_startproc
 1023              		@ args = 0, pretend = 0, frame = 32
 1024              		@ frame_needed = 1, uses_anonymous_args = 0
 1025 0000 90B5     		push	{r4, r7, lr}
 1026              		.cfi_def_cfa_offset 12
 1027              		.cfi_offset 4, -12
 1028              		.cfi_offset 7, -8
 1029              		.cfi_offset 14, -4
 1030 0002 89B0     		sub	sp, sp, #36
 1031              		.cfi_def_cfa_offset 48
 1032 0004 00AF     		add	r7, sp, #0
 1033              		.cfi_def_cfa_register 7
 1034 0006 F860     		str	r0, [r7, #12]
 1035 0008 B960     		str	r1, [r7, #8]
 1036 000a 7A60     		str	r2, [r7, #4]
 366:../drivers/fsl_uart.c ****     assert(baudRate_Bps);
 1037              		.loc 4 366 5
 1038 000c BB68     		ldr	r3, [r7, #8]
 1039 000e 002B     		cmp	r3, #0
 1040 0010 03D1     		bne	.L59
 1041              		.loc 4 366 5 is_stmt 0 discriminator 1
 1042 0012 414B     		ldr	r3, .L64
 1043 0014 1800     		movs	r0, r3
 1044 0016 FFF7FEFF 		bl	__assertion_failed
 1045              	.L59:
 367:../drivers/fsl_uart.c **** 
 368:../drivers/fsl_uart.c ****     uint16_t sbr = 0;
 1046              		.loc 4 368 14 is_stmt 1
 1047 001a 1E24     		movs	r4, #30
 1048 001c 3B19     		adds	r3, r7, r4
 1049 001e 0022     		movs	r2, #0
 1050 0020 1A80     		strh	r2, [r3]
 369:../drivers/fsl_uart.c ****     uint32_t baudDiff = 0;
 1051              		.loc 4 369 14
 1052 0022 0023     		movs	r3, #0
 1053 0024 BB61     		str	r3, [r7, #24]
 370:../drivers/fsl_uart.c ****     uint8_t oldCtrl;
 371:../drivers/fsl_uart.c **** 
 372:../drivers/fsl_uart.c ****     /* Calculate the baud rate modulo divisor, sbr*/
 373:../drivers/fsl_uart.c ****     sbr = srcClock_Hz / (baudRate_Bps * 16);
 1054              		.loc 4 373 39
 1055 0026 BB68     		ldr	r3, [r7, #8]
 1056 0028 1B01     		lsls	r3, r3, #4
 1057              		.loc 4 373 23
 1058 002a 1900     		movs	r1, r3
 1059 002c 7868     		ldr	r0, [r7, #4]
 1060 002e FFF7FEFF 		bl	__aeabi_uidiv
 1061              	.LVL5:
 1062 0032 0300     		movs	r3, r0
 1063 0034 1A00     		movs	r2, r3
 1064              		.loc 4 373 9
 1065 0036 3B19     		adds	r3, r7, r4
 1066 0038 1A80     		strh	r2, [r3]
 374:../drivers/fsl_uart.c ****     /* set sbrTemp to 1 if the sourceClockInHz can not satisfy the desired baud rate */
 375:../drivers/fsl_uart.c ****     if (sbr == 0)
 1067              		.loc 4 375 8
 1068 003a 3B19     		adds	r3, r7, r4
 1069 003c 1B88     		ldrh	r3, [r3]
 1070 003e 002B     		cmp	r3, #0
 1071 0040 02D1     		bne	.L60
 376:../drivers/fsl_uart.c ****     {
 377:../drivers/fsl_uart.c ****         sbr = 1;
 1072              		.loc 4 377 13
 1073 0042 3B19     		adds	r3, r7, r4
 1074 0044 0122     		movs	r2, #1
 1075 0046 1A80     		strh	r2, [r3]
 1076              	.L60:
 378:../drivers/fsl_uart.c ****     }
 379:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_F
 380:../drivers/fsl_uart.c ****     /* Determine if a fractional divider is needed to fine tune closer to the
 381:../drivers/fsl_uart.c ****      * desired baud, each value of brfa is in 1/32 increments,
 382:../drivers/fsl_uart.c ****      * hence the multiply-by-32. */
 383:../drivers/fsl_uart.c ****     uint32_t tempBaud = 0;
 384:../drivers/fsl_uart.c **** 
 385:../drivers/fsl_uart.c ****     uint16_t brfa = (2 * srcClock_Hz / (baudRate_Bps)) - 32 * sbr;
 386:../drivers/fsl_uart.c **** 
 387:../drivers/fsl_uart.c ****     /* Calculate the baud rate based on the temporary SBR values and BRFA */
 388:../drivers/fsl_uart.c ****     tempBaud = (srcClock_Hz * 2 / ((sbr * 32 + brfa)));
 389:../drivers/fsl_uart.c ****     baudDiff = (tempBaud > baudRate_Bps) ? (tempBaud - baudRate_Bps) : (baudRate_Bps - tempBaud);
 390:../drivers/fsl_uart.c **** #else
 391:../drivers/fsl_uart.c ****     /* Calculate the baud rate based on the temporary SBR values */
 392:../drivers/fsl_uart.c ****     baudDiff = (srcClock_Hz / (sbr * 16)) - baudRate_Bps;
 1077              		.loc 4 392 36
 1078 0048 1E24     		movs	r4, #30
 1079 004a 3B19     		adds	r3, r7, r4
 1080 004c 1B88     		ldrh	r3, [r3]
 1081 004e 1B01     		lsls	r3, r3, #4
 1082              		.loc 4 392 29
 1083 0050 1900     		movs	r1, r3
 1084 0052 7868     		ldr	r0, [r7, #4]
 1085 0054 FFF7FEFF 		bl	__aeabi_uidiv
 1086              	.LVL6:
 1087 0058 0300     		movs	r3, r0
 1088 005a 1A00     		movs	r2, r3
 1089              		.loc 4 392 14
 1090 005c BB68     		ldr	r3, [r7, #8]
 1091 005e D31A     		subs	r3, r2, r3
 1092 0060 BB61     		str	r3, [r7, #24]
 393:../drivers/fsl_uart.c **** 
 394:../drivers/fsl_uart.c ****     /* Select the better value between sbr and (sbr + 1) */
 395:../drivers/fsl_uart.c ****     if (baudDiff > (baudRate_Bps - (srcClock_Hz / (16 * (sbr + 1)))))
 1093              		.loc 4 395 62
 1094 0062 3B19     		adds	r3, r7, r4
 1095 0064 1B88     		ldrh	r3, [r3]
 1096 0066 0133     		adds	r3, r3, #1
 1097              		.loc 4 395 55
 1098 0068 1B01     		lsls	r3, r3, #4
 1099              		.loc 4 395 49
 1100 006a 1900     		movs	r1, r3
 1101 006c 7868     		ldr	r0, [r7, #4]
 1102 006e FFF7FEFF 		bl	__aeabi_uidiv
 1103              	.LVL7:
 1104 0072 0300     		movs	r3, r0
 1105 0074 1A00     		movs	r2, r3
 1106              		.loc 4 395 34
 1107 0076 BB68     		ldr	r3, [r7, #8]
 1108 0078 9B1A     		subs	r3, r3, r2
 1109              		.loc 4 395 8
 1110 007a BA69     		ldr	r2, [r7, #24]
 1111 007c 9A42     		cmp	r2, r3
 1112 007e 11D9     		bls	.L61
 396:../drivers/fsl_uart.c ****     {
 397:../drivers/fsl_uart.c ****         baudDiff = baudRate_Bps - (srcClock_Hz / (16 * (sbr + 1)));
 1113              		.loc 4 397 61
 1114 0080 3B19     		adds	r3, r7, r4
 1115 0082 1B88     		ldrh	r3, [r3]
 1116 0084 0133     		adds	r3, r3, #1
 1117              		.loc 4 397 54
 1118 0086 1B01     		lsls	r3, r3, #4
 1119              		.loc 4 397 48
 1120 0088 1900     		movs	r1, r3
 1121 008a 7868     		ldr	r0, [r7, #4]
 1122 008c FFF7FEFF 		bl	__aeabi_uidiv
 1123              	.LVL8:
 1124 0090 0300     		movs	r3, r0
 1125 0092 1A00     		movs	r2, r3
 1126              		.loc 4 397 18
 1127 0094 BB68     		ldr	r3, [r7, #8]
 1128 0096 9B1A     		subs	r3, r3, r2
 1129 0098 BB61     		str	r3, [r7, #24]
 398:../drivers/fsl_uart.c ****         sbr++;
 1130              		.loc 4 398 12
 1131 009a 3B19     		adds	r3, r7, r4
 1132 009c 1A88     		ldrh	r2, [r3]
 1133 009e 3B19     		adds	r3, r7, r4
 1134 00a0 0132     		adds	r2, r2, #1
 1135 00a2 1A80     		strh	r2, [r3]
 1136              	.L61:
 399:../drivers/fsl_uart.c ****     }
 400:../drivers/fsl_uart.c **** #endif
 401:../drivers/fsl_uart.c **** 
 402:../drivers/fsl_uart.c ****     /* next, check to see if actual baud rate is within 3% of desired baud rate
 403:../drivers/fsl_uart.c ****      * based on the calculate SBR value */
 404:../drivers/fsl_uart.c ****     if (baudDiff < ((baudRate_Bps / 100) * 3))
 1137              		.loc 4 404 35
 1138 00a4 BB68     		ldr	r3, [r7, #8]
 1139 00a6 6421     		movs	r1, #100
 1140 00a8 1800     		movs	r0, r3
 1141 00aa FFF7FEFF 		bl	__aeabi_uidiv
 1142              	.LVL9:
 1143 00ae 0300     		movs	r3, r0
 1144 00b0 1A00     		movs	r2, r3
 1145              		.loc 4 404 42
 1146 00b2 1300     		movs	r3, r2
 1147 00b4 5B00     		lsls	r3, r3, #1
 1148 00b6 9B18     		adds	r3, r3, r2
 1149              		.loc 4 404 8
 1150 00b8 BA69     		ldr	r2, [r7, #24]
 1151 00ba 9A42     		cmp	r2, r3
 1152 00bc 27D2     		bcs	.L62
 405:../drivers/fsl_uart.c ****     {
 406:../drivers/fsl_uart.c ****         /* Store C2 before disable Tx and Rx */
 407:../drivers/fsl_uart.c ****         oldCtrl = base->C2;
 1153              		.loc 4 407 17
 1154 00be 1721     		movs	r1, #23
 1155 00c0 7B18     		adds	r3, r7, r1
 1156 00c2 FA68     		ldr	r2, [r7, #12]
 1157 00c4 D278     		ldrb	r2, [r2, #3]
 1158 00c6 1A70     		strb	r2, [r3]
 408:../drivers/fsl_uart.c **** 
 409:../drivers/fsl_uart.c ****         /* Disable UART TX RX before setting. */
 410:../drivers/fsl_uart.c ****         base->C2 &= ~(UART_C2_TE_MASK | UART_C2_RE_MASK);
 1159              		.loc 4 410 18
 1160 00c8 FB68     		ldr	r3, [r7, #12]
 1161 00ca DB78     		ldrb	r3, [r3, #3]
 1162 00cc DBB2     		uxtb	r3, r3
 1163 00ce 0C22     		movs	r2, #12
 1164 00d0 9343     		bics	r3, r2
 1165 00d2 DAB2     		uxtb	r2, r3
 1166 00d4 FB68     		ldr	r3, [r7, #12]
 1167 00d6 DA70     		strb	r2, [r3, #3]
 411:../drivers/fsl_uart.c **** 
 412:../drivers/fsl_uart.c ****         /* Write the sbr value to the BDH and BDL registers*/
 413:../drivers/fsl_uart.c ****         base->BDH = (base->BDH & ~UART_BDH_SBR_MASK) | (uint8_t)(sbr >> 8);
 1168              		.loc 4 413 26
 1169 00d8 FB68     		ldr	r3, [r7, #12]
 1170 00da 1B78     		ldrb	r3, [r3]
 1171 00dc DBB2     		uxtb	r3, r3
 1172              		.loc 4 413 32
 1173 00de 1F22     		movs	r2, #31
 1174 00e0 9343     		bics	r3, r2
 1175 00e2 DAB2     		uxtb	r2, r3
 1176              		.loc 4 413 56
 1177 00e4 1E20     		movs	r0, #30
 1178 00e6 3B18     		adds	r3, r7, r0
 1179 00e8 1B88     		ldrh	r3, [r3]
 1180 00ea 1B0A     		lsrs	r3, r3, #8
 1181 00ec 9BB2     		uxth	r3, r3
 1182 00ee DBB2     		uxtb	r3, r3
 1183              		.loc 4 413 54
 1184 00f0 1343     		orrs	r3, r2
 1185 00f2 DAB2     		uxtb	r2, r3
 1186              		.loc 4 413 19
 1187 00f4 FB68     		ldr	r3, [r7, #12]
 1188 00f6 1A70     		strb	r2, [r3]
 414:../drivers/fsl_uart.c ****         base->BDL = (uint8_t)sbr;
 1189              		.loc 4 414 21
 1190 00f8 3B18     		adds	r3, r7, r0
 1191 00fa 1B88     		ldrh	r3, [r3]
 1192 00fc DAB2     		uxtb	r2, r3
 1193              		.loc 4 414 19
 1194 00fe FB68     		ldr	r3, [r7, #12]
 1195 0100 5A70     		strb	r2, [r3, #1]
 415:../drivers/fsl_uart.c **** 
 416:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_F
 417:../drivers/fsl_uart.c ****         /* Write the brfa value to the register*/
 418:../drivers/fsl_uart.c ****         base->C4 = (base->C4 & ~UART_C4_BRFA_MASK) | (brfa & UART_C4_BRFA_MASK);
 419:../drivers/fsl_uart.c **** #endif
 420:../drivers/fsl_uart.c ****         /* Restore C2. */
 421:../drivers/fsl_uart.c ****         base->C2 = oldCtrl;
 1196              		.loc 4 421 18
 1197 0102 FB68     		ldr	r3, [r7, #12]
 1198 0104 7A18     		adds	r2, r7, r1
 1199 0106 1278     		ldrb	r2, [r2]
 1200 0108 DA70     		strb	r2, [r3, #3]
 422:../drivers/fsl_uart.c **** 
 423:../drivers/fsl_uart.c ****         return kStatus_Success;
 1201              		.loc 4 423 16
 1202 010a 0023     		movs	r3, #0
 1203 010c 00E0     		b	.L63
 1204              	.L62:
 424:../drivers/fsl_uart.c ****     }
 425:../drivers/fsl_uart.c ****     else
 426:../drivers/fsl_uart.c ****     {
 427:../drivers/fsl_uart.c ****         /* Unacceptable baud rate difference of more than 3%*/
 428:../drivers/fsl_uart.c ****         return kStatus_UART_BaudrateNotSupport;
 1205              		.loc 4 428 16
 1206 010e 034B     		ldr	r3, .L64+4
 1207              	.L63:
 429:../drivers/fsl_uart.c ****     }
 430:../drivers/fsl_uart.c **** }
 1208              		.loc 4 430 1
 1209 0110 1800     		movs	r0, r3
 1210 0112 BD46     		mov	sp, r7
 1211 0114 09B0     		add	sp, sp, #36
 1212              		@ sp needed
 1213 0116 90BD     		pop	{r4, r7, pc}
 1214              	.L65:
 1215              		.align	2
 1216              	.L64:
 1217 0118 00000000 		.word	.LC15
 1218 011c F5030000 		.word	1013
 1219              		.cfi_endproc
 1220              	.LFE69:
 1222              		.section	.text.UART_EnableInterrupts,"ax",%progbits
 1223              		.align	1
 1224              		.global	UART_EnableInterrupts
 1225              		.syntax unified
 1226              		.code	16
 1227              		.thumb_func
 1228              		.fpu softvfp
 1230              	UART_EnableInterrupts:
 1231              	.LFB70:
 431:../drivers/fsl_uart.c **** 
 432:../drivers/fsl_uart.c **** void UART_EnableInterrupts(UART_Type *base, uint32_t mask)
 433:../drivers/fsl_uart.c **** {
 1232              		.loc 4 433 1
 1233              		.cfi_startproc
 1234              		@ args = 0, pretend = 0, frame = 8
 1235              		@ frame_needed = 1, uses_anonymous_args = 0
 1236 0000 80B5     		push	{r7, lr}
 1237              		.cfi_def_cfa_offset 8
 1238              		.cfi_offset 7, -8
 1239              		.cfi_offset 14, -4
 1240 0002 82B0     		sub	sp, sp, #8
 1241              		.cfi_def_cfa_offset 16
 1242 0004 00AF     		add	r7, sp, #0
 1243              		.cfi_def_cfa_register 7
 1244 0006 7860     		str	r0, [r7, #4]
 1245 0008 3960     		str	r1, [r7]
 434:../drivers/fsl_uart.c ****     mask &= kUART_AllInterruptsEnable;
 1246              		.loc 4 434 10
 1247 000a 3B68     		ldr	r3, [r7]
 1248 000c 114A     		ldr	r2, .L67
 1249 000e 1340     		ands	r3, r2
 1250 0010 3B60     		str	r3, [r7]
 435:../drivers/fsl_uart.c **** 
 436:../drivers/fsl_uart.c ****     /* The interrupt mask is combined by control bits from several register: ((CFIFO<<24) | (C3<<16
 437:../drivers/fsl_uart.c ****      */
 438:../drivers/fsl_uart.c ****     base->BDH |= mask;
 1251              		.loc 4 438 15
 1252 0012 7B68     		ldr	r3, [r7, #4]
 1253 0014 1B78     		ldrb	r3, [r3]
 1254 0016 DAB2     		uxtb	r2, r3
 1255 0018 3B68     		ldr	r3, [r7]
 1256 001a DBB2     		uxtb	r3, r3
 1257 001c 1343     		orrs	r3, r2
 1258 001e DAB2     		uxtb	r2, r3
 1259 0020 7B68     		ldr	r3, [r7, #4]
 1260 0022 1A70     		strb	r2, [r3]
 439:../drivers/fsl_uart.c ****     base->C2 |= (mask >> 8);
 1261              		.loc 4 439 14
 1262 0024 7B68     		ldr	r3, [r7, #4]
 1263 0026 DB78     		ldrb	r3, [r3, #3]
 1264 0028 DAB2     		uxtb	r2, r3
 1265              		.loc 4 439 23
 1266 002a 3B68     		ldr	r3, [r7]
 1267 002c 1B0A     		lsrs	r3, r3, #8
 1268              		.loc 4 439 14
 1269 002e DBB2     		uxtb	r3, r3
 1270 0030 1343     		orrs	r3, r2
 1271 0032 DAB2     		uxtb	r2, r3
 1272 0034 7B68     		ldr	r3, [r7, #4]
 1273 0036 DA70     		strb	r2, [r3, #3]
 440:../drivers/fsl_uart.c ****     base->C3 |= (mask >> 16);
 1274              		.loc 4 440 14
 1275 0038 7B68     		ldr	r3, [r7, #4]
 1276 003a 9B79     		ldrb	r3, [r3, #6]
 1277 003c DAB2     		uxtb	r2, r3
 1278              		.loc 4 440 23
 1279 003e 3B68     		ldr	r3, [r7]
 1280 0040 1B0C     		lsrs	r3, r3, #16
 1281              		.loc 4 440 14
 1282 0042 DBB2     		uxtb	r3, r3
 1283 0044 1343     		orrs	r3, r2
 1284 0046 DAB2     		uxtb	r2, r3
 1285 0048 7B68     		ldr	r3, [r7, #4]
 1286 004a 9A71     		strb	r2, [r3, #6]
 441:../drivers/fsl_uart.c **** 
 442:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
 443:../drivers/fsl_uart.c ****     base->CFIFO |= (mask >> 24);
 444:../drivers/fsl_uart.c **** #endif
 445:../drivers/fsl_uart.c **** }
 1287              		.loc 4 445 1
 1288 004c C046     		nop
 1289 004e BD46     		mov	sp, r7
 1290 0050 02B0     		add	sp, sp, #8
 1291              		@ sp needed
 1292 0052 80BD     		pop	{r7, pc}
 1293              	.L68:
 1294              		.align	2
 1295              	.L67:
 1296 0054 C0F00F00 		.word	1044672
 1297              		.cfi_endproc
 1298              	.LFE70:
 1300              		.section	.text.UART_DisableInterrupts,"ax",%progbits
 1301              		.align	1
 1302              		.global	UART_DisableInterrupts
 1303              		.syntax unified
 1304              		.code	16
 1305              		.thumb_func
 1306              		.fpu softvfp
 1308              	UART_DisableInterrupts:
 1309              	.LFB71:
 446:../drivers/fsl_uart.c **** 
 447:../drivers/fsl_uart.c **** void UART_DisableInterrupts(UART_Type *base, uint32_t mask)
 448:../drivers/fsl_uart.c **** {
 1310              		.loc 4 448 1
 1311              		.cfi_startproc
 1312              		@ args = 0, pretend = 0, frame = 8
 1313              		@ frame_needed = 1, uses_anonymous_args = 0
 1314 0000 80B5     		push	{r7, lr}
 1315              		.cfi_def_cfa_offset 8
 1316              		.cfi_offset 7, -8
 1317              		.cfi_offset 14, -4
 1318 0002 82B0     		sub	sp, sp, #8
 1319              		.cfi_def_cfa_offset 16
 1320 0004 00AF     		add	r7, sp, #0
 1321              		.cfi_def_cfa_register 7
 1322 0006 7860     		str	r0, [r7, #4]
 1323 0008 3960     		str	r1, [r7]
 449:../drivers/fsl_uart.c ****     mask &= kUART_AllInterruptsEnable;
 1324              		.loc 4 449 10
 1325 000a 3B68     		ldr	r3, [r7]
 1326 000c 144A     		ldr	r2, .L70
 1327 000e 1340     		ands	r3, r2
 1328 0010 3B60     		str	r3, [r7]
 450:../drivers/fsl_uart.c **** 
 451:../drivers/fsl_uart.c ****     /* The interrupt mask is combined by control bits from several register: ((CFIFO<<24) | (C3<<16
 452:../drivers/fsl_uart.c ****      */
 453:../drivers/fsl_uart.c ****     base->BDH &= ~mask;
 1329              		.loc 4 453 15
 1330 0012 7B68     		ldr	r3, [r7, #4]
 1331 0014 1B78     		ldrb	r3, [r3]
 1332 0016 DBB2     		uxtb	r3, r3
 1333 0018 3A68     		ldr	r2, [r7]
 1334 001a D2B2     		uxtb	r2, r2
 1335 001c D243     		mvns	r2, r2
 1336 001e D2B2     		uxtb	r2, r2
 1337 0020 1340     		ands	r3, r2
 1338 0022 DAB2     		uxtb	r2, r3
 1339 0024 7B68     		ldr	r3, [r7, #4]
 1340 0026 1A70     		strb	r2, [r3]
 454:../drivers/fsl_uart.c ****     base->C2 &= ~(mask >> 8);
 1341              		.loc 4 454 14
 1342 0028 7B68     		ldr	r3, [r7, #4]
 1343 002a DB78     		ldrb	r3, [r3, #3]
 1344 002c DBB2     		uxtb	r3, r3
 1345              		.loc 4 454 24
 1346 002e 3A68     		ldr	r2, [r7]
 1347 0030 120A     		lsrs	r2, r2, #8
 1348              		.loc 4 454 14
 1349 0032 D2B2     		uxtb	r2, r2
 1350 0034 D243     		mvns	r2, r2
 1351 0036 D2B2     		uxtb	r2, r2
 1352 0038 1340     		ands	r3, r2
 1353 003a DAB2     		uxtb	r2, r3
 1354 003c 7B68     		ldr	r3, [r7, #4]
 1355 003e DA70     		strb	r2, [r3, #3]
 455:../drivers/fsl_uart.c ****     base->C3 &= ~(mask >> 16);
 1356              		.loc 4 455 14
 1357 0040 7B68     		ldr	r3, [r7, #4]
 1358 0042 9B79     		ldrb	r3, [r3, #6]
 1359 0044 DBB2     		uxtb	r3, r3
 1360              		.loc 4 455 24
 1361 0046 3A68     		ldr	r2, [r7]
 1362 0048 120C     		lsrs	r2, r2, #16
 1363              		.loc 4 455 14
 1364 004a D2B2     		uxtb	r2, r2
 1365 004c D243     		mvns	r2, r2
 1366 004e D2B2     		uxtb	r2, r2
 1367 0050 1340     		ands	r3, r2
 1368 0052 DAB2     		uxtb	r2, r3
 1369 0054 7B68     		ldr	r3, [r7, #4]
 1370 0056 9A71     		strb	r2, [r3, #6]
 456:../drivers/fsl_uart.c **** 
 457:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
 458:../drivers/fsl_uart.c ****     base->CFIFO &= ~(mask >> 24);
 459:../drivers/fsl_uart.c **** #endif
 460:../drivers/fsl_uart.c **** }
 1371              		.loc 4 460 1
 1372 0058 C046     		nop
 1373 005a BD46     		mov	sp, r7
 1374 005c 02B0     		add	sp, sp, #8
 1375              		@ sp needed
 1376 005e 80BD     		pop	{r7, pc}
 1377              	.L71:
 1378              		.align	2
 1379              	.L70:
 1380 0060 C0F00F00 		.word	1044672
 1381              		.cfi_endproc
 1382              	.LFE71:
 1384              		.section	.text.UART_GetEnabledInterrupts,"ax",%progbits
 1385              		.align	1
 1386              		.global	UART_GetEnabledInterrupts
 1387              		.syntax unified
 1388              		.code	16
 1389              		.thumb_func
 1390              		.fpu softvfp
 1392              	UART_GetEnabledInterrupts:
 1393              	.LFB72:
 461:../drivers/fsl_uart.c **** 
 462:../drivers/fsl_uart.c **** uint32_t UART_GetEnabledInterrupts(UART_Type *base)
 463:../drivers/fsl_uart.c **** {
 1394              		.loc 4 463 1
 1395              		.cfi_startproc
 1396              		@ args = 0, pretend = 0, frame = 16
 1397              		@ frame_needed = 1, uses_anonymous_args = 0
 1398 0000 80B5     		push	{r7, lr}
 1399              		.cfi_def_cfa_offset 8
 1400              		.cfi_offset 7, -8
 1401              		.cfi_offset 14, -4
 1402 0002 84B0     		sub	sp, sp, #16
 1403              		.cfi_def_cfa_offset 24
 1404 0004 00AF     		add	r7, sp, #0
 1405              		.cfi_def_cfa_register 7
 1406 0006 7860     		str	r0, [r7, #4]
 464:../drivers/fsl_uart.c ****     uint32_t temp;
 465:../drivers/fsl_uart.c **** 
 466:../drivers/fsl_uart.c ****     temp = base->BDH | ((uint32_t)(base->C2) << 8) | ((uint32_t)(base->C3) << 16);
 1407              		.loc 4 466 16
 1408 0008 7B68     		ldr	r3, [r7, #4]
 1409 000a 1B78     		ldrb	r3, [r3]
 1410 000c DBB2     		uxtb	r3, r3
 1411 000e 1A00     		movs	r2, r3
 1412              		.loc 4 466 40
 1413 0010 7B68     		ldr	r3, [r7, #4]
 1414 0012 DB78     		ldrb	r3, [r3, #3]
 1415 0014 DBB2     		uxtb	r3, r3
 1416              		.loc 4 466 46
 1417 0016 1B02     		lsls	r3, r3, #8
 1418              		.loc 4 466 22
 1419 0018 1A43     		orrs	r2, r3
 1420              		.loc 4 466 70
 1421 001a 7B68     		ldr	r3, [r7, #4]
 1422 001c 9B79     		ldrb	r3, [r3, #6]
 1423 001e DBB2     		uxtb	r3, r3
 1424              		.loc 4 466 76
 1425 0020 1B04     		lsls	r3, r3, #16
 1426              		.loc 4 466 10
 1427 0022 1343     		orrs	r3, r2
 1428 0024 FB60     		str	r3, [r7, #12]
 467:../drivers/fsl_uart.c **** 
 468:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
 469:../drivers/fsl_uart.c ****     temp |= ((uint32_t)(base->CFIFO) << 24);
 470:../drivers/fsl_uart.c **** #endif
 471:../drivers/fsl_uart.c **** 
 472:../drivers/fsl_uart.c ****     return temp & kUART_AllInterruptsEnable;
 1429              		.loc 4 472 17
 1430 0026 FB68     		ldr	r3, [r7, #12]
 1431 0028 024A     		ldr	r2, .L74
 1432 002a 1340     		ands	r3, r2
 473:../drivers/fsl_uart.c **** }
 1433              		.loc 4 473 1
 1434 002c 1800     		movs	r0, r3
 1435 002e BD46     		mov	sp, r7
 1436 0030 04B0     		add	sp, sp, #16
 1437              		@ sp needed
 1438 0032 80BD     		pop	{r7, pc}
 1439              	.L75:
 1440              		.align	2
 1441              	.L74:
 1442 0034 C0F00F00 		.word	1044672
 1443              		.cfi_endproc
 1444              	.LFE72:
 1446              		.section	.text.UART_GetStatusFlags,"ax",%progbits
 1447              		.align	1
 1448              		.global	UART_GetStatusFlags
 1449              		.syntax unified
 1450              		.code	16
 1451              		.thumb_func
 1452              		.fpu softvfp
 1454              	UART_GetStatusFlags:
 1455              	.LFB73:
 474:../drivers/fsl_uart.c **** 
 475:../drivers/fsl_uart.c **** uint32_t UART_GetStatusFlags(UART_Type *base)
 476:../drivers/fsl_uart.c **** {
 1456              		.loc 4 476 1
 1457              		.cfi_startproc
 1458              		@ args = 0, pretend = 0, frame = 16
 1459              		@ frame_needed = 1, uses_anonymous_args = 0
 1460 0000 80B5     		push	{r7, lr}
 1461              		.cfi_def_cfa_offset 8
 1462              		.cfi_offset 7, -8
 1463              		.cfi_offset 14, -4
 1464 0002 84B0     		sub	sp, sp, #16
 1465              		.cfi_def_cfa_offset 24
 1466 0004 00AF     		add	r7, sp, #0
 1467              		.cfi_def_cfa_register 7
 1468 0006 7860     		str	r0, [r7, #4]
 477:../drivers/fsl_uart.c ****     uint32_t status_flag;
 478:../drivers/fsl_uart.c **** 
 479:../drivers/fsl_uart.c ****     status_flag = base->S1 | ((uint32_t)(base->S2) << 8);
 1469              		.loc 4 479 23
 1470 0008 7B68     		ldr	r3, [r7, #4]
 1471 000a 1B79     		ldrb	r3, [r3, #4]
 1472 000c DBB2     		uxtb	r3, r3
 1473 000e 1A00     		movs	r2, r3
 1474              		.loc 4 479 46
 1475 0010 7B68     		ldr	r3, [r7, #4]
 1476 0012 5B79     		ldrb	r3, [r3, #5]
 1477 0014 DBB2     		uxtb	r3, r3
 1478              		.loc 4 479 52
 1479 0016 1B02     		lsls	r3, r3, #8
 1480              		.loc 4 479 17
 1481 0018 1343     		orrs	r3, r2
 1482 001a FB60     		str	r3, [r7, #12]
 480:../drivers/fsl_uart.c **** 
 481:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_EXTENDED_DATA_REGISTER_FLAGS) && FSL_FEATURE_UART_HAS_EXTENDED_DAT
 482:../drivers/fsl_uart.c ****     status_flag |= ((uint32_t)(base->ED) << 16);
 483:../drivers/fsl_uart.c **** #endif
 484:../drivers/fsl_uart.c **** 
 485:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
 486:../drivers/fsl_uart.c ****     status_flag |= ((uint32_t)(base->SFIFO) << 24);
 487:../drivers/fsl_uart.c **** #endif
 488:../drivers/fsl_uart.c **** 
 489:../drivers/fsl_uart.c ****     return status_flag;
 1483              		.loc 4 489 12
 1484 001c FB68     		ldr	r3, [r7, #12]
 490:../drivers/fsl_uart.c **** }
 1485              		.loc 4 490 1
 1486 001e 1800     		movs	r0, r3
 1487 0020 BD46     		mov	sp, r7
 1488 0022 04B0     		add	sp, sp, #16
 1489              		@ sp needed
 1490 0024 80BD     		pop	{r7, pc}
 1491              		.cfi_endproc
 1492              	.LFE73:
 1494              		.section	.text.UART_ClearStatusFlags,"ax",%progbits
 1495              		.align	1
 1496              		.global	UART_ClearStatusFlags
 1497              		.syntax unified
 1498              		.code	16
 1499              		.thumb_func
 1500              		.fpu softvfp
 1502              	UART_ClearStatusFlags:
 1503              	.LFB74:
 491:../drivers/fsl_uart.c **** 
 492:../drivers/fsl_uart.c **** status_t UART_ClearStatusFlags(UART_Type *base, uint32_t mask)
 493:../drivers/fsl_uart.c **** {
 1504              		.loc 4 493 1
 1505              		.cfi_startproc
 1506              		@ args = 0, pretend = 0, frame = 16
 1507              		@ frame_needed = 1, uses_anonymous_args = 0
 1508 0000 80B5     		push	{r7, lr}
 1509              		.cfi_def_cfa_offset 8
 1510              		.cfi_offset 7, -8
 1511              		.cfi_offset 14, -4
 1512 0002 84B0     		sub	sp, sp, #16
 1513              		.cfi_def_cfa_offset 24
 1514 0004 00AF     		add	r7, sp, #0
 1515              		.cfi_def_cfa_register 7
 1516 0006 7860     		str	r0, [r7, #4]
 1517 0008 3960     		str	r1, [r7]
 494:../drivers/fsl_uart.c ****     uint8_t reg = base->S2;
 1518              		.loc 4 494 13
 1519 000a 0B20     		movs	r0, #11
 1520 000c 3B18     		adds	r3, r7, r0
 1521 000e 7A68     		ldr	r2, [r7, #4]
 1522 0010 5279     		ldrb	r2, [r2, #5]
 1523 0012 1A70     		strb	r2, [r3]
 495:../drivers/fsl_uart.c ****     status_t status;
 496:../drivers/fsl_uart.c **** 
 497:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_LIN_BREAK_DETECT) && FSL_FEATURE_UART_HAS_LIN_BREAK_DETECT
 498:../drivers/fsl_uart.c ****     reg &= ~(UART_S2_RXEDGIF_MASK | UART_S2_LBKDIF_MASK);
 1524              		.loc 4 498 9
 1525 0014 3B18     		adds	r3, r7, r0
 1526 0016 3A18     		adds	r2, r7, r0
 1527 0018 1278     		ldrb	r2, [r2]
 1528 001a 3F21     		movs	r1, #63
 1529 001c 0A40     		ands	r2, r1
 1530 001e 1A70     		strb	r2, [r3]
 499:../drivers/fsl_uart.c **** #else
 500:../drivers/fsl_uart.c ****     reg &= ~UART_S2_RXEDGIF_MASK;
 501:../drivers/fsl_uart.c **** #endif
 502:../drivers/fsl_uart.c **** 
 503:../drivers/fsl_uart.c ****     base->S2 = reg | (uint8_t)(mask >> 8);
 1531              		.loc 4 503 37
 1532 0020 3B68     		ldr	r3, [r7]
 1533 0022 1B0A     		lsrs	r3, r3, #8
 1534              		.loc 4 503 22
 1535 0024 DAB2     		uxtb	r2, r3
 1536              		.loc 4 503 14
 1537 0026 3B18     		adds	r3, r7, r0
 1538 0028 1B78     		ldrb	r3, [r3]
 1539 002a 1343     		orrs	r3, r2
 1540 002c DAB2     		uxtb	r2, r3
 1541 002e 7B68     		ldr	r3, [r7, #4]
 1542 0030 5A71     		strb	r2, [r3, #5]
 504:../drivers/fsl_uart.c **** 
 505:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
 506:../drivers/fsl_uart.c ****     base->SFIFO = (uint8_t)(mask >> 24);
 507:../drivers/fsl_uart.c **** #endif
 508:../drivers/fsl_uart.c **** 
 509:../drivers/fsl_uart.c ****     if (mask & (kUART_IdleLineFlag | kUART_NoiseErrorFlag | kUART_FramingErrorFlag | kUART_ParityEr
 1543              		.loc 4 509 14
 1544 0032 3B68     		ldr	r3, [r7]
 1545 0034 1722     		movs	r2, #23
 1546 0036 1340     		ands	r3, r2
 1547              		.loc 4 509 8
 1548 0038 03D0     		beq	.L79
 510:../drivers/fsl_uart.c ****     {
 511:../drivers/fsl_uart.c ****         /* Read base->D to clear the flags. */
 512:../drivers/fsl_uart.c ****         (void)base->S1;
 1549              		.loc 4 512 9
 1550 003a 7B68     		ldr	r3, [r7, #4]
 1551 003c 1B79     		ldrb	r3, [r3, #4]
 513:../drivers/fsl_uart.c ****         (void)base->D;
 1552              		.loc 4 513 9
 1553 003e 7B68     		ldr	r3, [r7, #4]
 1554 0040 DB79     		ldrb	r3, [r3, #7]
 1555              	.L79:
 514:../drivers/fsl_uart.c ****     }
 515:../drivers/fsl_uart.c **** 
 516:../drivers/fsl_uart.c ****     if (mask & kUART_RxOverrunFlag)
 1556              		.loc 4 516 14
 1557 0042 3B68     		ldr	r3, [r7]
 1558 0044 0822     		movs	r2, #8
 1559 0046 1340     		ands	r3, r2
 1560              		.loc 4 516 8
 1561 0048 03D0     		beq	.L80
 517:../drivers/fsl_uart.c ****     {
 518:../drivers/fsl_uart.c ****         /* Read base->D to clear the flags and Flush all data in FIFO. */
 519:../drivers/fsl_uart.c ****         (void)base->S1;
 1562              		.loc 4 519 9
 1563 004a 7B68     		ldr	r3, [r7, #4]
 1564 004c 1B79     		ldrb	r3, [r3, #4]
 520:../drivers/fsl_uart.c ****         (void)base->D;
 1565              		.loc 4 520 9
 1566 004e 7B68     		ldr	r3, [r7, #4]
 1567 0050 DB79     		ldrb	r3, [r3, #7]
 1568              	.L80:
 521:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
 522:../drivers/fsl_uart.c ****         /* Flush FIFO date, otherwise FIFO pointer will be in unknown state. */
 523:../drivers/fsl_uart.c ****         base->CFIFO |= UART_CFIFO_RXFLUSH_MASK;
 524:../drivers/fsl_uart.c **** #endif
 525:../drivers/fsl_uart.c ****     }
 526:../drivers/fsl_uart.c **** 
 527:../drivers/fsl_uart.c ****     /* If some flags still pending. */
 528:../drivers/fsl_uart.c ****     if (mask & UART_GetStatusFlags(base))
 1569              		.loc 4 528 16
 1570 0052 7B68     		ldr	r3, [r7, #4]
 1571 0054 1800     		movs	r0, r3
 1572 0056 FFF7FEFF 		bl	UART_GetStatusFlags
 1573 005a 0200     		movs	r2, r0
 1574              		.loc 4 528 14
 1575 005c 3B68     		ldr	r3, [r7]
 1576 005e 1340     		ands	r3, r2
 1577              		.loc 4 528 8
 1578 0060 02D0     		beq	.L81
 529:../drivers/fsl_uart.c ****     {
 530:../drivers/fsl_uart.c ****         /* Some flags can only clear or set by the hardware itself, these flags are: kUART_TxDataRe
 531:../drivers/fsl_uart.c ****         kUART_TransmissionCompleteFlag, kUART_RxDataRegFullFlag, kUART_RxActiveFlag, kUART_NoiseErr
 532:../drivers/fsl_uart.c ****         kUART_ParityErrorInRxDataRegFlag, kUART_TxFifoEmptyFlag, kUART_RxFifoEmptyFlag. */
 533:../drivers/fsl_uart.c ****         status = kStatus_UART_FlagCannotClearManually;
 1579              		.loc 4 533 16
 1580 0062 054B     		ldr	r3, .L84
 1581 0064 FB60     		str	r3, [r7, #12]
 1582 0066 01E0     		b	.L82
 1583              	.L81:
 534:../drivers/fsl_uart.c ****     }
 535:../drivers/fsl_uart.c ****     else
 536:../drivers/fsl_uart.c ****     {
 537:../drivers/fsl_uart.c ****         status = kStatus_Success;
 1584              		.loc 4 537 16
 1585 0068 0023     		movs	r3, #0
 1586 006a FB60     		str	r3, [r7, #12]
 1587              	.L82:
 538:../drivers/fsl_uart.c ****     }
 539:../drivers/fsl_uart.c **** 
 540:../drivers/fsl_uart.c ****     return status;
 1588              		.loc 4 540 12
 1589 006c FB68     		ldr	r3, [r7, #12]
 541:../drivers/fsl_uart.c **** }
 1590              		.loc 4 541 1
 1591 006e 1800     		movs	r0, r3
 1592 0070 BD46     		mov	sp, r7
 1593 0072 04B0     		add	sp, sp, #16
 1594              		@ sp needed
 1595 0074 80BD     		pop	{r7, pc}
 1596              	.L85:
 1597 0076 C046     		.align	2
 1598              	.L84:
 1599 0078 EE030000 		.word	1006
 1600              		.cfi_endproc
 1601              	.LFE74:
 1603              		.section	.text.UART_WriteBlocking,"ax",%progbits
 1604              		.align	1
 1605              		.global	UART_WriteBlocking
 1606              		.syntax unified
 1607              		.code	16
 1608              		.thumb_func
 1609              		.fpu softvfp
 1611              	UART_WriteBlocking:
 1612              	.LFB75:
 542:../drivers/fsl_uart.c **** 
 543:../drivers/fsl_uart.c **** void UART_WriteBlocking(UART_Type *base, const uint8_t *data, size_t length)
 544:../drivers/fsl_uart.c **** {
 1613              		.loc 4 544 1
 1614              		.cfi_startproc
 1615              		@ args = 0, pretend = 0, frame = 16
 1616              		@ frame_needed = 1, uses_anonymous_args = 0
 1617 0000 80B5     		push	{r7, lr}
 1618              		.cfi_def_cfa_offset 8
 1619              		.cfi_offset 7, -8
 1620              		.cfi_offset 14, -4
 1621 0002 84B0     		sub	sp, sp, #16
 1622              		.cfi_def_cfa_offset 24
 1623 0004 00AF     		add	r7, sp, #0
 1624              		.cfi_def_cfa_register 7
 1625 0006 F860     		str	r0, [r7, #12]
 1626 0008 B960     		str	r1, [r7, #8]
 1627 000a 7A60     		str	r2, [r7, #4]
 545:../drivers/fsl_uart.c ****     /* This API can only ensure that the data is written into the data buffer but can't
 546:../drivers/fsl_uart.c ****     ensure all data in the data buffer are sent into the transmit shift buffer. */
 547:../drivers/fsl_uart.c ****     while (length--)
 1628              		.loc 4 547 11
 1629 000c 0CE0     		b	.L87
 1630              	.L89:
 548:../drivers/fsl_uart.c ****     {
 549:../drivers/fsl_uart.c ****         while (!(base->S1 & UART_S1_TDRE_MASK))
 1631              		.loc 4 549 15
 1632 000e C046     		nop
 1633              	.L88:
 1634              		.loc 4 549 22 discriminator 1
 1635 0010 FB68     		ldr	r3, [r7, #12]
 1636 0012 1B79     		ldrb	r3, [r3, #4]
 1637 0014 DBB2     		uxtb	r3, r3
 1638              		.loc 4 549 16 discriminator 1
 1639 0016 5BB2     		sxtb	r3, r3
 1640              		.loc 4 549 15 discriminator 1
 1641 0018 002B     		cmp	r3, #0
 1642 001a F9DA     		bge	.L88
 550:../drivers/fsl_uart.c ****         {
 551:../drivers/fsl_uart.c ****         }
 552:../drivers/fsl_uart.c ****         base->D = *(data++);
 1643              		.loc 4 552 25
 1644 001c BB68     		ldr	r3, [r7, #8]
 1645 001e 5A1C     		adds	r2, r3, #1
 1646 0020 BA60     		str	r2, [r7, #8]
 1647              		.loc 4 552 19
 1648 0022 1A78     		ldrb	r2, [r3]
 1649              		.loc 4 552 17
 1650 0024 FB68     		ldr	r3, [r7, #12]
 1651 0026 DA71     		strb	r2, [r3, #7]
 1652              	.L87:
 547:../drivers/fsl_uart.c ****     {
 1653              		.loc 4 547 18
 1654 0028 7B68     		ldr	r3, [r7, #4]
 1655 002a 5A1E     		subs	r2, r3, #1
 1656 002c 7A60     		str	r2, [r7, #4]
 547:../drivers/fsl_uart.c ****     {
 1657              		.loc 4 547 11
 1658 002e 002B     		cmp	r3, #0
 1659 0030 EDD1     		bne	.L89
 553:../drivers/fsl_uart.c ****     }
 554:../drivers/fsl_uart.c **** }
 1660              		.loc 4 554 1
 1661 0032 C046     		nop
 1662 0034 C046     		nop
 1663 0036 BD46     		mov	sp, r7
 1664 0038 04B0     		add	sp, sp, #16
 1665              		@ sp needed
 1666 003a 80BD     		pop	{r7, pc}
 1667              		.cfi_endproc
 1668              	.LFE75:
 1670              		.section	.rodata.UART_WriteNonBlocking.str1.4,"aMS",%progbits,1
 1671              		.align	2
 1672              	.LC17:
 1673 0000 2E66736C 		.ascii	".fsl_uart.c:558 : data\000"
 1673      5F756172 
 1673      742E633A 
 1673      35353820 
 1673      3A206461 
 1674              		.section	.text.UART_WriteNonBlocking,"ax",%progbits
 1675              		.align	1
 1676              		.syntax unified
 1677              		.code	16
 1678              		.thumb_func
 1679              		.fpu softvfp
 1681              	UART_WriteNonBlocking:
 1682              	.LFB76:
 555:../drivers/fsl_uart.c **** 
 556:../drivers/fsl_uart.c **** static void UART_WriteNonBlocking(UART_Type *base, const uint8_t *data, size_t length)
 557:../drivers/fsl_uart.c **** {
 1683              		.loc 4 557 1
 1684              		.cfi_startproc
 1685              		@ args = 0, pretend = 0, frame = 24
 1686              		@ frame_needed = 1, uses_anonymous_args = 0
 1687 0000 80B5     		push	{r7, lr}
 1688              		.cfi_def_cfa_offset 8
 1689              		.cfi_offset 7, -8
 1690              		.cfi_offset 14, -4
 1691 0002 86B0     		sub	sp, sp, #24
 1692              		.cfi_def_cfa_offset 32
 1693 0004 00AF     		add	r7, sp, #0
 1694              		.cfi_def_cfa_register 7
 1695 0006 F860     		str	r0, [r7, #12]
 1696 0008 B960     		str	r1, [r7, #8]
 1697 000a 7A60     		str	r2, [r7, #4]
 558:../drivers/fsl_uart.c ****     assert(data);
 1698              		.loc 4 558 5
 1699 000c BB68     		ldr	r3, [r7, #8]
 1700 000e 002B     		cmp	r3, #0
 1701 0010 03D1     		bne	.L91
 1702              		.loc 4 558 5 is_stmt 0 discriminator 1
 1703 0012 0C4B     		ldr	r3, .L94
 1704 0014 1800     		movs	r0, r3
 1705 0016 FFF7FEFF 		bl	__assertion_failed
 1706              	.L91:
 559:../drivers/fsl_uart.c **** 
 560:../drivers/fsl_uart.c ****     size_t i;
 561:../drivers/fsl_uart.c **** 
 562:../drivers/fsl_uart.c ****     /* The Non Blocking write data API assume user have ensured there is enough space in
 563:../drivers/fsl_uart.c ****     peripheral to write. */
 564:../drivers/fsl_uart.c ****     for (i = 0; i < length; i++)
 1707              		.loc 4 564 12 is_stmt 1
 1708 001a 0023     		movs	r3, #0
 1709 001c 7B61     		str	r3, [r7, #20]
 1710              		.loc 4 564 5
 1711 001e 08E0     		b	.L92
 1712              	.L93:
 565:../drivers/fsl_uart.c ****     {
 566:../drivers/fsl_uart.c ****         base->D = data[i];
 1713              		.loc 4 566 23 discriminator 3
 1714 0020 BA68     		ldr	r2, [r7, #8]
 1715 0022 7B69     		ldr	r3, [r7, #20]
 1716 0024 D318     		adds	r3, r2, r3
 1717 0026 1A78     		ldrb	r2, [r3]
 1718              		.loc 4 566 17 discriminator 3
 1719 0028 FB68     		ldr	r3, [r7, #12]
 1720 002a DA71     		strb	r2, [r3, #7]
 564:../drivers/fsl_uart.c ****     {
 1721              		.loc 4 564 30 discriminator 3
 1722 002c 7B69     		ldr	r3, [r7, #20]
 1723 002e 0133     		adds	r3, r3, #1
 1724 0030 7B61     		str	r3, [r7, #20]
 1725              	.L92:
 564:../drivers/fsl_uart.c ****     {
 1726              		.loc 4 564 5 discriminator 1
 1727 0032 7A69     		ldr	r2, [r7, #20]
 1728 0034 7B68     		ldr	r3, [r7, #4]
 1729 0036 9A42     		cmp	r2, r3
 1730 0038 F2D3     		bcc	.L93
 567:../drivers/fsl_uart.c ****     }
 568:../drivers/fsl_uart.c **** }
 1731              		.loc 4 568 1
 1732 003a C046     		nop
 1733 003c C046     		nop
 1734 003e BD46     		mov	sp, r7
 1735 0040 06B0     		add	sp, sp, #24
 1736              		@ sp needed
 1737 0042 80BD     		pop	{r7, pc}
 1738              	.L95:
 1739              		.align	2
 1740              	.L94:
 1741 0044 00000000 		.word	.LC17
 1742              		.cfi_endproc
 1743              	.LFE76:
 1745              		.section	.rodata.UART_ReadBlocking.str1.4,"aMS",%progbits,1
 1746              		.align	2
 1747              	.LC19:
 1748 0000 2E66736C 		.ascii	".fsl_uart.c:572 : data\000"
 1748      5F756172 
 1748      742E633A 
 1748      35373220 
 1748      3A206461 
 1749              		.section	.text.UART_ReadBlocking,"ax",%progbits
 1750              		.align	1
 1751              		.global	UART_ReadBlocking
 1752              		.syntax unified
 1753              		.code	16
 1754              		.thumb_func
 1755              		.fpu softvfp
 1757              	UART_ReadBlocking:
 1758              	.LFB77:
 569:../drivers/fsl_uart.c **** 
 570:../drivers/fsl_uart.c **** status_t UART_ReadBlocking(UART_Type *base, uint8_t *data, size_t length)
 571:../drivers/fsl_uart.c **** {
 1759              		.loc 4 571 1
 1760              		.cfi_startproc
 1761              		@ args = 0, pretend = 0, frame = 24
 1762              		@ frame_needed = 1, uses_anonymous_args = 0
 1763 0000 80B5     		push	{r7, lr}
 1764              		.cfi_def_cfa_offset 8
 1765              		.cfi_offset 7, -8
 1766              		.cfi_offset 14, -4
 1767 0002 86B0     		sub	sp, sp, #24
 1768              		.cfi_def_cfa_offset 32
 1769 0004 00AF     		add	r7, sp, #0
 1770              		.cfi_def_cfa_register 7
 1771 0006 F860     		str	r0, [r7, #12]
 1772 0008 B960     		str	r1, [r7, #8]
 1773 000a 7A60     		str	r2, [r7, #4]
 572:../drivers/fsl_uart.c ****     assert(data);
 1774              		.loc 4 572 5
 1775 000c BB68     		ldr	r3, [r7, #8]
 1776 000e 002B     		cmp	r3, #0
 1777 0010 30D1     		bne	.L98
 1778              		.loc 4 572 5 is_stmt 0 discriminator 1
 1779 0012 1D4B     		ldr	r3, .L106
 1780 0014 1800     		movs	r0, r3
 1781 0016 FFF7FEFF 		bl	__assertion_failed
 1782              	.L104:
 573:../drivers/fsl_uart.c **** 
 574:../drivers/fsl_uart.c ****     uint32_t statusFlag;
 575:../drivers/fsl_uart.c **** 
 576:../drivers/fsl_uart.c ****     while (length--)
 577:../drivers/fsl_uart.c ****     {
 578:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
 579:../drivers/fsl_uart.c ****         while (!base->RCFIFO)
 580:../drivers/fsl_uart.c **** #else
 581:../drivers/fsl_uart.c ****         while (!(base->S1 & UART_S1_RDRF_MASK))
 582:../drivers/fsl_uart.c **** #endif
 583:../drivers/fsl_uart.c ****         {
 584:../drivers/fsl_uart.c ****             statusFlag = UART_GetStatusFlags(base);
 1783              		.loc 4 584 26 is_stmt 1
 1784 001a FB68     		ldr	r3, [r7, #12]
 1785 001c 1800     		movs	r0, r3
 1786 001e FFF7FEFF 		bl	UART_GetStatusFlags
 1787 0022 0300     		movs	r3, r0
 1788 0024 7B61     		str	r3, [r7, #20]
 585:../drivers/fsl_uart.c **** 
 586:../drivers/fsl_uart.c ****             if (statusFlag & kUART_RxOverrunFlag)
 1789              		.loc 4 586 28
 1790 0026 7B69     		ldr	r3, [r7, #20]
 1791 0028 0822     		movs	r2, #8
 1792 002a 1340     		ands	r3, r2
 1793              		.loc 4 586 16
 1794 002c 01D0     		beq	.L100
 587:../drivers/fsl_uart.c ****             {
 588:../drivers/fsl_uart.c ****                 return kStatus_UART_RxHardwareOverrun;
 1795              		.loc 4 588 24
 1796 002e 174B     		ldr	r3, .L106+4
 1797 0030 26E0     		b	.L101
 1798              	.L100:
 589:../drivers/fsl_uart.c ****             }
 590:../drivers/fsl_uart.c **** 
 591:../drivers/fsl_uart.c ****             if (statusFlag & kUART_NoiseErrorFlag)
 1799              		.loc 4 591 28
 1800 0032 7B69     		ldr	r3, [r7, #20]
 1801 0034 0422     		movs	r2, #4
 1802 0036 1340     		ands	r3, r2
 1803              		.loc 4 591 16
 1804 0038 01D0     		beq	.L102
 592:../drivers/fsl_uart.c ****             {
 593:../drivers/fsl_uart.c ****                 return kStatus_UART_NoiseError;
 1805              		.loc 4 593 24
 1806 003a 154B     		ldr	r3, .L106+8
 1807 003c 20E0     		b	.L101
 1808              	.L102:
 594:../drivers/fsl_uart.c ****             }
 595:../drivers/fsl_uart.c **** 
 596:../drivers/fsl_uart.c ****             if (statusFlag & kUART_FramingErrorFlag)
 1809              		.loc 4 596 28
 1810 003e 7B69     		ldr	r3, [r7, #20]
 1811 0040 0222     		movs	r2, #2
 1812 0042 1340     		ands	r3, r2
 1813              		.loc 4 596 16
 1814 0044 01D0     		beq	.L103
 597:../drivers/fsl_uart.c ****             {
 598:../drivers/fsl_uart.c ****                 return kStatus_UART_FramingError;
 1815              		.loc 4 598 24
 1816 0046 134B     		ldr	r3, .L106+12
 1817 0048 1AE0     		b	.L101
 1818              	.L103:
 599:../drivers/fsl_uart.c ****             }
 600:../drivers/fsl_uart.c **** 
 601:../drivers/fsl_uart.c ****             if (statusFlag & kUART_ParityErrorFlag)
 1819              		.loc 4 601 28
 1820 004a 7B69     		ldr	r3, [r7, #20]
 1821 004c 0122     		movs	r2, #1
 1822 004e 1340     		ands	r3, r2
 1823              		.loc 4 601 16
 1824 0050 02D0     		beq	.L99
 602:../drivers/fsl_uart.c ****             {
 603:../drivers/fsl_uart.c ****                 return kStatus_UART_ParityError;
 1825              		.loc 4 603 24
 1826 0052 FD23     		movs	r3, #253
 1827 0054 9B00     		lsls	r3, r3, #2
 1828 0056 13E0     		b	.L101
 1829              	.L99:
 581:../drivers/fsl_uart.c **** #endif
 1830              		.loc 4 581 22
 1831 0058 FB68     		ldr	r3, [r7, #12]
 1832 005a 1B79     		ldrb	r3, [r3, #4]
 1833 005c DBB2     		uxtb	r3, r3
 581:../drivers/fsl_uart.c **** #endif
 1834              		.loc 4 581 27
 1835 005e 1A00     		movs	r2, r3
 1836 0060 2023     		movs	r3, #32
 1837 0062 1340     		ands	r3, r2
 581:../drivers/fsl_uart.c **** #endif
 1838              		.loc 4 581 15
 1839 0064 D9D0     		beq	.L104
 604:../drivers/fsl_uart.c ****             }
 605:../drivers/fsl_uart.c ****         }
 606:../drivers/fsl_uart.c ****         *(data++) = base->D;
 1840              		.loc 4 606 15
 1841 0066 BB68     		ldr	r3, [r7, #8]
 1842 0068 5A1C     		adds	r2, r3, #1
 1843 006a BA60     		str	r2, [r7, #8]
 1844              		.loc 4 606 25
 1845 006c FA68     		ldr	r2, [r7, #12]
 1846 006e D279     		ldrb	r2, [r2, #7]
 1847 0070 D2B2     		uxtb	r2, r2
 1848              		.loc 4 606 19
 1849 0072 1A70     		strb	r2, [r3]
 1850              	.L98:
 576:../drivers/fsl_uart.c ****     {
 1851              		.loc 4 576 18
 1852 0074 7B68     		ldr	r3, [r7, #4]
 1853 0076 5A1E     		subs	r2, r3, #1
 1854 0078 7A60     		str	r2, [r7, #4]
 576:../drivers/fsl_uart.c ****     {
 1855              		.loc 4 576 11
 1856 007a 002B     		cmp	r3, #0
 1857 007c ECD1     		bne	.L99
 607:../drivers/fsl_uart.c ****     }
 608:../drivers/fsl_uart.c **** 
 609:../drivers/fsl_uart.c ****     return kStatus_Success;
 1858              		.loc 4 609 12
 1859 007e 0023     		movs	r3, #0
 1860              	.L101:
 610:../drivers/fsl_uart.c **** }
 1861              		.loc 4 610 1
 1862 0080 1800     		movs	r0, r3
 1863 0082 BD46     		mov	sp, r7
 1864 0084 06B0     		add	sp, sp, #24
 1865              		@ sp needed
 1866 0086 80BD     		pop	{r7, pc}
 1867              	.L107:
 1868              		.align	2
 1869              	.L106:
 1870 0088 00000000 		.word	.LC19
 1871 008c F1030000 		.word	1009
 1872 0090 F2030000 		.word	1010
 1873 0094 F3030000 		.word	1011
 1874              		.cfi_endproc
 1875              	.LFE77:
 1877              		.section	.rodata.UART_ReadNonBlocking.str1.4,"aMS",%progbits,1
 1878              		.align	2
 1879              	.LC21:
 1880 0000 2E66736C 		.ascii	".fsl_uart.c:614 : data\000"
 1880      5F756172 
 1880      742E633A 
 1880      36313420 
 1880      3A206461 
 1881              		.section	.text.UART_ReadNonBlocking,"ax",%progbits
 1882              		.align	1
 1883              		.syntax unified
 1884              		.code	16
 1885              		.thumb_func
 1886              		.fpu softvfp
 1888              	UART_ReadNonBlocking:
 1889              	.LFB78:
 611:../drivers/fsl_uart.c **** 
 612:../drivers/fsl_uart.c **** static void UART_ReadNonBlocking(UART_Type *base, uint8_t *data, size_t length)
 613:../drivers/fsl_uart.c **** {
 1890              		.loc 4 613 1
 1891              		.cfi_startproc
 1892              		@ args = 0, pretend = 0, frame = 24
 1893              		@ frame_needed = 1, uses_anonymous_args = 0
 1894 0000 80B5     		push	{r7, lr}
 1895              		.cfi_def_cfa_offset 8
 1896              		.cfi_offset 7, -8
 1897              		.cfi_offset 14, -4
 1898 0002 86B0     		sub	sp, sp, #24
 1899              		.cfi_def_cfa_offset 32
 1900 0004 00AF     		add	r7, sp, #0
 1901              		.cfi_def_cfa_register 7
 1902 0006 F860     		str	r0, [r7, #12]
 1903 0008 B960     		str	r1, [r7, #8]
 1904 000a 7A60     		str	r2, [r7, #4]
 614:../drivers/fsl_uart.c ****     assert(data);
 1905              		.loc 4 614 5
 1906 000c BB68     		ldr	r3, [r7, #8]
 1907 000e 002B     		cmp	r3, #0
 1908 0010 03D1     		bne	.L109
 1909              		.loc 4 614 5 is_stmt 0 discriminator 1
 1910 0012 0D4B     		ldr	r3, .L112
 1911 0014 1800     		movs	r0, r3
 1912 0016 FFF7FEFF 		bl	__assertion_failed
 1913              	.L109:
 615:../drivers/fsl_uart.c **** 
 616:../drivers/fsl_uart.c ****     size_t i;
 617:../drivers/fsl_uart.c **** 
 618:../drivers/fsl_uart.c ****     /* The Non Blocking read data API assume user have ensured there is enough space in
 619:../drivers/fsl_uart.c ****     peripheral to write. */
 620:../drivers/fsl_uart.c ****     for (i = 0; i < length; i++)
 1914              		.loc 4 620 12 is_stmt 1
 1915 001a 0023     		movs	r3, #0
 1916 001c 7B61     		str	r3, [r7, #20]
 1917              		.loc 4 620 5
 1918 001e 09E0     		b	.L110
 1919              	.L111:
 621:../drivers/fsl_uart.c ****     {
 622:../drivers/fsl_uart.c ****         data[i] = base->D;
 1920              		.loc 4 622 13 discriminator 3
 1921 0020 BA68     		ldr	r2, [r7, #8]
 1922 0022 7B69     		ldr	r3, [r7, #20]
 1923 0024 D318     		adds	r3, r2, r3
 1924              		.loc 4 622 23 discriminator 3
 1925 0026 FA68     		ldr	r2, [r7, #12]
 1926 0028 D279     		ldrb	r2, [r2, #7]
 1927 002a D2B2     		uxtb	r2, r2
 1928              		.loc 4 622 17 discriminator 3
 1929 002c 1A70     		strb	r2, [r3]
 620:../drivers/fsl_uart.c ****     {
 1930              		.loc 4 620 30 discriminator 3
 1931 002e 7B69     		ldr	r3, [r7, #20]
 1932 0030 0133     		adds	r3, r3, #1
 1933 0032 7B61     		str	r3, [r7, #20]
 1934              	.L110:
 620:../drivers/fsl_uart.c ****     {
 1935              		.loc 4 620 5 discriminator 1
 1936 0034 7A69     		ldr	r2, [r7, #20]
 1937 0036 7B68     		ldr	r3, [r7, #4]
 1938 0038 9A42     		cmp	r2, r3
 1939 003a F1D3     		bcc	.L111
 623:../drivers/fsl_uart.c ****     }
 624:../drivers/fsl_uart.c **** }
 1940              		.loc 4 624 1
 1941 003c C046     		nop
 1942 003e C046     		nop
 1943 0040 BD46     		mov	sp, r7
 1944 0042 06B0     		add	sp, sp, #24
 1945              		@ sp needed
 1946 0044 80BD     		pop	{r7, pc}
 1947              	.L113:
 1948 0046 C046     		.align	2
 1949              	.L112:
 1950 0048 00000000 		.word	.LC21
 1951              		.cfi_endproc
 1952              	.LFE78:
 1954              		.section	.rodata.UART_TransferCreateHandle.str1.4,"aMS",%progbits,1
 1955              		.align	2
 1956              	.LC23:
 1957 0000 2E66736C 		.ascii	".fsl_uart.c:631 : handle\000"
 1957      5F756172 
 1957      742E633A 
 1957      36333120 
 1957      3A206861 
 1958              		.section	.text.UART_TransferCreateHandle,"ax",%progbits
 1959              		.align	1
 1960              		.global	UART_TransferCreateHandle
 1961              		.syntax unified
 1962              		.code	16
 1963              		.thumb_func
 1964              		.fpu softvfp
 1966              	UART_TransferCreateHandle:
 1967              	.LFB79:
 625:../drivers/fsl_uart.c **** 
 626:../drivers/fsl_uart.c **** void UART_TransferCreateHandle(UART_Type *base,
 627:../drivers/fsl_uart.c ****                                uart_handle_t *handle,
 628:../drivers/fsl_uart.c ****                                uart_transfer_callback_t callback,
 629:../drivers/fsl_uart.c ****                                void *userData)
 630:../drivers/fsl_uart.c **** {
 1968              		.loc 4 630 1
 1969              		.cfi_startproc
 1970              		@ args = 0, pretend = 0, frame = 24
 1971              		@ frame_needed = 1, uses_anonymous_args = 0
 1972 0000 80B5     		push	{r7, lr}
 1973              		.cfi_def_cfa_offset 8
 1974              		.cfi_offset 7, -8
 1975              		.cfi_offset 14, -4
 1976 0002 86B0     		sub	sp, sp, #24
 1977              		.cfi_def_cfa_offset 32
 1978 0004 00AF     		add	r7, sp, #0
 1979              		.cfi_def_cfa_register 7
 1980 0006 F860     		str	r0, [r7, #12]
 1981 0008 B960     		str	r1, [r7, #8]
 1982 000a 7A60     		str	r2, [r7, #4]
 1983 000c 3B60     		str	r3, [r7]
 631:../drivers/fsl_uart.c ****     assert(handle);
 1984              		.loc 4 631 5
 1985 000e BB68     		ldr	r3, [r7, #8]
 1986 0010 002B     		cmp	r3, #0
 1987 0012 03D1     		bne	.L115
 1988              		.loc 4 631 5 is_stmt 0 discriminator 1
 1989 0014 184B     		ldr	r3, .L116
 1990 0016 1800     		movs	r0, r3
 1991 0018 FFF7FEFF 		bl	__assertion_failed
 1992              	.L115:
 632:../drivers/fsl_uart.c **** 
 633:../drivers/fsl_uart.c ****     uint32_t instance;
 634:../drivers/fsl_uart.c **** 
 635:../drivers/fsl_uart.c ****     /* Zero the handle. */
 636:../drivers/fsl_uart.c ****     memset(handle, 0, sizeof(*handle));
 1993              		.loc 4 636 5 is_stmt 1
 1994 001c BB68     		ldr	r3, [r7, #8]
 1995 001e 3022     		movs	r2, #48
 1996 0020 0021     		movs	r1, #0
 1997 0022 1800     		movs	r0, r3
 1998 0024 FFF7FEFF 		bl	memset
 637:../drivers/fsl_uart.c **** 
 638:../drivers/fsl_uart.c ****     /* Set the TX/RX state. */
 639:../drivers/fsl_uart.c ****     handle->rxState = kUART_RxIdle;
 1999              		.loc 4 639 21
 2000 0028 BB68     		ldr	r3, [r7, #8]
 2001 002a 2D22     		movs	r2, #45
 2002 002c 0221     		movs	r1, #2
 2003 002e 9954     		strb	r1, [r3, r2]
 640:../drivers/fsl_uart.c ****     handle->txState = kUART_TxIdle;
 2004              		.loc 4 640 21
 2005 0030 BB68     		ldr	r3, [r7, #8]
 2006 0032 2C22     		movs	r2, #44
 2007 0034 0021     		movs	r1, #0
 2008 0036 9954     		strb	r1, [r3, r2]
 641:../drivers/fsl_uart.c **** 
 642:../drivers/fsl_uart.c ****     /* Set the callback and user data. */
 643:../drivers/fsl_uart.c ****     handle->callback = callback;
 2009              		.loc 4 643 22
 2010 0038 BB68     		ldr	r3, [r7, #8]
 2011 003a 7A68     		ldr	r2, [r7, #4]
 2012 003c 5A62     		str	r2, [r3, #36]
 644:../drivers/fsl_uart.c ****     handle->userData = userData;
 2013              		.loc 4 644 22
 2014 003e BB68     		ldr	r3, [r7, #8]
 2015 0040 3A68     		ldr	r2, [r7]
 2016 0042 9A62     		str	r2, [r3, #40]
 645:../drivers/fsl_uart.c **** 
 646:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
 647:../drivers/fsl_uart.c ****     /* Note:
 648:../drivers/fsl_uart.c ****        Take care of the RX FIFO, RX interrupt request only assert when received bytes
 649:../drivers/fsl_uart.c ****        equal or more than RX water mark, there is potential issue if RX water
 650:../drivers/fsl_uart.c ****        mark larger than 1.
 651:../drivers/fsl_uart.c ****        For example, if RX FIFO water mark is 2, upper layer needs 5 bytes and
 652:../drivers/fsl_uart.c ****        5 bytes are received. the last byte will be saved in FIFO but not trigger
 653:../drivers/fsl_uart.c ****        RX interrupt because the water mark is 2.
 654:../drivers/fsl_uart.c ****      */
 655:../drivers/fsl_uart.c ****     base->RWFIFO = 1U;
 656:../drivers/fsl_uart.c **** #endif
 657:../drivers/fsl_uart.c **** 
 658:../drivers/fsl_uart.c ****     /* Get instance from peripheral base address. */
 659:../drivers/fsl_uart.c ****     instance = UART_GetInstance(base);
 2017              		.loc 4 659 16
 2018 0044 FB68     		ldr	r3, [r7, #12]
 2019 0046 1800     		movs	r0, r3
 2020 0048 FFF7FEFF 		bl	UART_GetInstance
 2021 004c 0300     		movs	r3, r0
 2022 004e 7B61     		str	r3, [r7, #20]
 660:../drivers/fsl_uart.c **** 
 661:../drivers/fsl_uart.c ****     /* Save the handle in global variables to support the double weak mechanism. */
 662:../drivers/fsl_uart.c ****     s_uartHandle[instance] = handle;
 2023              		.loc 4 662 28
 2024 0050 0A4B     		ldr	r3, .L116+4
 2025 0052 7A69     		ldr	r2, [r7, #20]
 2026 0054 9200     		lsls	r2, r2, #2
 2027 0056 B968     		ldr	r1, [r7, #8]
 2028 0058 D150     		str	r1, [r2, r3]
 663:../drivers/fsl_uart.c **** 
 664:../drivers/fsl_uart.c ****     s_uartIsr = UART_TransferHandleIRQ;
 2029              		.loc 4 664 15
 2030 005a 094B     		ldr	r3, .L116+8
 2031 005c 094A     		ldr	r2, .L116+12
 2032 005e 1A60     		str	r2, [r3]
 665:../drivers/fsl_uart.c ****     /* Enable interrupt in NVIC. */
 666:../drivers/fsl_uart.c ****     EnableIRQ(s_uartIRQ[instance]);
 2033              		.loc 4 666 5
 2034 0060 094A     		ldr	r2, .L116+16
 2035 0062 7B69     		ldr	r3, [r7, #20]
 2036 0064 D318     		adds	r3, r2, r3
 2037 0066 1B78     		ldrb	r3, [r3]
 2038 0068 5BB2     		sxtb	r3, r3
 2039 006a 1800     		movs	r0, r3
 2040 006c FFF7FEFF 		bl	EnableIRQ
 667:../drivers/fsl_uart.c **** }
 2041              		.loc 4 667 1
 2042 0070 C046     		nop
 2043 0072 BD46     		mov	sp, r7
 2044 0074 06B0     		add	sp, sp, #24
 2045              		@ sp needed
 2046 0076 80BD     		pop	{r7, pc}
 2047              	.L117:
 2048              		.align	2
 2049              	.L116:
 2050 0078 00000000 		.word	.LC23
 2051 007c 00000000 		.word	s_uartHandle
 2052 0080 00000000 		.word	s_uartIsr
 2053 0084 00000000 		.word	UART_TransferHandleIRQ
 2054 0088 00000000 		.word	s_uartIRQ
 2055              		.cfi_endproc
 2056              	.LFE79:
 2058              		.section	.rodata.UART_TransferStartRingBuffer.str1.4,"aMS",%progbits,1
 2059              		.align	2
 2060              	.LC29:
 2061 0000 2E66736C 		.ascii	".fsl_uart.c:671 : handle\000"
 2061      5F756172 
 2061      742E633A 
 2061      36373120 
 2061      3A206861 
 2062 0019 000000   		.align	2
 2063              	.LC31:
 2064 001c 2E66736C 		.ascii	".fsl_uart.c:672 : ringBuffer\000"
 2064      5F756172 
 2064      742E633A 
 2064      36373220 
 2064      3A207269 
 2065              		.section	.text.UART_TransferStartRingBuffer,"ax",%progbits
 2066              		.align	1
 2067              		.global	UART_TransferStartRingBuffer
 2068              		.syntax unified
 2069              		.code	16
 2070              		.thumb_func
 2071              		.fpu softvfp
 2073              	UART_TransferStartRingBuffer:
 2074              	.LFB80:
 668:../drivers/fsl_uart.c **** 
 669:../drivers/fsl_uart.c **** void UART_TransferStartRingBuffer(UART_Type *base, uart_handle_t *handle, uint8_t *ringBuffer, size
 670:../drivers/fsl_uart.c **** {
 2075              		.loc 4 670 1
 2076              		.cfi_startproc
 2077              		@ args = 0, pretend = 0, frame = 16
 2078              		@ frame_needed = 1, uses_anonymous_args = 0
 2079 0000 80B5     		push	{r7, lr}
 2080              		.cfi_def_cfa_offset 8
 2081              		.cfi_offset 7, -8
 2082              		.cfi_offset 14, -4
 2083 0002 84B0     		sub	sp, sp, #16
 2084              		.cfi_def_cfa_offset 24
 2085 0004 00AF     		add	r7, sp, #0
 2086              		.cfi_def_cfa_register 7
 2087 0006 F860     		str	r0, [r7, #12]
 2088 0008 B960     		str	r1, [r7, #8]
 2089 000a 7A60     		str	r2, [r7, #4]
 2090 000c 3B60     		str	r3, [r7]
 671:../drivers/fsl_uart.c ****     assert(handle);
 2091              		.loc 4 671 5
 2092 000e BB68     		ldr	r3, [r7, #8]
 2093 0010 002B     		cmp	r3, #0
 2094 0012 03D1     		bne	.L119
 2095              		.loc 4 671 5 is_stmt 0 discriminator 1
 2096 0014 184B     		ldr	r3, .L123
 2097 0016 1800     		movs	r0, r3
 2098 0018 FFF7FEFF 		bl	__assertion_failed
 2099              	.L119:
 672:../drivers/fsl_uart.c ****     assert(ringBuffer);
 2100              		.loc 4 672 5 is_stmt 1
 2101 001c 7B68     		ldr	r3, [r7, #4]
 2102 001e 002B     		cmp	r3, #0
 2103 0020 03D1     		bne	.L120
 2104              		.loc 4 672 5 is_stmt 0 discriminator 1
 2105 0022 164B     		ldr	r3, .L123+4
 2106 0024 1800     		movs	r0, r3
 2107 0026 FFF7FEFF 		bl	__assertion_failed
 2108              	.L120:
 673:../drivers/fsl_uart.c **** 
 674:../drivers/fsl_uart.c ****     /* Setup the ringbuffer address */
 675:../drivers/fsl_uart.c ****     handle->rxRingBuffer = ringBuffer;
 2109              		.loc 4 675 26 is_stmt 1
 2110 002a BB68     		ldr	r3, [r7, #8]
 2111 002c 7A68     		ldr	r2, [r7, #4]
 2112 002e 9A61     		str	r2, [r3, #24]
 676:../drivers/fsl_uart.c ****     handle->rxRingBufferSize = ringBufferSize;
 2113              		.loc 4 676 30
 2114 0030 BB68     		ldr	r3, [r7, #8]
 2115 0032 3A68     		ldr	r2, [r7]
 2116 0034 DA61     		str	r2, [r3, #28]
 677:../drivers/fsl_uart.c ****     handle->rxRingBufferHead = 0U;
 2117              		.loc 4 677 30
 2118 0036 BB68     		ldr	r3, [r7, #8]
 2119 0038 0022     		movs	r2, #0
 2120 003a 1A84     		strh	r2, [r3, #32]
 678:../drivers/fsl_uart.c ****     handle->rxRingBufferTail = 0U;
 2121              		.loc 4 678 30
 2122 003c BB68     		ldr	r3, [r7, #8]
 2123 003e 0022     		movs	r2, #0
 2124 0040 5A84     		strh	r2, [r3, #34]
 679:../drivers/fsl_uart.c **** 
 680:../drivers/fsl_uart.c ****     /* Enable the interrupt to accept the data when user need the ring buffer. */
 681:../drivers/fsl_uart.c ****     UART_EnableInterrupts(
 2125              		.loc 4 681 5
 2126 0042 A223     		movs	r3, #162
 2127 0044 1A03     		lsls	r2, r3, #12
 2128 0046 FB68     		ldr	r3, [r7, #12]
 2129 0048 1100     		movs	r1, r2
 2130 004a 1800     		movs	r0, r3
 2131 004c FFF7FEFF 		bl	UART_EnableInterrupts
 682:../drivers/fsl_uart.c ****         base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterruptEnable | kUART_FramingEr
 683:../drivers/fsl_uart.c ****     /* Enable parity error interrupt when parity mode is enable*/
 684:../drivers/fsl_uart.c ****     if (UART_C1_PE_MASK & base->C1)
 2132              		.loc 4 684 31
 2133 0050 FB68     		ldr	r3, [r7, #12]
 2134 0052 9B78     		ldrb	r3, [r3, #2]
 2135 0054 DBB2     		uxtb	r3, r3
 2136              		.loc 4 684 9
 2137 0056 0222     		movs	r2, #2
 2138 0058 1340     		ands	r3, r2
 2139 005a DBB2     		uxtb	r3, r3
 2140              		.loc 4 684 8
 2141 005c 002B     		cmp	r3, #0
 2142 005e 06D0     		beq	.L122
 685:../drivers/fsl_uart.c ****     {
 686:../drivers/fsl_uart.c ****         UART_EnableInterrupts(base, kUART_ParityErrorInterruptEnable);
 2143              		.loc 4 686 9
 2144 0060 8023     		movs	r3, #128
 2145 0062 5A02     		lsls	r2, r3, #9
 2146 0064 FB68     		ldr	r3, [r7, #12]
 2147 0066 1100     		movs	r1, r2
 2148 0068 1800     		movs	r0, r3
 2149 006a FFF7FEFF 		bl	UART_EnableInterrupts
 2150              	.L122:
 687:../drivers/fsl_uart.c ****     }
 688:../drivers/fsl_uart.c **** }
 2151              		.loc 4 688 1
 2152 006e C046     		nop
 2153 0070 BD46     		mov	sp, r7
 2154 0072 04B0     		add	sp, sp, #16
 2155              		@ sp needed
 2156 0074 80BD     		pop	{r7, pc}
 2157              	.L124:
 2158 0076 C046     		.align	2
 2159              	.L123:
 2160 0078 00000000 		.word	.LC29
 2161 007c 1C000000 		.word	.LC31
 2162              		.cfi_endproc
 2163              	.LFE80:
 2165              		.section	.rodata.UART_TransferStopRingBuffer.str1.4,"aMS",%progbits,1
 2166              		.align	2
 2167              	.LC33:
 2168 0000 2E66736C 		.ascii	".fsl_uart.c:692 : handle\000"
 2168      5F756172 
 2168      742E633A 
 2168      36393220 
 2168      3A206861 
 2169              		.section	.text.UART_TransferStopRingBuffer,"ax",%progbits
 2170              		.align	1
 2171              		.global	UART_TransferStopRingBuffer
 2172              		.syntax unified
 2173              		.code	16
 2174              		.thumb_func
 2175              		.fpu softvfp
 2177              	UART_TransferStopRingBuffer:
 2178              	.LFB81:
 689:../drivers/fsl_uart.c **** 
 690:../drivers/fsl_uart.c **** void UART_TransferStopRingBuffer(UART_Type *base, uart_handle_t *handle)
 691:../drivers/fsl_uart.c **** {
 2179              		.loc 4 691 1
 2180              		.cfi_startproc
 2181              		@ args = 0, pretend = 0, frame = 8
 2182              		@ frame_needed = 1, uses_anonymous_args = 0
 2183 0000 80B5     		push	{r7, lr}
 2184              		.cfi_def_cfa_offset 8
 2185              		.cfi_offset 7, -8
 2186              		.cfi_offset 14, -4
 2187 0002 82B0     		sub	sp, sp, #8
 2188              		.cfi_def_cfa_offset 16
 2189 0004 00AF     		add	r7, sp, #0
 2190              		.cfi_def_cfa_register 7
 2191 0006 7860     		str	r0, [r7, #4]
 2192 0008 3960     		str	r1, [r7]
 692:../drivers/fsl_uart.c ****     assert(handle);
 2193              		.loc 4 692 5
 2194 000a 3B68     		ldr	r3, [r7]
 2195 000c 002B     		cmp	r3, #0
 2196 000e 03D1     		bne	.L126
 2197              		.loc 4 692 5 is_stmt 0 discriminator 1
 2198 0010 174B     		ldr	r3, .L128
 2199 0012 1800     		movs	r0, r3
 2200 0014 FFF7FEFF 		bl	__assertion_failed
 2201              	.L126:
 693:../drivers/fsl_uart.c **** 
 694:../drivers/fsl_uart.c ****     if (handle->rxState == kUART_RxIdle)
 2202              		.loc 4 694 15 is_stmt 1
 2203 0018 3B68     		ldr	r3, [r7]
 2204 001a 2D22     		movs	r2, #45
 2205 001c 9B5C     		ldrb	r3, [r3, r2]
 2206 001e DBB2     		uxtb	r3, r3
 2207              		.loc 4 694 8
 2208 0020 022B     		cmp	r3, #2
 2209 0022 15D1     		bne	.L127
 695:../drivers/fsl_uart.c ****     {
 696:../drivers/fsl_uart.c ****         UART_DisableInterrupts(base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterruptE
 2210              		.loc 4 696 9
 2211 0024 A223     		movs	r3, #162
 2212 0026 1A03     		lsls	r2, r3, #12
 2213 0028 7B68     		ldr	r3, [r7, #4]
 2214 002a 1100     		movs	r1, r2
 2215 002c 1800     		movs	r0, r3
 2216 002e FFF7FEFF 		bl	UART_DisableInterrupts
 697:../drivers/fsl_uart.c ****                                          kUART_FramingErrorInterruptEnable);
 698:../drivers/fsl_uart.c ****         /* Disable parity error interrupt when parity mode is enable*/
 699:../drivers/fsl_uart.c ****         if (UART_C1_PE_MASK & base->C1)
 2217              		.loc 4 699 35
 2218 0032 7B68     		ldr	r3, [r7, #4]
 2219 0034 9B78     		ldrb	r3, [r3, #2]
 2220 0036 DBB2     		uxtb	r3, r3
 2221              		.loc 4 699 13
 2222 0038 0222     		movs	r2, #2
 2223 003a 1340     		ands	r3, r2
 2224 003c DBB2     		uxtb	r3, r3
 2225              		.loc 4 699 12
 2226 003e 002B     		cmp	r3, #0
 2227 0040 06D0     		beq	.L127
 700:../drivers/fsl_uart.c ****         {
 701:../drivers/fsl_uart.c ****             UART_DisableInterrupts(base, kUART_ParityErrorInterruptEnable);
 2228              		.loc 4 701 13
 2229 0042 8023     		movs	r3, #128
 2230 0044 5A02     		lsls	r2, r3, #9
 2231 0046 7B68     		ldr	r3, [r7, #4]
 2232 0048 1100     		movs	r1, r2
 2233 004a 1800     		movs	r0, r3
 2234 004c FFF7FEFF 		bl	UART_DisableInterrupts
 2235              	.L127:
 702:../drivers/fsl_uart.c ****         }
 703:../drivers/fsl_uart.c ****     }
 704:../drivers/fsl_uart.c **** 
 705:../drivers/fsl_uart.c ****     handle->rxRingBuffer = NULL;
 2236              		.loc 4 705 26
 2237 0050 3B68     		ldr	r3, [r7]
 2238 0052 0022     		movs	r2, #0
 2239 0054 9A61     		str	r2, [r3, #24]
 706:../drivers/fsl_uart.c ****     handle->rxRingBufferSize = 0U;
 2240              		.loc 4 706 30
 2241 0056 3B68     		ldr	r3, [r7]
 2242 0058 0022     		movs	r2, #0
 2243 005a DA61     		str	r2, [r3, #28]
 707:../drivers/fsl_uart.c ****     handle->rxRingBufferHead = 0U;
 2244              		.loc 4 707 30
 2245 005c 3B68     		ldr	r3, [r7]
 2246 005e 0022     		movs	r2, #0
 2247 0060 1A84     		strh	r2, [r3, #32]
 708:../drivers/fsl_uart.c ****     handle->rxRingBufferTail = 0U;
 2248              		.loc 4 708 30
 2249 0062 3B68     		ldr	r3, [r7]
 2250 0064 0022     		movs	r2, #0
 2251 0066 5A84     		strh	r2, [r3, #34]
 709:../drivers/fsl_uart.c **** }
 2252              		.loc 4 709 1
 2253 0068 C046     		nop
 2254 006a BD46     		mov	sp, r7
 2255 006c 02B0     		add	sp, sp, #8
 2256              		@ sp needed
 2257 006e 80BD     		pop	{r7, pc}
 2258              	.L129:
 2259              		.align	2
 2260              	.L128:
 2261 0070 00000000 		.word	.LC33
 2262              		.cfi_endproc
 2263              	.LFE81:
 2265              		.section	.rodata.UART_TransferSendNonBlocking.str1.4,"aMS",%progbits,1
 2266              		.align	2
 2267              	.LC35:
 2268 0000 2E66736C 		.ascii	".fsl_uart.c:713 : handle\000"
 2268      5F756172 
 2268      742E633A 
 2268      37313320 
 2268      3A206861 
 2269 0019 000000   		.align	2
 2270              	.LC37:
 2271 001c 2E66736C 		.ascii	".fsl_uart.c:714 : xfer\000"
 2271      5F756172 
 2271      742E633A 
 2271      37313420 
 2271      3A207866 
 2272 0033 00       		.align	2
 2273              	.LC39:
 2274 0034 2E66736C 		.ascii	".fsl_uart.c:715 : xfer->dataSize\000"
 2274      5F756172 
 2274      742E633A 
 2274      37313520 
 2274      3A207866 
 2275 0055 000000   		.align	2
 2276              	.LC41:
 2277 0058 2E66736C 		.ascii	".fsl_uart.c:716 : xfer->data\000"
 2277      5F756172 
 2277      742E633A 
 2277      37313620 
 2277      3A207866 
 2278              		.section	.text.UART_TransferSendNonBlocking,"ax",%progbits
 2279              		.align	1
 2280              		.global	UART_TransferSendNonBlocking
 2281              		.syntax unified
 2282              		.code	16
 2283              		.thumb_func
 2284              		.fpu softvfp
 2286              	UART_TransferSendNonBlocking:
 2287              	.LFB82:
 710:../drivers/fsl_uart.c **** 
 711:../drivers/fsl_uart.c **** status_t UART_TransferSendNonBlocking(UART_Type *base, uart_handle_t *handle, uart_transfer_t *xfer
 712:../drivers/fsl_uart.c **** {
 2288              		.loc 4 712 1
 2289              		.cfi_startproc
 2290              		@ args = 0, pretend = 0, frame = 24
 2291              		@ frame_needed = 1, uses_anonymous_args = 0
 2292 0000 80B5     		push	{r7, lr}
 2293              		.cfi_def_cfa_offset 8
 2294              		.cfi_offset 7, -8
 2295              		.cfi_offset 14, -4
 2296 0002 86B0     		sub	sp, sp, #24
 2297              		.cfi_def_cfa_offset 32
 2298 0004 00AF     		add	r7, sp, #0
 2299              		.cfi_def_cfa_register 7
 2300 0006 F860     		str	r0, [r7, #12]
 2301 0008 B960     		str	r1, [r7, #8]
 2302 000a 7A60     		str	r2, [r7, #4]
 713:../drivers/fsl_uart.c ****     assert(handle);
 2303              		.loc 4 713 5
 2304 000c BB68     		ldr	r3, [r7, #8]
 2305 000e 002B     		cmp	r3, #0
 2306 0010 03D1     		bne	.L131
 2307              		.loc 4 713 5 is_stmt 0 discriminator 1
 2308 0012 214B     		ldr	r3, .L138
 2309 0014 1800     		movs	r0, r3
 2310 0016 FFF7FEFF 		bl	__assertion_failed
 2311              	.L131:
 714:../drivers/fsl_uart.c ****     assert(xfer);
 2312              		.loc 4 714 5 is_stmt 1
 2313 001a 7B68     		ldr	r3, [r7, #4]
 2314 001c 002B     		cmp	r3, #0
 2315 001e 03D1     		bne	.L132
 2316              		.loc 4 714 5 is_stmt 0 discriminator 1
 2317 0020 1E4B     		ldr	r3, .L138+4
 2318 0022 1800     		movs	r0, r3
 2319 0024 FFF7FEFF 		bl	__assertion_failed
 2320              	.L132:
 715:../drivers/fsl_uart.c ****     assert(xfer->dataSize);
 2321              		.loc 4 715 5 is_stmt 1
 2322 0028 7B68     		ldr	r3, [r7, #4]
 2323 002a 5B68     		ldr	r3, [r3, #4]
 2324 002c 002B     		cmp	r3, #0
 2325 002e 03D1     		bne	.L133
 2326              		.loc 4 715 5 is_stmt 0 discriminator 1
 2327 0030 1B4B     		ldr	r3, .L138+8
 2328 0032 1800     		movs	r0, r3
 2329 0034 FFF7FEFF 		bl	__assertion_failed
 2330              	.L133:
 716:../drivers/fsl_uart.c ****     assert(xfer->data);
 2331              		.loc 4 716 5 is_stmt 1
 2332 0038 7B68     		ldr	r3, [r7, #4]
 2333 003a 1B68     		ldr	r3, [r3]
 2334 003c 002B     		cmp	r3, #0
 2335 003e 03D1     		bne	.L134
 2336              		.loc 4 716 5 is_stmt 0 discriminator 1
 2337 0040 184B     		ldr	r3, .L138+12
 2338 0042 1800     		movs	r0, r3
 2339 0044 FFF7FEFF 		bl	__assertion_failed
 2340              	.L134:
 717:../drivers/fsl_uart.c **** 
 718:../drivers/fsl_uart.c ****     status_t status;
 719:../drivers/fsl_uart.c **** 
 720:../drivers/fsl_uart.c ****     /* Return error if current TX busy. */
 721:../drivers/fsl_uart.c ****     if (kUART_TxBusy == handle->txState)
 2341              		.loc 4 721 31 is_stmt 1
 2342 0048 BB68     		ldr	r3, [r7, #8]
 2343 004a 2C22     		movs	r2, #44
 2344 004c 9B5C     		ldrb	r3, [r3, r2]
 2345 004e DBB2     		uxtb	r3, r3
 2346              		.loc 4 721 8
 2347 0050 012B     		cmp	r3, #1
 2348 0052 03D1     		bne	.L135
 722:../drivers/fsl_uart.c ****     {
 723:../drivers/fsl_uart.c ****         status = kStatus_UART_TxBusy;
 2349              		.loc 4 723 16
 2350 0054 FA23     		movs	r3, #250
 2351 0056 9B00     		lsls	r3, r3, #2
 2352 0058 7B61     		str	r3, [r7, #20]
 2353 005a 18E0     		b	.L136
 2354              	.L135:
 724:../drivers/fsl_uart.c ****     }
 725:../drivers/fsl_uart.c ****     else
 726:../drivers/fsl_uart.c ****     {
 727:../drivers/fsl_uart.c ****         handle->txData = xfer->data;
 2355              		.loc 4 727 30
 2356 005c 7B68     		ldr	r3, [r7, #4]
 2357 005e 1A68     		ldr	r2, [r3]
 2358              		.loc 4 727 24
 2359 0060 BB68     		ldr	r3, [r7, #8]
 2360 0062 1A60     		str	r2, [r3]
 728:../drivers/fsl_uart.c ****         handle->txDataSize = xfer->dataSize;
 2361              		.loc 4 728 34
 2362 0064 7B68     		ldr	r3, [r7, #4]
 2363 0066 5A68     		ldr	r2, [r3, #4]
 2364              		.loc 4 728 28
 2365 0068 BB68     		ldr	r3, [r7, #8]
 2366 006a 5A60     		str	r2, [r3, #4]
 729:../drivers/fsl_uart.c ****         handle->txDataSizeAll = xfer->dataSize;
 2367              		.loc 4 729 37
 2368 006c 7B68     		ldr	r3, [r7, #4]
 2369 006e 5A68     		ldr	r2, [r3, #4]
 2370              		.loc 4 729 31
 2371 0070 BB68     		ldr	r3, [r7, #8]
 2372 0072 9A60     		str	r2, [r3, #8]
 730:../drivers/fsl_uart.c ****         handle->txState = kUART_TxBusy;
 2373              		.loc 4 730 25
 2374 0074 BB68     		ldr	r3, [r7, #8]
 2375 0076 2C22     		movs	r2, #44
 2376 0078 0121     		movs	r1, #1
 2377 007a 9954     		strb	r1, [r3, r2]
 731:../drivers/fsl_uart.c **** 
 732:../drivers/fsl_uart.c ****         /* Enable transmiter interrupt. */
 733:../drivers/fsl_uart.c ****         UART_EnableInterrupts(base, kUART_TxDataRegEmptyInterruptEnable);
 2378              		.loc 4 733 9
 2379 007c 8023     		movs	r3, #128
 2380 007e 1A02     		lsls	r2, r3, #8
 2381 0080 FB68     		ldr	r3, [r7, #12]
 2382 0082 1100     		movs	r1, r2
 2383 0084 1800     		movs	r0, r3
 2384 0086 FFF7FEFF 		bl	UART_EnableInterrupts
 734:../drivers/fsl_uart.c **** 
 735:../drivers/fsl_uart.c ****         status = kStatus_Success;
 2385              		.loc 4 735 16
 2386 008a 0023     		movs	r3, #0
 2387 008c 7B61     		str	r3, [r7, #20]
 2388              	.L136:
 736:../drivers/fsl_uart.c ****     }
 737:../drivers/fsl_uart.c **** 
 738:../drivers/fsl_uart.c ****     return status;
 2389              		.loc 4 738 12
 2390 008e 7B69     		ldr	r3, [r7, #20]
 739:../drivers/fsl_uart.c **** }
 2391              		.loc 4 739 1
 2392 0090 1800     		movs	r0, r3
 2393 0092 BD46     		mov	sp, r7
 2394 0094 06B0     		add	sp, sp, #24
 2395              		@ sp needed
 2396 0096 80BD     		pop	{r7, pc}
 2397              	.L139:
 2398              		.align	2
 2399              	.L138:
 2400 0098 00000000 		.word	.LC35
 2401 009c 1C000000 		.word	.LC37
 2402 00a0 34000000 		.word	.LC39
 2403 00a4 58000000 		.word	.LC41
 2404              		.cfi_endproc
 2405              	.LFE82:
 2407              		.section	.rodata.UART_TransferAbortSend.str1.4,"aMS",%progbits,1
 2408              		.align	2
 2409              	.LC43:
 2410 0000 2E66736C 		.ascii	".fsl_uart.c:743 : handle\000"
 2410      5F756172 
 2410      742E633A 
 2410      37343320 
 2410      3A206861 
 2411              		.section	.text.UART_TransferAbortSend,"ax",%progbits
 2412              		.align	1
 2413              		.global	UART_TransferAbortSend
 2414              		.syntax unified
 2415              		.code	16
 2416              		.thumb_func
 2417              		.fpu softvfp
 2419              	UART_TransferAbortSend:
 2420              	.LFB83:
 740:../drivers/fsl_uart.c **** 
 741:../drivers/fsl_uart.c **** void UART_TransferAbortSend(UART_Type *base, uart_handle_t *handle)
 742:../drivers/fsl_uart.c **** {
 2421              		.loc 4 742 1
 2422              		.cfi_startproc
 2423              		@ args = 0, pretend = 0, frame = 8
 2424              		@ frame_needed = 1, uses_anonymous_args = 0
 2425 0000 80B5     		push	{r7, lr}
 2426              		.cfi_def_cfa_offset 8
 2427              		.cfi_offset 7, -8
 2428              		.cfi_offset 14, -4
 2429 0002 82B0     		sub	sp, sp, #8
 2430              		.cfi_def_cfa_offset 16
 2431 0004 00AF     		add	r7, sp, #0
 2432              		.cfi_def_cfa_register 7
 2433 0006 7860     		str	r0, [r7, #4]
 2434 0008 3960     		str	r1, [r7]
 743:../drivers/fsl_uart.c ****     assert(handle);
 2435              		.loc 4 743 5
 2436 000a 3B68     		ldr	r3, [r7]
 2437 000c 002B     		cmp	r3, #0
 2438 000e 03D1     		bne	.L141
 2439              		.loc 4 743 5 is_stmt 0 discriminator 1
 2440 0010 0A4B     		ldr	r3, .L142
 2441 0012 1800     		movs	r0, r3
 2442 0014 FFF7FEFF 		bl	__assertion_failed
 2443              	.L141:
 744:../drivers/fsl_uart.c **** 
 745:../drivers/fsl_uart.c ****     UART_DisableInterrupts(base, kUART_TxDataRegEmptyInterruptEnable | kUART_TransmissionCompleteIn
 2444              		.loc 4 745 5 is_stmt 1
 2445 0018 C023     		movs	r3, #192
 2446 001a 1A02     		lsls	r2, r3, #8
 2447 001c 7B68     		ldr	r3, [r7, #4]
 2448 001e 1100     		movs	r1, r2
 2449 0020 1800     		movs	r0, r3
 2450 0022 FFF7FEFF 		bl	UART_DisableInterrupts
 746:../drivers/fsl_uart.c **** 
 747:../drivers/fsl_uart.c ****     handle->txDataSize = 0;
 2451              		.loc 4 747 24
 2452 0026 3B68     		ldr	r3, [r7]
 2453 0028 0022     		movs	r2, #0
 2454 002a 5A60     		str	r2, [r3, #4]
 748:../drivers/fsl_uart.c ****     handle->txState = kUART_TxIdle;
 2455              		.loc 4 748 21
 2456 002c 3B68     		ldr	r3, [r7]
 2457 002e 2C22     		movs	r2, #44
 2458 0030 0021     		movs	r1, #0
 2459 0032 9954     		strb	r1, [r3, r2]
 749:../drivers/fsl_uart.c **** }
 2460              		.loc 4 749 1
 2461 0034 C046     		nop
 2462 0036 BD46     		mov	sp, r7
 2463 0038 02B0     		add	sp, sp, #8
 2464              		@ sp needed
 2465 003a 80BD     		pop	{r7, pc}
 2466              	.L143:
 2467              		.align	2
 2468              	.L142:
 2469 003c 00000000 		.word	.LC43
 2470              		.cfi_endproc
 2471              	.LFE83:
 2473              		.section	.rodata.UART_TransferGetSendCount.str1.4,"aMS",%progbits,1
 2474              		.align	2
 2475              	.LC45:
 2476 0000 2E66736C 		.ascii	".fsl_uart.c:753 : handle\000"
 2476      5F756172 
 2476      742E633A 
 2476      37353320 
 2476      3A206861 
 2477 0019 000000   		.align	2
 2478              	.LC47:
 2479 001c 2E66736C 		.ascii	".fsl_uart.c:754 : count\000"
 2479      5F756172 
 2479      742E633A 
 2479      37353420 
 2479      3A20636F 
 2480              		.section	.text.UART_TransferGetSendCount,"ax",%progbits
 2481              		.align	1
 2482              		.global	UART_TransferGetSendCount
 2483              		.syntax unified
 2484              		.code	16
 2485              		.thumb_func
 2486              		.fpu softvfp
 2488              	UART_TransferGetSendCount:
 2489              	.LFB84:
 750:../drivers/fsl_uart.c **** 
 751:../drivers/fsl_uart.c **** status_t UART_TransferGetSendCount(UART_Type *base, uart_handle_t *handle, uint32_t *count)
 752:../drivers/fsl_uart.c **** {
 2490              		.loc 4 752 1
 2491              		.cfi_startproc
 2492              		@ args = 0, pretend = 0, frame = 16
 2493              		@ frame_needed = 1, uses_anonymous_args = 0
 2494 0000 80B5     		push	{r7, lr}
 2495              		.cfi_def_cfa_offset 8
 2496              		.cfi_offset 7, -8
 2497              		.cfi_offset 14, -4
 2498 0002 84B0     		sub	sp, sp, #16
 2499              		.cfi_def_cfa_offset 24
 2500 0004 00AF     		add	r7, sp, #0
 2501              		.cfi_def_cfa_register 7
 2502 0006 F860     		str	r0, [r7, #12]
 2503 0008 B960     		str	r1, [r7, #8]
 2504 000a 7A60     		str	r2, [r7, #4]
 753:../drivers/fsl_uart.c ****     assert(handle);
 2505              		.loc 4 753 5
 2506 000c BB68     		ldr	r3, [r7, #8]
 2507 000e 002B     		cmp	r3, #0
 2508 0010 03D1     		bne	.L145
 2509              		.loc 4 753 5 is_stmt 0 discriminator 1
 2510 0012 0F4B     		ldr	r3, .L149
 2511 0014 1800     		movs	r0, r3
 2512 0016 FFF7FEFF 		bl	__assertion_failed
 2513              	.L145:
 754:../drivers/fsl_uart.c ****     assert(count);
 2514              		.loc 4 754 5 is_stmt 1
 2515 001a 7B68     		ldr	r3, [r7, #4]
 2516 001c 002B     		cmp	r3, #0
 2517 001e 03D1     		bne	.L146
 2518              		.loc 4 754 5 is_stmt 0 discriminator 1
 2519 0020 0C4B     		ldr	r3, .L149+4
 2520 0022 1800     		movs	r0, r3
 2521 0024 FFF7FEFF 		bl	__assertion_failed
 2522              	.L146:
 755:../drivers/fsl_uart.c **** 
 756:../drivers/fsl_uart.c ****     if (kUART_TxIdle == handle->txState)
 2523              		.loc 4 756 31 is_stmt 1
 2524 0028 BB68     		ldr	r3, [r7, #8]
 2525 002a 2C22     		movs	r2, #44
 2526 002c 9B5C     		ldrb	r3, [r3, r2]
 2527 002e DBB2     		uxtb	r3, r3
 2528              		.loc 4 756 8
 2529 0030 002B     		cmp	r3, #0
 2530 0032 01D1     		bne	.L147
 757:../drivers/fsl_uart.c ****     {
 758:../drivers/fsl_uart.c ****         return kStatus_NoTransferInProgress;
 2531              		.loc 4 758 16
 2532 0034 0623     		movs	r3, #6
 2533 0036 07E0     		b	.L148
 2534              	.L147:
 759:../drivers/fsl_uart.c ****     }
 760:../drivers/fsl_uart.c **** 
 761:../drivers/fsl_uart.c ****     *count = handle->txDataSizeAll - handle->txDataSize;
 2535              		.loc 4 761 20
 2536 0038 BB68     		ldr	r3, [r7, #8]
 2537 003a 9A68     		ldr	r2, [r3, #8]
 2538              		.loc 4 761 44
 2539 003c BB68     		ldr	r3, [r7, #8]
 2540 003e 5B68     		ldr	r3, [r3, #4]
 2541              		.loc 4 761 36
 2542 0040 D21A     		subs	r2, r2, r3
 2543              		.loc 4 761 12
 2544 0042 7B68     		ldr	r3, [r7, #4]
 2545 0044 1A60     		str	r2, [r3]
 762:../drivers/fsl_uart.c **** 
 763:../drivers/fsl_uart.c ****     return kStatus_Success;
 2546              		.loc 4 763 12
 2547 0046 0023     		movs	r3, #0
 2548              	.L148:
 764:../drivers/fsl_uart.c **** }
 2549              		.loc 4 764 1
 2550 0048 1800     		movs	r0, r3
 2551 004a BD46     		mov	sp, r7
 2552 004c 04B0     		add	sp, sp, #16
 2553              		@ sp needed
 2554 004e 80BD     		pop	{r7, pc}
 2555              	.L150:
 2556              		.align	2
 2557              	.L149:
 2558 0050 00000000 		.word	.LC45
 2559 0054 1C000000 		.word	.LC47
 2560              		.cfi_endproc
 2561              	.LFE84:
 2563              		.section	.rodata.UART_TransferReceiveNonBlocking.str1.4,"aMS",%progbits,1
 2564              		.align	2
 2565              	.LC49:
 2566 0000 2E66736C 		.ascii	".fsl_uart.c:771 : handle\000"
 2566      5F756172 
 2566      742E633A 
 2566      37373120 
 2566      3A206861 
 2567 0019 000000   		.align	2
 2568              	.LC51:
 2569 001c 2E66736C 		.ascii	".fsl_uart.c:772 : xfer\000"
 2569      5F756172 
 2569      742E633A 
 2569      37373220 
 2569      3A207866 
 2570 0033 00       		.align	2
 2571              	.LC53:
 2572 0034 2E66736C 		.ascii	".fsl_uart.c:773 : xfer->data\000"
 2572      5F756172 
 2572      742E633A 
 2572      37373320 
 2572      3A207866 
 2573 0051 000000   		.align	2
 2574              	.LC55:
 2575 0054 2E66736C 		.ascii	".fsl_uart.c:774 : xfer->dataSize\000"
 2575      5F756172 
 2575      742E633A 
 2575      37373420 
 2575      3A207866 
 2576              		.section	.text.UART_TransferReceiveNonBlocking,"ax",%progbits
 2577              		.align	1
 2578              		.global	UART_TransferReceiveNonBlocking
 2579              		.syntax unified
 2580              		.code	16
 2581              		.thumb_func
 2582              		.fpu softvfp
 2584              	UART_TransferReceiveNonBlocking:
 2585              	.LFB85:
 765:../drivers/fsl_uart.c **** 
 766:../drivers/fsl_uart.c **** status_t UART_TransferReceiveNonBlocking(UART_Type *base,
 767:../drivers/fsl_uart.c ****                                          uart_handle_t *handle,
 768:../drivers/fsl_uart.c ****                                          uart_transfer_t *xfer,
 769:../drivers/fsl_uart.c ****                                          size_t *receivedBytes)
 770:../drivers/fsl_uart.c **** {
 2586              		.loc 4 770 1
 2587              		.cfi_startproc
 2588              		@ args = 0, pretend = 0, frame = 40
 2589              		@ frame_needed = 1, uses_anonymous_args = 0
 2590 0000 90B5     		push	{r4, r7, lr}
 2591              		.cfi_def_cfa_offset 12
 2592              		.cfi_offset 4, -12
 2593              		.cfi_offset 7, -8
 2594              		.cfi_offset 14, -4
 2595 0002 8BB0     		sub	sp, sp, #44
 2596              		.cfi_def_cfa_offset 56
 2597 0004 00AF     		add	r7, sp, #0
 2598              		.cfi_def_cfa_register 7
 2599 0006 F860     		str	r0, [r7, #12]
 2600 0008 B960     		str	r1, [r7, #8]
 2601 000a 7A60     		str	r2, [r7, #4]
 2602 000c 3B60     		str	r3, [r7]
 771:../drivers/fsl_uart.c ****     assert(handle);
 2603              		.loc 4 771 5
 2604 000e BB68     		ldr	r3, [r7, #8]
 2605 0010 002B     		cmp	r3, #0
 2606 0012 03D1     		bne	.L152
 2607              		.loc 4 771 5 is_stmt 0 discriminator 1
 2608 0014 684B     		ldr	r3, .L169
 2609 0016 1800     		movs	r0, r3
 2610 0018 FFF7FEFF 		bl	__assertion_failed
 2611              	.L152:
 772:../drivers/fsl_uart.c ****     assert(xfer);
 2612              		.loc 4 772 5 is_stmt 1
 2613 001c 7B68     		ldr	r3, [r7, #4]
 2614 001e 002B     		cmp	r3, #0
 2615 0020 03D1     		bne	.L153
 2616              		.loc 4 772 5 is_stmt 0 discriminator 1
 2617 0022 664B     		ldr	r3, .L169+4
 2618 0024 1800     		movs	r0, r3
 2619 0026 FFF7FEFF 		bl	__assertion_failed
 2620              	.L153:
 773:../drivers/fsl_uart.c ****     assert(xfer->data);
 2621              		.loc 4 773 5 is_stmt 1
 2622 002a 7B68     		ldr	r3, [r7, #4]
 2623 002c 1B68     		ldr	r3, [r3]
 2624 002e 002B     		cmp	r3, #0
 2625 0030 03D1     		bne	.L154
 2626              		.loc 4 773 5 is_stmt 0 discriminator 1
 2627 0032 634B     		ldr	r3, .L169+8
 2628 0034 1800     		movs	r0, r3
 2629 0036 FFF7FEFF 		bl	__assertion_failed
 2630              	.L154:
 774:../drivers/fsl_uart.c ****     assert(xfer->dataSize);
 2631              		.loc 4 774 5 is_stmt 1
 2632 003a 7B68     		ldr	r3, [r7, #4]
 2633 003c 5B68     		ldr	r3, [r3, #4]
 2634 003e 002B     		cmp	r3, #0
 2635 0040 03D1     		bne	.L155
 2636              		.loc 4 774 5 is_stmt 0 discriminator 1
 2637 0042 604B     		ldr	r3, .L169+12
 2638 0044 1800     		movs	r0, r3
 2639 0046 FFF7FEFF 		bl	__assertion_failed
 2640              	.L155:
 775:../drivers/fsl_uart.c **** 
 776:../drivers/fsl_uart.c ****     uint32_t i;
 777:../drivers/fsl_uart.c ****     status_t status;
 778:../drivers/fsl_uart.c ****     /* How many bytes to copy from ring buffer to user memory. */
 779:../drivers/fsl_uart.c ****     size_t bytesToCopy = 0U;
 2641              		.loc 4 779 12 is_stmt 1
 2642 004a 0023     		movs	r3, #0
 2643 004c 7B61     		str	r3, [r7, #20]
 780:../drivers/fsl_uart.c ****     /* How many bytes to receive. */
 781:../drivers/fsl_uart.c ****     size_t bytesToReceive;
 782:../drivers/fsl_uart.c ****     /* How many bytes currently have received. */
 783:../drivers/fsl_uart.c ****     size_t bytesCurrentReceived;
 784:../drivers/fsl_uart.c **** 
 785:../drivers/fsl_uart.c ****     /* How to get data:
 786:../drivers/fsl_uart.c ****        1. If RX ring buffer is not enabled, then save xfer->data and xfer->dataSize
 787:../drivers/fsl_uart.c ****           to uart handle, enable interrupt to store received data to xfer->data. When
 788:../drivers/fsl_uart.c ****           all data received, trigger callback.
 789:../drivers/fsl_uart.c ****        2. If RX ring buffer is enabled and not empty, get data from ring buffer first.
 790:../drivers/fsl_uart.c ****           If there are enough data in ring buffer, copy them to xfer->data and return.
 791:../drivers/fsl_uart.c ****           If there are not enough data in ring buffer, copy all of them to xfer->data,
 792:../drivers/fsl_uart.c ****           save the xfer->data remained empty space to uart handle, receive data
 793:../drivers/fsl_uart.c ****           to this empty space and trigger callback when finished. */
 794:../drivers/fsl_uart.c **** 
 795:../drivers/fsl_uart.c ****     if (kUART_RxBusy == handle->rxState)
 2644              		.loc 4 795 31
 2645 004e BB68     		ldr	r3, [r7, #8]
 2646 0050 2D22     		movs	r2, #45
 2647 0052 9B5C     		ldrb	r3, [r3, r2]
 2648 0054 DBB2     		uxtb	r3, r3
 2649              		.loc 4 795 8
 2650 0056 032B     		cmp	r3, #3
 2651 0058 02D1     		bne	.L156
 796:../drivers/fsl_uart.c ****     {
 797:../drivers/fsl_uart.c ****         status = kStatus_UART_RxBusy;
 2652              		.loc 4 797 16
 2653 005a 5B4B     		ldr	r3, .L169+16
 2654 005c 3B62     		str	r3, [r7, #32]
 2655 005e A6E0     		b	.L157
 2656              	.L156:
 798:../drivers/fsl_uart.c ****     }
 799:../drivers/fsl_uart.c ****     else
 800:../drivers/fsl_uart.c ****     {
 801:../drivers/fsl_uart.c ****         bytesToReceive = xfer->dataSize;
 2657              		.loc 4 801 24
 2658 0060 7B68     		ldr	r3, [r7, #4]
 2659 0062 5B68     		ldr	r3, [r3, #4]
 2660 0064 FB61     		str	r3, [r7, #28]
 802:../drivers/fsl_uart.c ****         bytesCurrentReceived = 0U;
 2661              		.loc 4 802 30
 2662 0066 0023     		movs	r3, #0
 2663 0068 BB61     		str	r3, [r7, #24]
 803:../drivers/fsl_uart.c **** 
 804:../drivers/fsl_uart.c ****         /* If RX ring buffer is used. */
 805:../drivers/fsl_uart.c ****         if (handle->rxRingBuffer)
 2664              		.loc 4 805 19
 2665 006a BB68     		ldr	r3, [r7, #8]
 2666 006c 9B69     		ldr	r3, [r3, #24]
 2667              		.loc 4 805 12
 2668 006e 002B     		cmp	r3, #0
 2669 0070 00D1     		bne	.LCB2131
 2670 0072 6EE0     		b	.L158	@long jump
 2671              	.LCB2131:
 806:../drivers/fsl_uart.c ****         {
 807:../drivers/fsl_uart.c ****             /* Disable UART RX IRQ, protect ring buffer. */
 808:../drivers/fsl_uart.c ****             UART_DisableInterrupts(base, kUART_RxDataRegFullInterruptEnable);
 2672              		.loc 4 808 13
 2673 0074 8023     		movs	r3, #128
 2674 0076 9A01     		lsls	r2, r3, #6
 2675 0078 FB68     		ldr	r3, [r7, #12]
 2676 007a 1100     		movs	r1, r2
 2677 007c 1800     		movs	r0, r3
 2678 007e FFF7FEFF 		bl	UART_DisableInterrupts
 809:../drivers/fsl_uart.c **** 
 810:../drivers/fsl_uart.c ****             /* How many bytes in RX ring buffer currently. */
 811:../drivers/fsl_uart.c ****             bytesToCopy = UART_TransferGetRxRingBufferLength(handle);
 2679              		.loc 4 811 27
 2680 0082 BB68     		ldr	r3, [r7, #8]
 2681 0084 1800     		movs	r0, r3
 2682 0086 FFF7FEFF 		bl	UART_TransferGetRxRingBufferLength
 2683 008a 0300     		movs	r3, r0
 2684 008c 7B61     		str	r3, [r7, #20]
 812:../drivers/fsl_uart.c **** 
 813:../drivers/fsl_uart.c ****             if (bytesToCopy)
 2685              		.loc 4 813 16
 2686 008e 7B69     		ldr	r3, [r7, #20]
 2687 0090 002B     		cmp	r3, #0
 2688 0092 34D0     		beq	.L159
 814:../drivers/fsl_uart.c ****             {
 815:../drivers/fsl_uart.c ****                 bytesToCopy = MIN(bytesToReceive, bytesToCopy);
 2689              		.loc 4 815 29
 2690 0094 FA69     		ldr	r2, [r7, #28]
 2691 0096 7B69     		ldr	r3, [r7, #20]
 2692 0098 9342     		cmp	r3, r2
 2693 009a 00D9     		bls	.L160
 2694 009c 1300     		movs	r3, r2
 2695              	.L160:
 2696 009e 7B61     		str	r3, [r7, #20]
 816:../drivers/fsl_uart.c **** 
 817:../drivers/fsl_uart.c ****                 bytesToReceive -= bytesToCopy;
 2697              		.loc 4 817 32
 2698 00a0 FA69     		ldr	r2, [r7, #28]
 2699 00a2 7B69     		ldr	r3, [r7, #20]
 2700 00a4 D31A     		subs	r3, r2, r3
 2701 00a6 FB61     		str	r3, [r7, #28]
 818:../drivers/fsl_uart.c **** 
 819:../drivers/fsl_uart.c ****                 /* Copy data from ring buffer to user memory. */
 820:../drivers/fsl_uart.c ****                 for (i = 0U; i < bytesToCopy; i++)
 2702              		.loc 4 820 24
 2703 00a8 0023     		movs	r3, #0
 2704 00aa 7B62     		str	r3, [r7, #36]
 2705              		.loc 4 820 17
 2706 00ac 23E0     		b	.L161
 2707              	.L164:
 821:../drivers/fsl_uart.c ****                 {
 822:../drivers/fsl_uart.c ****                     xfer->data[bytesCurrentReceived++] = handle->rxRingBuffer[handle->rxRingBufferT
 2708              		.loc 4 822 64
 2709 00ae BB68     		ldr	r3, [r7, #8]
 2710 00b0 9B69     		ldr	r3, [r3, #24]
 2711              		.loc 4 822 85
 2712 00b2 BA68     		ldr	r2, [r7, #8]
 2713 00b4 528C     		ldrh	r2, [r2, #34]
 2714 00b6 92B2     		uxth	r2, r2
 2715              		.loc 4 822 78
 2716 00b8 9A18     		adds	r2, r3, r2
 2717              		.loc 4 822 25
 2718 00ba 7B68     		ldr	r3, [r7, #4]
 2719 00bc 1968     		ldr	r1, [r3]
 2720              		.loc 4 822 52
 2721 00be BB69     		ldr	r3, [r7, #24]
 2722 00c0 581C     		adds	r0, r3, #1
 2723 00c2 B861     		str	r0, [r7, #24]
 2724              		.loc 4 822 31
 2725 00c4 CB18     		adds	r3, r1, r3
 2726              		.loc 4 822 78
 2727 00c6 1278     		ldrb	r2, [r2]
 2728              		.loc 4 822 56
 2729 00c8 1A70     		strb	r2, [r3]
 823:../drivers/fsl_uart.c **** 
 824:../drivers/fsl_uart.c ****                     /* Wrap to 0. Not use modulo (%) because it might be large and slow. */
 825:../drivers/fsl_uart.c ****                     if (handle->rxRingBufferTail + 1U == handle->rxRingBufferSize)
 2730              		.loc 4 825 31
 2731 00ca BB68     		ldr	r3, [r7, #8]
 2732 00cc 5B8C     		ldrh	r3, [r3, #34]
 2733 00ce 9BB2     		uxth	r3, r3
 2734              		.loc 4 825 50
 2735 00d0 5A1C     		adds	r2, r3, #1
 2736              		.loc 4 825 64
 2737 00d2 BB68     		ldr	r3, [r7, #8]
 2738 00d4 DB69     		ldr	r3, [r3, #28]
 2739              		.loc 4 825 24
 2740 00d6 9A42     		cmp	r2, r3
 2741 00d8 03D1     		bne	.L162
 826:../drivers/fsl_uart.c ****                     {
 827:../drivers/fsl_uart.c ****                         handle->rxRingBufferTail = 0U;
 2742              		.loc 4 827 50
 2743 00da BB68     		ldr	r3, [r7, #8]
 2744 00dc 0022     		movs	r2, #0
 2745 00de 5A84     		strh	r2, [r3, #34]
 2746 00e0 06E0     		b	.L163
 2747              	.L162:
 828:../drivers/fsl_uart.c ****                     }
 829:../drivers/fsl_uart.c ****                     else
 830:../drivers/fsl_uart.c ****                     {
 831:../drivers/fsl_uart.c ****                         handle->rxRingBufferTail++;
 2748              		.loc 4 831 31
 2749 00e2 BB68     		ldr	r3, [r7, #8]
 2750 00e4 5B8C     		ldrh	r3, [r3, #34]
 2751 00e6 9BB2     		uxth	r3, r3
 2752              		.loc 4 831 49
 2753 00e8 0133     		adds	r3, r3, #1
 2754 00ea 9AB2     		uxth	r2, r3
 2755 00ec BB68     		ldr	r3, [r7, #8]
 2756 00ee 5A84     		strh	r2, [r3, #34]
 2757              	.L163:
 820:../drivers/fsl_uart.c ****                 {
 2758              		.loc 4 820 48 discriminator 2
 2759 00f0 7B6A     		ldr	r3, [r7, #36]
 2760 00f2 0133     		adds	r3, r3, #1
 2761 00f4 7B62     		str	r3, [r7, #36]
 2762              	.L161:
 820:../drivers/fsl_uart.c ****                 {
 2763              		.loc 4 820 17 discriminator 1
 2764 00f6 7A6A     		ldr	r2, [r7, #36]
 2765 00f8 7B69     		ldr	r3, [r7, #20]
 2766 00fa 9A42     		cmp	r2, r3
 2767 00fc D7D3     		bcc	.L164
 2768              	.L159:
 832:../drivers/fsl_uart.c ****                     }
 833:../drivers/fsl_uart.c ****                 }
 834:../drivers/fsl_uart.c ****             }
 835:../drivers/fsl_uart.c **** 
 836:../drivers/fsl_uart.c ****             /* If ring buffer does not have enough data, still need to read more data. */
 837:../drivers/fsl_uart.c ****             if (bytesToReceive)
 2769              		.loc 4 837 16
 2770 00fe FB69     		ldr	r3, [r7, #28]
 2771 0100 002B     		cmp	r3, #0
 2772 0102 0FD0     		beq	.L165
 838:../drivers/fsl_uart.c ****             {
 839:../drivers/fsl_uart.c ****                 /* No data in ring buffer, save the request to UART handle. */
 840:../drivers/fsl_uart.c ****                 handle->rxData = xfer->data + bytesCurrentReceived;
 2773              		.loc 4 840 38
 2774 0104 7B68     		ldr	r3, [r7, #4]
 2775 0106 1A68     		ldr	r2, [r3]
 2776              		.loc 4 840 45
 2777 0108 BB69     		ldr	r3, [r7, #24]
 2778 010a D218     		adds	r2, r2, r3
 2779              		.loc 4 840 32
 2780 010c BB68     		ldr	r3, [r7, #8]
 2781 010e DA60     		str	r2, [r3, #12]
 841:../drivers/fsl_uart.c ****                 handle->rxDataSize = bytesToReceive;
 2782              		.loc 4 841 36
 2783 0110 BB68     		ldr	r3, [r7, #8]
 2784 0112 FA69     		ldr	r2, [r7, #28]
 2785 0114 1A61     		str	r2, [r3, #16]
 842:../drivers/fsl_uart.c ****                 handle->rxDataSizeAll = bytesToReceive;
 2786              		.loc 4 842 39
 2787 0116 BB68     		ldr	r3, [r7, #8]
 2788 0118 FA69     		ldr	r2, [r7, #28]
 2789 011a 5A61     		str	r2, [r3, #20]
 843:../drivers/fsl_uart.c ****                 handle->rxState = kUART_RxBusy;
 2790              		.loc 4 843 33
 2791 011c BB68     		ldr	r3, [r7, #8]
 2792 011e 2D22     		movs	r2, #45
 2793 0120 0321     		movs	r1, #3
 2794 0122 9954     		strb	r1, [r3, r2]
 2795              	.L165:
 844:../drivers/fsl_uart.c ****             }
 845:../drivers/fsl_uart.c **** 
 846:../drivers/fsl_uart.c ****             /* Enable UART RX IRQ if previously enabled. */
 847:../drivers/fsl_uart.c ****             UART_EnableInterrupts(base, kUART_RxDataRegFullInterruptEnable);
 2796              		.loc 4 847 13
 2797 0124 8023     		movs	r3, #128
 2798 0126 9A01     		lsls	r2, r3, #6
 2799 0128 FB68     		ldr	r3, [r7, #12]
 2800 012a 1100     		movs	r1, r2
 2801 012c 1800     		movs	r0, r3
 2802 012e FFF7FEFF 		bl	UART_EnableInterrupts
 848:../drivers/fsl_uart.c **** 
 849:../drivers/fsl_uart.c ****             /* Call user callback since all data are received. */
 850:../drivers/fsl_uart.c ****             if (0 == bytesToReceive)
 2803              		.loc 4 850 16
 2804 0132 FB69     		ldr	r3, [r7, #28]
 2805 0134 002B     		cmp	r3, #0
 2806 0136 32D1     		bne	.L166
 851:../drivers/fsl_uart.c ****             {
 852:../drivers/fsl_uart.c ****                 if (handle->callback)
 2807              		.loc 4 852 27
 2808 0138 BB68     		ldr	r3, [r7, #8]
 2809 013a 5B6A     		ldr	r3, [r3, #36]
 2810              		.loc 4 852 20
 2811 013c 002B     		cmp	r3, #0
 2812 013e 2ED0     		beq	.L166
 853:../drivers/fsl_uart.c ****                 {
 854:../drivers/fsl_uart.c ****                     handle->callback(base, handle, kStatus_UART_RxIdle, handle->userData);
 2813              		.loc 4 854 27
 2814 0140 BB68     		ldr	r3, [r7, #8]
 2815 0142 5C6A     		ldr	r4, [r3, #36]
 2816              		.loc 4 854 21
 2817 0144 BB68     		ldr	r3, [r7, #8]
 2818 0146 9B6A     		ldr	r3, [r3, #40]
 2819 0148 204A     		ldr	r2, .L169+20
 2820 014a B968     		ldr	r1, [r7, #8]
 2821 014c F868     		ldr	r0, [r7, #12]
 2822 014e A047     		blx	r4
 2823              	.LVL10:
 2824 0150 25E0     		b	.L166
 2825              	.L158:
 855:../drivers/fsl_uart.c ****                 }
 856:../drivers/fsl_uart.c ****             }
 857:../drivers/fsl_uart.c ****         }
 858:../drivers/fsl_uart.c ****         /* Ring buffer not used. */
 859:../drivers/fsl_uart.c ****         else
 860:../drivers/fsl_uart.c ****         {
 861:../drivers/fsl_uart.c ****             handle->rxData = xfer->data + bytesCurrentReceived;
 2826              		.loc 4 861 34
 2827 0152 7B68     		ldr	r3, [r7, #4]
 2828 0154 1A68     		ldr	r2, [r3]
 2829              		.loc 4 861 41
 2830 0156 BB69     		ldr	r3, [r7, #24]
 2831 0158 D218     		adds	r2, r2, r3
 2832              		.loc 4 861 28
 2833 015a BB68     		ldr	r3, [r7, #8]
 2834 015c DA60     		str	r2, [r3, #12]
 862:../drivers/fsl_uart.c ****             handle->rxDataSize = bytesToReceive;
 2835              		.loc 4 862 32
 2836 015e BB68     		ldr	r3, [r7, #8]
 2837 0160 FA69     		ldr	r2, [r7, #28]
 2838 0162 1A61     		str	r2, [r3, #16]
 863:../drivers/fsl_uart.c ****             handle->rxDataSizeAll = bytesToReceive;
 2839              		.loc 4 863 35
 2840 0164 BB68     		ldr	r3, [r7, #8]
 2841 0166 FA69     		ldr	r2, [r7, #28]
 2842 0168 5A61     		str	r2, [r3, #20]
 864:../drivers/fsl_uart.c ****             handle->rxState = kUART_RxBusy;
 2843              		.loc 4 864 29
 2844 016a BB68     		ldr	r3, [r7, #8]
 2845 016c 2D22     		movs	r2, #45
 2846 016e 0321     		movs	r1, #3
 2847 0170 9954     		strb	r1, [r3, r2]
 865:../drivers/fsl_uart.c **** 
 866:../drivers/fsl_uart.c ****             /* Enable RX/Rx overrun/framing error interrupt. */
 867:../drivers/fsl_uart.c ****             UART_EnableInterrupts(base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterru
 2848              		.loc 4 867 13
 2849 0172 A223     		movs	r3, #162
 2850 0174 1A03     		lsls	r2, r3, #12
 2851 0176 FB68     		ldr	r3, [r7, #12]
 2852 0178 1100     		movs	r1, r2
 2853 017a 1800     		movs	r0, r3
 2854 017c FFF7FEFF 		bl	UART_EnableInterrupts
 868:../drivers/fsl_uart.c ****                                             kUART_FramingErrorInterruptEnable);
 869:../drivers/fsl_uart.c ****             /* Enable parity error interrupt when parity mode is enable*/
 870:../drivers/fsl_uart.c ****             if (UART_C1_PE_MASK & base->C1)
 2855              		.loc 4 870 39
 2856 0180 FB68     		ldr	r3, [r7, #12]
 2857 0182 9B78     		ldrb	r3, [r3, #2]
 2858 0184 DBB2     		uxtb	r3, r3
 2859              		.loc 4 870 17
 2860 0186 0222     		movs	r2, #2
 2861 0188 1340     		ands	r3, r2
 2862 018a DBB2     		uxtb	r3, r3
 2863              		.loc 4 870 16
 2864 018c 002B     		cmp	r3, #0
 2865 018e 06D0     		beq	.L166
 871:../drivers/fsl_uart.c ****             {
 872:../drivers/fsl_uart.c ****                 UART_EnableInterrupts(base, kUART_ParityErrorInterruptEnable);
 2866              		.loc 4 872 17
 2867 0190 8023     		movs	r3, #128
 2868 0192 5A02     		lsls	r2, r3, #9
 2869 0194 FB68     		ldr	r3, [r7, #12]
 2870 0196 1100     		movs	r1, r2
 2871 0198 1800     		movs	r0, r3
 2872 019a FFF7FEFF 		bl	UART_EnableInterrupts
 2873              	.L166:
 873:../drivers/fsl_uart.c ****             }
 874:../drivers/fsl_uart.c ****         }
 875:../drivers/fsl_uart.c **** 
 876:../drivers/fsl_uart.c ****         /* Return the how many bytes have read. */
 877:../drivers/fsl_uart.c ****         if (receivedBytes)
 2874              		.loc 4 877 12
 2875 019e 3B68     		ldr	r3, [r7]
 2876 01a0 002B     		cmp	r3, #0
 2877 01a2 02D0     		beq	.L167
 878:../drivers/fsl_uart.c ****         {
 879:../drivers/fsl_uart.c ****             *receivedBytes = bytesCurrentReceived;
 2878              		.loc 4 879 28
 2879 01a4 3B68     		ldr	r3, [r7]
 2880 01a6 BA69     		ldr	r2, [r7, #24]
 2881 01a8 1A60     		str	r2, [r3]
 2882              	.L167:
 880:../drivers/fsl_uart.c ****         }
 881:../drivers/fsl_uart.c **** 
 882:../drivers/fsl_uart.c ****         status = kStatus_Success;
 2883              		.loc 4 882 16
 2884 01aa 0023     		movs	r3, #0
 2885 01ac 3B62     		str	r3, [r7, #32]
 2886              	.L157:
 883:../drivers/fsl_uart.c ****     }
 884:../drivers/fsl_uart.c **** 
 885:../drivers/fsl_uart.c ****     return status;
 2887              		.loc 4 885 12
 2888 01ae 3B6A     		ldr	r3, [r7, #32]
 886:../drivers/fsl_uart.c **** }
 2889              		.loc 4 886 1
 2890 01b0 1800     		movs	r0, r3
 2891 01b2 BD46     		mov	sp, r7
 2892 01b4 0BB0     		add	sp, sp, #44
 2893              		@ sp needed
 2894 01b6 90BD     		pop	{r4, r7, pc}
 2895              	.L170:
 2896              		.align	2
 2897              	.L169:
 2898 01b8 00000000 		.word	.LC49
 2899 01bc 1C000000 		.word	.LC51
 2900 01c0 34000000 		.word	.LC53
 2901 01c4 54000000 		.word	.LC55
 2902 01c8 E9030000 		.word	1001
 2903 01cc EB030000 		.word	1003
 2904              		.cfi_endproc
 2905              	.LFE85:
 2907              		.section	.rodata.UART_TransferAbortReceive.str1.4,"aMS",%progbits,1
 2908              		.align	2
 2909              	.LC57:
 2910 0000 2E66736C 		.ascii	".fsl_uart.c:890 : handle\000"
 2910      5F756172 
 2910      742E633A 
 2910      38393020 
 2910      3A206861 
 2911              		.section	.text.UART_TransferAbortReceive,"ax",%progbits
 2912              		.align	1
 2913              		.global	UART_TransferAbortReceive
 2914              		.syntax unified
 2915              		.code	16
 2916              		.thumb_func
 2917              		.fpu softvfp
 2919              	UART_TransferAbortReceive:
 2920              	.LFB86:
 887:../drivers/fsl_uart.c **** 
 888:../drivers/fsl_uart.c **** void UART_TransferAbortReceive(UART_Type *base, uart_handle_t *handle)
 889:../drivers/fsl_uart.c **** {
 2921              		.loc 4 889 1
 2922              		.cfi_startproc
 2923              		@ args = 0, pretend = 0, frame = 8
 2924              		@ frame_needed = 1, uses_anonymous_args = 0
 2925 0000 80B5     		push	{r7, lr}
 2926              		.cfi_def_cfa_offset 8
 2927              		.cfi_offset 7, -8
 2928              		.cfi_offset 14, -4
 2929 0002 82B0     		sub	sp, sp, #8
 2930              		.cfi_def_cfa_offset 16
 2931 0004 00AF     		add	r7, sp, #0
 2932              		.cfi_def_cfa_register 7
 2933 0006 7860     		str	r0, [r7, #4]
 2934 0008 3960     		str	r1, [r7]
 890:../drivers/fsl_uart.c ****     assert(handle);
 2935              		.loc 4 890 5
 2936 000a 3B68     		ldr	r3, [r7]
 2937 000c 002B     		cmp	r3, #0
 2938 000e 03D1     		bne	.L172
 2939              		.loc 4 890 5 is_stmt 0 discriminator 1
 2940 0010 144B     		ldr	r3, .L174
 2941 0012 1800     		movs	r0, r3
 2942 0014 FFF7FEFF 		bl	__assertion_failed
 2943              	.L172:
 891:../drivers/fsl_uart.c **** 
 892:../drivers/fsl_uart.c ****     /* Only abort the receive to handle->rxData, the RX ring buffer is still working. */
 893:../drivers/fsl_uart.c ****     if (!handle->rxRingBuffer)
 2944              		.loc 4 893 16 is_stmt 1
 2945 0018 3B68     		ldr	r3, [r7]
 2946 001a 9B69     		ldr	r3, [r3, #24]
 2947              		.loc 4 893 8
 2948 001c 002B     		cmp	r3, #0
 2949 001e 15D1     		bne	.L173
 894:../drivers/fsl_uart.c ****     {
 895:../drivers/fsl_uart.c ****         /* Disable RX interrupt. */
 896:../drivers/fsl_uart.c ****         UART_DisableInterrupts(base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterruptE
 2950              		.loc 4 896 9
 2951 0020 A223     		movs	r3, #162
 2952 0022 1A03     		lsls	r2, r3, #12
 2953 0024 7B68     		ldr	r3, [r7, #4]
 2954 0026 1100     		movs	r1, r2
 2955 0028 1800     		movs	r0, r3
 2956 002a FFF7FEFF 		bl	UART_DisableInterrupts
 897:../drivers/fsl_uart.c ****                                          kUART_FramingErrorInterruptEnable);
 898:../drivers/fsl_uart.c ****         /* Disable parity error interrupt when parity mode is enable*/
 899:../drivers/fsl_uart.c ****         if (UART_C1_PE_MASK & base->C1)
 2957              		.loc 4 899 35
 2958 002e 7B68     		ldr	r3, [r7, #4]
 2959 0030 9B78     		ldrb	r3, [r3, #2]
 2960 0032 DBB2     		uxtb	r3, r3
 2961              		.loc 4 899 13
 2962 0034 0222     		movs	r2, #2
 2963 0036 1340     		ands	r3, r2
 2964 0038 DBB2     		uxtb	r3, r3
 2965              		.loc 4 899 12
 2966 003a 002B     		cmp	r3, #0
 2967 003c 06D0     		beq	.L173
 900:../drivers/fsl_uart.c ****         {
 901:../drivers/fsl_uart.c ****             UART_DisableInterrupts(base, kUART_ParityErrorInterruptEnable);
 2968              		.loc 4 901 13
 2969 003e 8023     		movs	r3, #128
 2970 0040 5A02     		lsls	r2, r3, #9
 2971 0042 7B68     		ldr	r3, [r7, #4]
 2972 0044 1100     		movs	r1, r2
 2973 0046 1800     		movs	r0, r3
 2974 0048 FFF7FEFF 		bl	UART_DisableInterrupts
 2975              	.L173:
 902:../drivers/fsl_uart.c ****         }
 903:../drivers/fsl_uart.c ****     }
 904:../drivers/fsl_uart.c **** 
 905:../drivers/fsl_uart.c ****     handle->rxDataSize = 0U;
 2976              		.loc 4 905 24
 2977 004c 3B68     		ldr	r3, [r7]
 2978 004e 0022     		movs	r2, #0
 2979 0050 1A61     		str	r2, [r3, #16]
 906:../drivers/fsl_uart.c ****     handle->rxState = kUART_RxIdle;
 2980              		.loc 4 906 21
 2981 0052 3B68     		ldr	r3, [r7]
 2982 0054 2D22     		movs	r2, #45
 2983 0056 0221     		movs	r1, #2
 2984 0058 9954     		strb	r1, [r3, r2]
 907:../drivers/fsl_uart.c **** }
 2985              		.loc 4 907 1
 2986 005a C046     		nop
 2987 005c BD46     		mov	sp, r7
 2988 005e 02B0     		add	sp, sp, #8
 2989              		@ sp needed
 2990 0060 80BD     		pop	{r7, pc}
 2991              	.L175:
 2992 0062 C046     		.align	2
 2993              	.L174:
 2994 0064 00000000 		.word	.LC57
 2995              		.cfi_endproc
 2996              	.LFE86:
 2998              		.section	.rodata.UART_TransferGetReceiveCount.str1.4,"aMS",%progbits,1
 2999              		.align	2
 3000              	.LC59:
 3001 0000 2E66736C 		.ascii	".fsl_uart.c:911 : handle\000"
 3001      5F756172 
 3001      742E633A 
 3001      39313120 
 3001      3A206861 
 3002 0019 000000   		.align	2
 3003              	.LC61:
 3004 001c 2E66736C 		.ascii	".fsl_uart.c:912 : count\000"
 3004      5F756172 
 3004      742E633A 
 3004      39313220 
 3004      3A20636F 
 3005              		.section	.text.UART_TransferGetReceiveCount,"ax",%progbits
 3006              		.align	1
 3007              		.global	UART_TransferGetReceiveCount
 3008              		.syntax unified
 3009              		.code	16
 3010              		.thumb_func
 3011              		.fpu softvfp
 3013              	UART_TransferGetReceiveCount:
 3014              	.LFB87:
 908:../drivers/fsl_uart.c **** 
 909:../drivers/fsl_uart.c **** status_t UART_TransferGetReceiveCount(UART_Type *base, uart_handle_t *handle, uint32_t *count)
 910:../drivers/fsl_uart.c **** {
 3015              		.loc 4 910 1
 3016              		.cfi_startproc
 3017              		@ args = 0, pretend = 0, frame = 16
 3018              		@ frame_needed = 1, uses_anonymous_args = 0
 3019 0000 80B5     		push	{r7, lr}
 3020              		.cfi_def_cfa_offset 8
 3021              		.cfi_offset 7, -8
 3022              		.cfi_offset 14, -4
 3023 0002 84B0     		sub	sp, sp, #16
 3024              		.cfi_def_cfa_offset 24
 3025 0004 00AF     		add	r7, sp, #0
 3026              		.cfi_def_cfa_register 7
 3027 0006 F860     		str	r0, [r7, #12]
 3028 0008 B960     		str	r1, [r7, #8]
 3029 000a 7A60     		str	r2, [r7, #4]
 911:../drivers/fsl_uart.c ****     assert(handle);
 3030              		.loc 4 911 5
 3031 000c BB68     		ldr	r3, [r7, #8]
 3032 000e 002B     		cmp	r3, #0
 3033 0010 03D1     		bne	.L177
 3034              		.loc 4 911 5 is_stmt 0 discriminator 1
 3035 0012 124B     		ldr	r3, .L182
 3036 0014 1800     		movs	r0, r3
 3037 0016 FFF7FEFF 		bl	__assertion_failed
 3038              	.L177:
 912:../drivers/fsl_uart.c ****     assert(count);
 3039              		.loc 4 912 5 is_stmt 1
 3040 001a 7B68     		ldr	r3, [r7, #4]
 3041 001c 002B     		cmp	r3, #0
 3042 001e 03D1     		bne	.L178
 3043              		.loc 4 912 5 is_stmt 0 discriminator 1
 3044 0020 0F4B     		ldr	r3, .L182+4
 3045 0022 1800     		movs	r0, r3
 3046 0024 FFF7FEFF 		bl	__assertion_failed
 3047              	.L178:
 913:../drivers/fsl_uart.c **** 
 914:../drivers/fsl_uart.c ****     if (kUART_RxIdle == handle->rxState)
 3048              		.loc 4 914 31 is_stmt 1
 3049 0028 BB68     		ldr	r3, [r7, #8]
 3050 002a 2D22     		movs	r2, #45
 3051 002c 9B5C     		ldrb	r3, [r3, r2]
 3052 002e DBB2     		uxtb	r3, r3
 3053              		.loc 4 914 8
 3054 0030 022B     		cmp	r3, #2
 3055 0032 01D1     		bne	.L179
 915:../drivers/fsl_uart.c ****     {
 916:../drivers/fsl_uart.c ****         return kStatus_NoTransferInProgress;
 3056              		.loc 4 916 16
 3057 0034 0623     		movs	r3, #6
 3058 0036 0CE0     		b	.L180
 3059              	.L179:
 917:../drivers/fsl_uart.c ****     }
 918:../drivers/fsl_uart.c **** 
 919:../drivers/fsl_uart.c ****     if (!count)
 3060              		.loc 4 919 8
 3061 0038 7B68     		ldr	r3, [r7, #4]
 3062 003a 002B     		cmp	r3, #0
 3063 003c 01D1     		bne	.L181
 920:../drivers/fsl_uart.c ****     {
 921:../drivers/fsl_uart.c ****         return kStatus_InvalidArgument;
 3064              		.loc 4 921 16
 3065 003e 0423     		movs	r3, #4
 3066 0040 07E0     		b	.L180
 3067              	.L181:
 922:../drivers/fsl_uart.c ****     }
 923:../drivers/fsl_uart.c **** 
 924:../drivers/fsl_uart.c ****     *count = handle->rxDataSizeAll - handle->rxDataSize;
 3068              		.loc 4 924 20
 3069 0042 BB68     		ldr	r3, [r7, #8]
 3070 0044 5A69     		ldr	r2, [r3, #20]
 3071              		.loc 4 924 44
 3072 0046 BB68     		ldr	r3, [r7, #8]
 3073 0048 1B69     		ldr	r3, [r3, #16]
 3074              		.loc 4 924 36
 3075 004a D21A     		subs	r2, r2, r3
 3076              		.loc 4 924 12
 3077 004c 7B68     		ldr	r3, [r7, #4]
 3078 004e 1A60     		str	r2, [r3]
 925:../drivers/fsl_uart.c **** 
 926:../drivers/fsl_uart.c ****     return kStatus_Success;
 3079              		.loc 4 926 12
 3080 0050 0023     		movs	r3, #0
 3081              	.L180:
 927:../drivers/fsl_uart.c **** }
 3082              		.loc 4 927 1
 3083 0052 1800     		movs	r0, r3
 3084 0054 BD46     		mov	sp, r7
 3085 0056 04B0     		add	sp, sp, #16
 3086              		@ sp needed
 3087 0058 80BD     		pop	{r7, pc}
 3088              	.L183:
 3089 005a C046     		.align	2
 3090              	.L182:
 3091 005c 00000000 		.word	.LC59
 3092 0060 1C000000 		.word	.LC61
 3093              		.cfi_endproc
 3094              	.LFE87:
 3096              		.section	.rodata.UART_TransferHandleIRQ.str1.4,"aMS",%progbits,1
 3097              		.align	2
 3098              	.LC63:
 3099 0000 2E66736C 		.ascii	".fsl_uart.c:931 : handle\000"
 3099      5F756172 
 3099      742E633A 
 3099      39333120 
 3099      3A206861 
 3100              		.section	.text.UART_TransferHandleIRQ,"ax",%progbits
 3101              		.align	1
 3102              		.global	UART_TransferHandleIRQ
 3103              		.syntax unified
 3104              		.code	16
 3105              		.thumb_func
 3106              		.fpu softvfp
 3108              	UART_TransferHandleIRQ:
 3109              	.LFB88:
 928:../drivers/fsl_uart.c **** 
 929:../drivers/fsl_uart.c **** void UART_TransferHandleIRQ(UART_Type *base, uart_handle_t *handle)
 930:../drivers/fsl_uart.c **** {
 3110              		.loc 4 930 1
 3111              		.cfi_startproc
 3112              		@ args = 0, pretend = 0, frame = 16
 3113              		@ frame_needed = 1, uses_anonymous_args = 0
 3114 0000 90B5     		push	{r4, r7, lr}
 3115              		.cfi_def_cfa_offset 12
 3116              		.cfi_offset 4, -12
 3117              		.cfi_offset 7, -8
 3118              		.cfi_offset 14, -4
 3119 0002 85B0     		sub	sp, sp, #20
 3120              		.cfi_def_cfa_offset 32
 3121 0004 00AF     		add	r7, sp, #0
 3122              		.cfi_def_cfa_register 7
 3123 0006 7860     		str	r0, [r7, #4]
 3124 0008 3960     		str	r1, [r7]
 931:../drivers/fsl_uart.c ****     assert(handle);
 3125              		.loc 4 931 5
 3126 000a 3B68     		ldr	r3, [r7]
 3127 000c 002B     		cmp	r3, #0
 3128 000e 03D1     		bne	.L185
 3129              		.loc 4 931 5 is_stmt 0 discriminator 1
 3130 0010 B54B     		ldr	r3, .L212
 3131 0012 1800     		movs	r0, r3
 3132 0014 FFF7FEFF 		bl	__assertion_failed
 3133              	.L185:
 932:../drivers/fsl_uart.c **** 
 933:../drivers/fsl_uart.c ****     uint8_t count;
 934:../drivers/fsl_uart.c ****     uint8_t tempCount;
 935:../drivers/fsl_uart.c **** 
 936:../drivers/fsl_uart.c ****     /* If RX framing error */
 937:../drivers/fsl_uart.c ****     if (UART_S1_FE_MASK & base->S1)
 3134              		.loc 4 937 31 is_stmt 1
 3135 0018 7B68     		ldr	r3, [r7, #4]
 3136 001a 1B79     		ldrb	r3, [r3, #4]
 3137 001c DBB2     		uxtb	r3, r3
 3138              		.loc 4 937 9
 3139 001e 0222     		movs	r2, #2
 3140 0020 1340     		ands	r3, r2
 3141 0022 DBB2     		uxtb	r3, r3
 3142              		.loc 4 937 8
 3143 0024 002B     		cmp	r3, #0
 3144 0026 1CD0     		beq	.L186
 938:../drivers/fsl_uart.c ****     {
 939:../drivers/fsl_uart.c ****         /* Read base->D to clear framing error flag, otherwise the RX does not work. */
 940:../drivers/fsl_uart.c ****         while (base->S1 & UART_S1_RDRF_MASK)
 3145              		.loc 4 940 15
 3146 0028 01E0     		b	.L187
 3147              	.L188:
 941:../drivers/fsl_uart.c ****         {
 942:../drivers/fsl_uart.c ****             (void)base->D;
 3148              		.loc 4 942 13
 3149 002a 7B68     		ldr	r3, [r7, #4]
 3150 002c DB79     		ldrb	r3, [r3, #7]
 3151              	.L187:
 940:../drivers/fsl_uart.c ****         {
 3152              		.loc 4 940 20
 3153 002e 7B68     		ldr	r3, [r7, #4]
 3154 0030 1B79     		ldrb	r3, [r3, #4]
 3155 0032 DBB2     		uxtb	r3, r3
 940:../drivers/fsl_uart.c ****         {
 3156              		.loc 4 940 25
 3157 0034 1A00     		movs	r2, r3
 3158 0036 2023     		movs	r3, #32
 3159 0038 1340     		ands	r3, r2
 940:../drivers/fsl_uart.c ****         {
 3160              		.loc 4 940 15
 3161 003a F6D1     		bne	.L188
 943:../drivers/fsl_uart.c ****         }
 944:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
 945:../drivers/fsl_uart.c ****         /* Flush FIFO date, otherwise FIFO pointer will be in unknown state. */
 946:../drivers/fsl_uart.c ****         base->CFIFO |= UART_CFIFO_RXFLUSH_MASK;
 947:../drivers/fsl_uart.c **** #endif
 948:../drivers/fsl_uart.c **** 
 949:../drivers/fsl_uart.c ****         handle->rxState = kUART_RxFramingError;
 3162              		.loc 4 949 25
 3163 003c 3B68     		ldr	r3, [r7]
 3164 003e 2D22     		movs	r2, #45
 3165 0040 0421     		movs	r1, #4
 3166 0042 9954     		strb	r1, [r3, r2]
 950:../drivers/fsl_uart.c ****         handle->rxDataSize = 0U;
 3167              		.loc 4 950 28
 3168 0044 3B68     		ldr	r3, [r7]
 3169 0046 0022     		movs	r2, #0
 3170 0048 1A61     		str	r2, [r3, #16]
 951:../drivers/fsl_uart.c ****         /* Trigger callback. */
 952:../drivers/fsl_uart.c ****         if (handle->callback)
 3171              		.loc 4 952 19
 3172 004a 3B68     		ldr	r3, [r7]
 3173 004c 5B6A     		ldr	r3, [r3, #36]
 3174              		.loc 4 952 12
 3175 004e 002B     		cmp	r3, #0
 3176 0050 07D0     		beq	.L186
 953:../drivers/fsl_uart.c ****         {
 954:../drivers/fsl_uart.c ****             handle->callback(base, handle, kStatus_UART_FramingError, handle->userData);
 3177              		.loc 4 954 19
 3178 0052 3B68     		ldr	r3, [r7]
 3179 0054 5C6A     		ldr	r4, [r3, #36]
 3180              		.loc 4 954 13
 3181 0056 3B68     		ldr	r3, [r7]
 3182 0058 9B6A     		ldr	r3, [r3, #40]
 3183 005a A44A     		ldr	r2, .L212+4
 3184 005c 3968     		ldr	r1, [r7]
 3185 005e 7868     		ldr	r0, [r7, #4]
 3186 0060 A047     		blx	r4
 3187              	.LVL11:
 3188              	.L186:
 955:../drivers/fsl_uart.c ****         }
 956:../drivers/fsl_uart.c ****     }
 957:../drivers/fsl_uart.c **** 
 958:../drivers/fsl_uart.c ****     /* If RX parity error */
 959:../drivers/fsl_uart.c ****     if (UART_S1_PF_MASK & base->S1)
 3189              		.loc 4 959 31
 3190 0062 7B68     		ldr	r3, [r7, #4]
 3191 0064 1B79     		ldrb	r3, [r3, #4]
 3192 0066 DBB2     		uxtb	r3, r3
 3193              		.loc 4 959 9
 3194 0068 0122     		movs	r2, #1
 3195 006a 1340     		ands	r3, r2
 3196 006c DBB2     		uxtb	r3, r3
 3197              		.loc 4 959 8
 3198 006e 002B     		cmp	r3, #0
 3199 0070 1DD0     		beq	.L189
 960:../drivers/fsl_uart.c ****     {
 961:../drivers/fsl_uart.c ****         /* Read base->D to clear parity error flag, otherwise the RX does not work. */
 962:../drivers/fsl_uart.c ****         while (base->S1 & UART_S1_RDRF_MASK)
 3200              		.loc 4 962 15
 3201 0072 01E0     		b	.L190
 3202              	.L191:
 963:../drivers/fsl_uart.c ****         {
 964:../drivers/fsl_uart.c ****             (void)base->D;
 3203              		.loc 4 964 13
 3204 0074 7B68     		ldr	r3, [r7, #4]
 3205 0076 DB79     		ldrb	r3, [r3, #7]
 3206              	.L190:
 962:../drivers/fsl_uart.c ****         {
 3207              		.loc 4 962 20
 3208 0078 7B68     		ldr	r3, [r7, #4]
 3209 007a 1B79     		ldrb	r3, [r3, #4]
 3210 007c DBB2     		uxtb	r3, r3
 962:../drivers/fsl_uart.c ****         {
 3211              		.loc 4 962 25
 3212 007e 1A00     		movs	r2, r3
 3213 0080 2023     		movs	r3, #32
 3214 0082 1340     		ands	r3, r2
 962:../drivers/fsl_uart.c ****         {
 3215              		.loc 4 962 15
 3216 0084 F6D1     		bne	.L191
 965:../drivers/fsl_uart.c ****         }
 966:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
 967:../drivers/fsl_uart.c ****         /* Flush FIFO date, otherwise FIFO pointer will be in unknown state. */
 968:../drivers/fsl_uart.c ****         base->CFIFO |= UART_CFIFO_RXFLUSH_MASK;
 969:../drivers/fsl_uart.c **** #endif
 970:../drivers/fsl_uart.c **** 
 971:../drivers/fsl_uart.c ****         handle->rxState = kUART_RxParityError;
 3217              		.loc 4 971 25
 3218 0086 3B68     		ldr	r3, [r7]
 3219 0088 2D22     		movs	r2, #45
 3220 008a 0521     		movs	r1, #5
 3221 008c 9954     		strb	r1, [r3, r2]
 972:../drivers/fsl_uart.c ****         handle->rxDataSize = 0U;
 3222              		.loc 4 972 28
 3223 008e 3B68     		ldr	r3, [r7]
 3224 0090 0022     		movs	r2, #0
 3225 0092 1A61     		str	r2, [r3, #16]
 973:../drivers/fsl_uart.c ****         /* Trigger callback. */
 974:../drivers/fsl_uart.c ****         if (handle->callback)
 3226              		.loc 4 974 19
 3227 0094 3B68     		ldr	r3, [r7]
 3228 0096 5B6A     		ldr	r3, [r3, #36]
 3229              		.loc 4 974 12
 3230 0098 002B     		cmp	r3, #0
 3231 009a 08D0     		beq	.L189
 975:../drivers/fsl_uart.c ****         {
 976:../drivers/fsl_uart.c ****             handle->callback(base, handle, kStatus_UART_ParityError, handle->userData);
 3232              		.loc 4 976 19
 3233 009c 3B68     		ldr	r3, [r7]
 3234 009e 5C6A     		ldr	r4, [r3, #36]
 3235              		.loc 4 976 13
 3236 00a0 3B68     		ldr	r3, [r7]
 3237 00a2 9B6A     		ldr	r3, [r3, #40]
 3238 00a4 FD22     		movs	r2, #253
 3239 00a6 9200     		lsls	r2, r2, #2
 3240 00a8 3968     		ldr	r1, [r7]
 3241 00aa 7868     		ldr	r0, [r7, #4]
 3242 00ac A047     		blx	r4
 3243              	.LVL12:
 3244              	.L189:
 977:../drivers/fsl_uart.c ****         }
 978:../drivers/fsl_uart.c ****     }
 979:../drivers/fsl_uart.c **** 
 980:../drivers/fsl_uart.c ****     /* If RX overrun. */
 981:../drivers/fsl_uart.c ****     if (UART_S1_OR_MASK & base->S1)
 3245              		.loc 4 981 31
 3246 00ae 7B68     		ldr	r3, [r7, #4]
 3247 00b0 1B79     		ldrb	r3, [r3, #4]
 3248 00b2 DBB2     		uxtb	r3, r3
 3249              		.loc 4 981 9
 3250 00b4 0822     		movs	r2, #8
 3251 00b6 1340     		ands	r3, r2
 3252 00b8 DBB2     		uxtb	r3, r3
 3253              		.loc 4 981 8
 3254 00ba 002B     		cmp	r3, #0
 3255 00bc 15D0     		beq	.L192
 982:../drivers/fsl_uart.c ****     {
 983:../drivers/fsl_uart.c ****         /* Read base->D to clear overrun flag, otherwise the RX does not work. */
 984:../drivers/fsl_uart.c ****         while (base->S1 & UART_S1_RDRF_MASK)
 3256              		.loc 4 984 15
 3257 00be 01E0     		b	.L193
 3258              	.L194:
 985:../drivers/fsl_uart.c ****         {
 986:../drivers/fsl_uart.c ****             (void)base->D;
 3259              		.loc 4 986 13
 3260 00c0 7B68     		ldr	r3, [r7, #4]
 3261 00c2 DB79     		ldrb	r3, [r3, #7]
 3262              	.L193:
 984:../drivers/fsl_uart.c ****         {
 3263              		.loc 4 984 20
 3264 00c4 7B68     		ldr	r3, [r7, #4]
 3265 00c6 1B79     		ldrb	r3, [r3, #4]
 3266 00c8 DBB2     		uxtb	r3, r3
 984:../drivers/fsl_uart.c ****         {
 3267              		.loc 4 984 25
 3268 00ca 1A00     		movs	r2, r3
 3269 00cc 2023     		movs	r3, #32
 3270 00ce 1340     		ands	r3, r2
 984:../drivers/fsl_uart.c ****         {
 3271              		.loc 4 984 15
 3272 00d0 F6D1     		bne	.L194
 987:../drivers/fsl_uart.c ****         }
 988:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
 989:../drivers/fsl_uart.c ****         /* Flush FIFO date, otherwise FIFO pointer will be in unknown state. */
 990:../drivers/fsl_uart.c ****         base->CFIFO |= UART_CFIFO_RXFLUSH_MASK;
 991:../drivers/fsl_uart.c **** #endif
 992:../drivers/fsl_uart.c ****         /* Trigger callback. */
 993:../drivers/fsl_uart.c ****         if (handle->callback)
 3273              		.loc 4 993 19
 3274 00d2 3B68     		ldr	r3, [r7]
 3275 00d4 5B6A     		ldr	r3, [r3, #36]
 3276              		.loc 4 993 12
 3277 00d6 002B     		cmp	r3, #0
 3278 00d8 07D0     		beq	.L192
 994:../drivers/fsl_uart.c ****         {
 995:../drivers/fsl_uart.c ****             handle->callback(base, handle, kStatus_UART_RxHardwareOverrun, handle->userData);
 3279              		.loc 4 995 19
 3280 00da 3B68     		ldr	r3, [r7]
 3281 00dc 5C6A     		ldr	r4, [r3, #36]
 3282              		.loc 4 995 13
 3283 00de 3B68     		ldr	r3, [r7]
 3284 00e0 9B6A     		ldr	r3, [r3, #40]
 3285 00e2 834A     		ldr	r2, .L212+8
 3286 00e4 3968     		ldr	r1, [r7]
 3287 00e6 7868     		ldr	r0, [r7, #4]
 3288 00e8 A047     		blx	r4
 3289              	.LVL13:
 3290              	.L192:
 996:../drivers/fsl_uart.c ****         }
 997:../drivers/fsl_uart.c ****     }
 998:../drivers/fsl_uart.c **** 
 999:../drivers/fsl_uart.c ****     /* Receive data register full */
1000:../drivers/fsl_uart.c ****     if ((UART_S1_RDRF_MASK & base->S1) && (UART_C2_RIE_MASK & base->C2))
 3291              		.loc 4 1000 34
 3292 00ea 7B68     		ldr	r3, [r7, #4]
 3293 00ec 1B79     		ldrb	r3, [r3, #4]
 3294 00ee DBB2     		uxtb	r3, r3
 3295              		.loc 4 1000 9
 3296 00f0 2022     		movs	r2, #32
 3297 00f2 1340     		ands	r3, r2
 3298 00f4 DBB2     		uxtb	r3, r3
 3299              		.loc 4 1000 8
 3300 00f6 002B     		cmp	r3, #0
 3301 00f8 00D1     		bne	.LCB2644
 3302 00fa BEE0     		b	.L195	@long jump
 3303              	.LCB2644:
 3304              		.loc 4 1000 67 discriminator 1
 3305 00fc 7B68     		ldr	r3, [r7, #4]
 3306 00fe DB78     		ldrb	r3, [r3, #3]
 3307 0100 DBB2     		uxtb	r3, r3
 3308              		.loc 4 1000 40 discriminator 1
 3309 0102 2022     		movs	r2, #32
 3310 0104 1340     		ands	r3, r2
 3311 0106 DBB2     		uxtb	r3, r3
 3312 0108 002B     		cmp	r3, #0
 3313 010a 00D1     		bne	.LCB2652
 3314 010c B5E0     		b	.L195	@long jump
 3315              	.LCB2652:
1001:../drivers/fsl_uart.c ****     {
1002:../drivers/fsl_uart.c **** /* Get the size that can be stored into buffer for this interrupt. */
1003:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
1004:../drivers/fsl_uart.c ****         count = base->RCFIFO;
1005:../drivers/fsl_uart.c **** #else
1006:../drivers/fsl_uart.c ****         count = 1;
 3316              		.loc 4 1006 15
 3317 010e 0F23     		movs	r3, #15
 3318 0110 FB18     		adds	r3, r7, r3
 3319 0112 0122     		movs	r2, #1
 3320 0114 1A70     		strb	r2, [r3]
1007:../drivers/fsl_uart.c **** #endif
1008:../drivers/fsl_uart.c **** 
1009:../drivers/fsl_uart.c ****         /* If handle->rxDataSize is not 0, first save data to handle->rxData. */
1010:../drivers/fsl_uart.c ****         while ((count) && (handle->rxDataSize))
 3321              		.loc 4 1010 15
 3322 0116 36E0     		b	.L196
 3323              	.L198:
1011:../drivers/fsl_uart.c ****         {
1012:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
1013:../drivers/fsl_uart.c ****             tempCount = MIN(handle->rxDataSize, count);
1014:../drivers/fsl_uart.c **** #else
1015:../drivers/fsl_uart.c ****             tempCount = 1;
 3324              		.loc 4 1015 23
 3325 0118 0E24     		movs	r4, #14
 3326 011a 3B19     		adds	r3, r7, r4
 3327 011c 0122     		movs	r2, #1
 3328 011e 1A70     		strb	r2, [r3]
1016:../drivers/fsl_uart.c **** #endif
1017:../drivers/fsl_uart.c **** 
1018:../drivers/fsl_uart.c ****             /* Using non block API to read the data from the registers. */
1019:../drivers/fsl_uart.c ****             UART_ReadNonBlocking(base, handle->rxData, tempCount);
 3329              		.loc 4 1019 13
 3330 0120 3B68     		ldr	r3, [r7]
 3331 0122 D968     		ldr	r1, [r3, #12]
 3332 0124 3B19     		adds	r3, r7, r4
 3333 0126 1A78     		ldrb	r2, [r3]
 3334 0128 7B68     		ldr	r3, [r7, #4]
 3335 012a 1800     		movs	r0, r3
 3336 012c FFF7FEFF 		bl	UART_ReadNonBlocking
1020:../drivers/fsl_uart.c ****             handle->rxData += tempCount;
 3337              		.loc 4 1020 28
 3338 0130 3B68     		ldr	r3, [r7]
 3339 0132 DA68     		ldr	r2, [r3, #12]
 3340 0134 2000     		movs	r0, r4
 3341 0136 3B18     		adds	r3, r7, r0
 3342 0138 1B78     		ldrb	r3, [r3]
 3343 013a D218     		adds	r2, r2, r3
 3344 013c 3B68     		ldr	r3, [r7]
 3345 013e DA60     		str	r2, [r3, #12]
1021:../drivers/fsl_uart.c ****             handle->rxDataSize -= tempCount;
 3346              		.loc 4 1021 32
 3347 0140 3B68     		ldr	r3, [r7]
 3348 0142 1A69     		ldr	r2, [r3, #16]
 3349 0144 3B18     		adds	r3, r7, r0
 3350 0146 1B78     		ldrb	r3, [r3]
 3351 0148 D21A     		subs	r2, r2, r3
 3352 014a 3B68     		ldr	r3, [r7]
 3353 014c 1A61     		str	r2, [r3, #16]
1022:../drivers/fsl_uart.c ****             count -= tempCount;
 3354              		.loc 4 1022 19
 3355 014e 0F22     		movs	r2, #15
 3356 0150 BB18     		adds	r3, r7, r2
 3357 0152 B918     		adds	r1, r7, r2
 3358 0154 3A18     		adds	r2, r7, r0
 3359 0156 0978     		ldrb	r1, [r1]
 3360 0158 1278     		ldrb	r2, [r2]
 3361 015a 8A1A     		subs	r2, r1, r2
 3362 015c 1A70     		strb	r2, [r3]
1023:../drivers/fsl_uart.c **** 
1024:../drivers/fsl_uart.c ****             /* If all the data required for upper layer is ready, trigger callback. */
1025:../drivers/fsl_uart.c ****             if (!handle->rxDataSize)
 3363              		.loc 4 1025 24
 3364 015e 3B68     		ldr	r3, [r7]
 3365 0160 1B69     		ldr	r3, [r3, #16]
 3366              		.loc 4 1025 16
 3367 0162 002B     		cmp	r3, #0
 3368 0164 0FD1     		bne	.L196
1026:../drivers/fsl_uart.c ****             {
1027:../drivers/fsl_uart.c ****                 handle->rxState = kUART_RxIdle;
 3369              		.loc 4 1027 33
 3370 0166 3B68     		ldr	r3, [r7]
 3371 0168 2D22     		movs	r2, #45
 3372 016a 0221     		movs	r1, #2
 3373 016c 9954     		strb	r1, [r3, r2]
1028:../drivers/fsl_uart.c **** 
1029:../drivers/fsl_uart.c ****                 if (handle->callback)
 3374              		.loc 4 1029 27
 3375 016e 3B68     		ldr	r3, [r7]
 3376 0170 5B6A     		ldr	r3, [r3, #36]
 3377              		.loc 4 1029 20
 3378 0172 002B     		cmp	r3, #0
 3379 0174 07D0     		beq	.L196
1030:../drivers/fsl_uart.c ****                 {
1031:../drivers/fsl_uart.c ****                     handle->callback(base, handle, kStatus_UART_RxIdle, handle->userData);
 3380              		.loc 4 1031 27
 3381 0176 3B68     		ldr	r3, [r7]
 3382 0178 5C6A     		ldr	r4, [r3, #36]
 3383              		.loc 4 1031 21
 3384 017a 3B68     		ldr	r3, [r7]
 3385 017c 9B6A     		ldr	r3, [r3, #40]
 3386 017e 5D4A     		ldr	r2, .L212+12
 3387 0180 3968     		ldr	r1, [r7]
 3388 0182 7868     		ldr	r0, [r7, #4]
 3389 0184 A047     		blx	r4
 3390              	.LVL14:
 3391              	.L196:
1010:../drivers/fsl_uart.c ****         {
 3392              		.loc 4 1010 15
 3393 0186 0F23     		movs	r3, #15
 3394 0188 FB18     		adds	r3, r7, r3
 3395 018a 1B78     		ldrb	r3, [r3]
 3396 018c 002B     		cmp	r3, #0
 3397 018e 03D0     		beq	.L197
1010:../drivers/fsl_uart.c ****         {
 3398              		.loc 4 1010 34 discriminator 1
 3399 0190 3B68     		ldr	r3, [r7]
 3400 0192 1B69     		ldr	r3, [r3, #16]
1010:../drivers/fsl_uart.c ****         {
 3401              		.loc 4 1010 24 discriminator 1
 3402 0194 002B     		cmp	r3, #0
 3403 0196 BFD1     		bne	.L198
 3404              	.L197:
1032:../drivers/fsl_uart.c ****                 }
1033:../drivers/fsl_uart.c ****             }
1034:../drivers/fsl_uart.c ****         }
1035:../drivers/fsl_uart.c **** 
1036:../drivers/fsl_uart.c ****         /* If use RX ring buffer, receive data to ring buffer. */
1037:../drivers/fsl_uart.c ****         if (handle->rxRingBuffer)
 3405              		.loc 4 1037 19
 3406 0198 3B68     		ldr	r3, [r7]
 3407 019a 9B69     		ldr	r3, [r3, #24]
 3408              		.loc 4 1037 12
 3409 019c 002B     		cmp	r3, #0
 3410 019e 52D0     		beq	.L199
1038:../drivers/fsl_uart.c ****         {
1039:../drivers/fsl_uart.c ****             while (count--)
 3411              		.loc 4 1039 19
 3412 01a0 48E0     		b	.L200
 3413              	.L205:
1040:../drivers/fsl_uart.c ****             {
1041:../drivers/fsl_uart.c ****                 /* If RX ring buffer is full, trigger callback to notify over run. */
1042:../drivers/fsl_uart.c ****                 if (UART_TransferIsRxRingBufferFull(handle))
 3414              		.loc 4 1042 21
 3415 01a2 3B68     		ldr	r3, [r7]
 3416 01a4 1800     		movs	r0, r3
 3417 01a6 FFF7FEFF 		bl	UART_TransferIsRxRingBufferFull
 3418 01aa 031E     		subs	r3, r0, #0
 3419              		.loc 4 1042 20
 3420 01ac 0CD0     		beq	.L201
1043:../drivers/fsl_uart.c ****                 {
1044:../drivers/fsl_uart.c ****                     if (handle->callback)
 3421              		.loc 4 1044 31
 3422 01ae 3B68     		ldr	r3, [r7]
 3423 01b0 5B6A     		ldr	r3, [r3, #36]
 3424              		.loc 4 1044 24
 3425 01b2 002B     		cmp	r3, #0
 3426 01b4 08D0     		beq	.L201
1045:../drivers/fsl_uart.c ****                     {
1046:../drivers/fsl_uart.c ****                         handle->callback(base, handle, kStatus_UART_RxRingBufferOverrun, handle->us
 3427              		.loc 4 1046 31
 3428 01b6 3B68     		ldr	r3, [r7]
 3429 01b8 5C6A     		ldr	r4, [r3, #36]
 3430              		.loc 4 1046 25
 3431 01ba 3B68     		ldr	r3, [r7]
 3432 01bc 9B6A     		ldr	r3, [r3, #40]
 3433 01be FC22     		movs	r2, #252
 3434 01c0 9200     		lsls	r2, r2, #2
 3435 01c2 3968     		ldr	r1, [r7]
 3436 01c4 7868     		ldr	r0, [r7, #4]
 3437 01c6 A047     		blx	r4
 3438              	.LVL15:
 3439              	.L201:
1047:../drivers/fsl_uart.c ****                     }
1048:../drivers/fsl_uart.c ****                 }
1049:../drivers/fsl_uart.c **** 
1050:../drivers/fsl_uart.c ****                 /* If ring buffer is still full after callback function, the oldest data is overrid
1051:../drivers/fsl_uart.c ****                 if (UART_TransferIsRxRingBufferFull(handle))
 3440              		.loc 4 1051 21
 3441 01c8 3B68     		ldr	r3, [r7]
 3442 01ca 1800     		movs	r0, r3
 3443 01cc FFF7FEFF 		bl	UART_TransferIsRxRingBufferFull
 3444 01d0 031E     		subs	r3, r0, #0
 3445              		.loc 4 1051 20
 3446 01d2 12D0     		beq	.L202
1052:../drivers/fsl_uart.c ****                 {
1053:../drivers/fsl_uart.c ****                     /* Increase handle->rxRingBufferTail to make room for new data. */
1054:../drivers/fsl_uart.c ****                     if (handle->rxRingBufferTail + 1U == handle->rxRingBufferSize)
 3447              		.loc 4 1054 31
 3448 01d4 3B68     		ldr	r3, [r7]
 3449 01d6 5B8C     		ldrh	r3, [r3, #34]
 3450 01d8 9BB2     		uxth	r3, r3
 3451              		.loc 4 1054 50
 3452 01da 5A1C     		adds	r2, r3, #1
 3453              		.loc 4 1054 64
 3454 01dc 3B68     		ldr	r3, [r7]
 3455 01de DB69     		ldr	r3, [r3, #28]
 3456              		.loc 4 1054 24
 3457 01e0 9A42     		cmp	r2, r3
 3458 01e2 03D1     		bne	.L203
1055:../drivers/fsl_uart.c ****                     {
1056:../drivers/fsl_uart.c ****                         handle->rxRingBufferTail = 0U;
 3459              		.loc 4 1056 50
 3460 01e4 3B68     		ldr	r3, [r7]
 3461 01e6 0022     		movs	r2, #0
 3462 01e8 5A84     		strh	r2, [r3, #34]
 3463 01ea 06E0     		b	.L202
 3464              	.L203:
1057:../drivers/fsl_uart.c ****                     }
1058:../drivers/fsl_uart.c ****                     else
1059:../drivers/fsl_uart.c ****                     {
1060:../drivers/fsl_uart.c ****                         handle->rxRingBufferTail++;
 3465              		.loc 4 1060 31
 3466 01ec 3B68     		ldr	r3, [r7]
 3467 01ee 5B8C     		ldrh	r3, [r3, #34]
 3468 01f0 9BB2     		uxth	r3, r3
 3469              		.loc 4 1060 49
 3470 01f2 0133     		adds	r3, r3, #1
 3471 01f4 9AB2     		uxth	r2, r3
 3472 01f6 3B68     		ldr	r3, [r7]
 3473 01f8 5A84     		strh	r2, [r3, #34]
 3474              	.L202:
1061:../drivers/fsl_uart.c ****                     }
1062:../drivers/fsl_uart.c ****                 }
1063:../drivers/fsl_uart.c **** 
1064:../drivers/fsl_uart.c ****                 /* Read data. */
1065:../drivers/fsl_uart.c ****                 handle->rxRingBuffer[handle->rxRingBufferHead] = base->D;
 3475              		.loc 4 1065 23
 3476 01fa 3B68     		ldr	r3, [r7]
 3477 01fc 9B69     		ldr	r3, [r3, #24]
 3478              		.loc 4 1065 44
 3479 01fe 3A68     		ldr	r2, [r7]
 3480 0200 128C     		ldrh	r2, [r2, #32]
 3481 0202 92B2     		uxth	r2, r2
 3482              		.loc 4 1065 37
 3483 0204 9B18     		adds	r3, r3, r2
 3484              		.loc 4 1065 70
 3485 0206 7A68     		ldr	r2, [r7, #4]
 3486 0208 D279     		ldrb	r2, [r2, #7]
 3487 020a D2B2     		uxtb	r2, r2
 3488              		.loc 4 1065 64
 3489 020c 1A70     		strb	r2, [r3]
1066:../drivers/fsl_uart.c **** 
1067:../drivers/fsl_uart.c ****                 /* Increase handle->rxRingBufferHead. */
1068:../drivers/fsl_uart.c ****                 if (handle->rxRingBufferHead + 1U == handle->rxRingBufferSize)
 3490              		.loc 4 1068 27
 3491 020e 3B68     		ldr	r3, [r7]
 3492 0210 1B8C     		ldrh	r3, [r3, #32]
 3493 0212 9BB2     		uxth	r3, r3
 3494              		.loc 4 1068 46
 3495 0214 5A1C     		adds	r2, r3, #1
 3496              		.loc 4 1068 60
 3497 0216 3B68     		ldr	r3, [r7]
 3498 0218 DB69     		ldr	r3, [r3, #28]
 3499              		.loc 4 1068 20
 3500 021a 9A42     		cmp	r2, r3
 3501 021c 03D1     		bne	.L204
1069:../drivers/fsl_uart.c ****                 {
1070:../drivers/fsl_uart.c ****                     handle->rxRingBufferHead = 0U;
 3502              		.loc 4 1070 46
 3503 021e 3B68     		ldr	r3, [r7]
 3504 0220 0022     		movs	r2, #0
 3505 0222 1A84     		strh	r2, [r3, #32]
 3506 0224 06E0     		b	.L200
 3507              	.L204:
1071:../drivers/fsl_uart.c ****                 }
1072:../drivers/fsl_uart.c ****                 else
1073:../drivers/fsl_uart.c ****                 {
1074:../drivers/fsl_uart.c ****                     handle->rxRingBufferHead++;
 3508              		.loc 4 1074 27
 3509 0226 3B68     		ldr	r3, [r7]
 3510 0228 1B8C     		ldrh	r3, [r3, #32]
 3511 022a 9BB2     		uxth	r3, r3
 3512              		.loc 4 1074 45
 3513 022c 0133     		adds	r3, r3, #1
 3514 022e 9AB2     		uxth	r2, r3
 3515 0230 3B68     		ldr	r3, [r7]
 3516 0232 1A84     		strh	r2, [r3, #32]
 3517              	.L200:
1039:../drivers/fsl_uart.c ****             {
 3518              		.loc 4 1039 25
 3519 0234 0F22     		movs	r2, #15
 3520 0236 BB18     		adds	r3, r7, r2
 3521 0238 1B78     		ldrb	r3, [r3]
 3522 023a BA18     		adds	r2, r7, r2
 3523 023c 591E     		subs	r1, r3, #1
 3524 023e 1170     		strb	r1, [r2]
1039:../drivers/fsl_uart.c ****             {
 3525              		.loc 4 1039 19
 3526 0240 002B     		cmp	r3, #0
 3527 0242 AED1     		bne	.L205
 3528 0244 19E0     		b	.L195
 3529              	.L199:
1075:../drivers/fsl_uart.c ****                 }
1076:../drivers/fsl_uart.c ****             }
1077:../drivers/fsl_uart.c ****         }
1078:../drivers/fsl_uart.c **** 
1079:../drivers/fsl_uart.c ****         else if (!handle->rxDataSize)
 3530              		.loc 4 1079 25
 3531 0246 3B68     		ldr	r3, [r7]
 3532 0248 1B69     		ldr	r3, [r3, #16]
 3533              		.loc 4 1079 17
 3534 024a 002B     		cmp	r3, #0
 3535 024c 15D1     		bne	.L195
1080:../drivers/fsl_uart.c ****         {
1081:../drivers/fsl_uart.c ****             /* Disable RX interrupt/overrun interrupt/fram error interrupt */
1082:../drivers/fsl_uart.c ****             UART_DisableInterrupts(base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterr
 3536              		.loc 4 1082 13
 3537 024e A223     		movs	r3, #162
 3538 0250 1A03     		lsls	r2, r3, #12
 3539 0252 7B68     		ldr	r3, [r7, #4]
 3540 0254 1100     		movs	r1, r2
 3541 0256 1800     		movs	r0, r3
 3542 0258 FFF7FEFF 		bl	UART_DisableInterrupts
1083:../drivers/fsl_uart.c ****                                              kUART_FramingErrorInterruptEnable);
1084:../drivers/fsl_uart.c **** 
1085:../drivers/fsl_uart.c ****             /* Disable parity error interrupt when parity mode is enable*/
1086:../drivers/fsl_uart.c ****             if (UART_C1_PE_MASK & base->C1)
 3543              		.loc 4 1086 39
 3544 025c 7B68     		ldr	r3, [r7, #4]
 3545 025e 9B78     		ldrb	r3, [r3, #2]
 3546 0260 DBB2     		uxtb	r3, r3
 3547              		.loc 4 1086 17
 3548 0262 0222     		movs	r2, #2
 3549 0264 1340     		ands	r3, r2
 3550 0266 DBB2     		uxtb	r3, r3
 3551              		.loc 4 1086 16
 3552 0268 002B     		cmp	r3, #0
 3553 026a 06D0     		beq	.L195
1087:../drivers/fsl_uart.c ****             {
1088:../drivers/fsl_uart.c ****                 UART_DisableInterrupts(base, kUART_ParityErrorInterruptEnable);
 3554              		.loc 4 1088 17
 3555 026c 8023     		movs	r3, #128
 3556 026e 5A02     		lsls	r2, r3, #9
 3557 0270 7B68     		ldr	r3, [r7, #4]
 3558 0272 1100     		movs	r1, r2
 3559 0274 1800     		movs	r0, r3
 3560 0276 FFF7FEFF 		bl	UART_DisableInterrupts
 3561              	.L195:
1089:../drivers/fsl_uart.c ****             }
1090:../drivers/fsl_uart.c ****         }
1091:../drivers/fsl_uart.c ****         else
1092:../drivers/fsl_uart.c ****         {
1093:../drivers/fsl_uart.c ****         }
1094:../drivers/fsl_uart.c ****     }
1095:../drivers/fsl_uart.c **** 
1096:../drivers/fsl_uart.c ****     /* If framing error or parity error happened, stop the RX interrupt when ues no ring buffer */
1097:../drivers/fsl_uart.c ****     if (((handle->rxState == kUART_RxFramingError) || (handle->rxState == kUART_RxParityError)) &&
 3562              		.loc 4 1097 17
 3563 027a 3B68     		ldr	r3, [r7]
 3564 027c 2D22     		movs	r2, #45
 3565 027e 9B5C     		ldrb	r3, [r3, r2]
 3566 0280 DBB2     		uxtb	r3, r3
 3567              		.loc 4 1097 8
 3568 0282 042B     		cmp	r3, #4
 3569 0284 05D0     		beq	.L206
 3570              		.loc 4 1097 62 discriminator 2
 3571 0286 3B68     		ldr	r3, [r7]
 3572 0288 2D22     		movs	r2, #45
 3573 028a 9B5C     		ldrb	r3, [r3, r2]
 3574 028c DBB2     		uxtb	r3, r3
 3575              		.loc 4 1097 52 discriminator 2
 3576 028e 052B     		cmp	r3, #5
 3577 0290 19D1     		bne	.L207
 3578              	.L206:
1098:../drivers/fsl_uart.c ****         (!handle->rxRingBuffer))
 3579              		.loc 4 1098 17 discriminator 3
 3580 0292 3B68     		ldr	r3, [r7]
 3581 0294 9B69     		ldr	r3, [r3, #24]
1097:../drivers/fsl_uart.c ****         (!handle->rxRingBuffer))
 3582              		.loc 4 1097 97 discriminator 3
 3583 0296 002B     		cmp	r3, #0
 3584 0298 15D1     		bne	.L207
1099:../drivers/fsl_uart.c ****     {
1100:../drivers/fsl_uart.c ****         UART_DisableInterrupts(base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterruptE
 3585              		.loc 4 1100 9
 3586 029a A223     		movs	r3, #162
 3587 029c 1A03     		lsls	r2, r3, #12
 3588 029e 7B68     		ldr	r3, [r7, #4]
 3589 02a0 1100     		movs	r1, r2
 3590 02a2 1800     		movs	r0, r3
 3591 02a4 FFF7FEFF 		bl	UART_DisableInterrupts
1101:../drivers/fsl_uart.c ****                                          kUART_FramingErrorInterruptEnable);
1102:../drivers/fsl_uart.c **** 
1103:../drivers/fsl_uart.c ****         /* Disable parity error interrupt when parity mode is enable*/
1104:../drivers/fsl_uart.c ****         if (UART_C1_PE_MASK & base->C1)
 3592              		.loc 4 1104 35
 3593 02a8 7B68     		ldr	r3, [r7, #4]
 3594 02aa 9B78     		ldrb	r3, [r3, #2]
 3595 02ac DBB2     		uxtb	r3, r3
 3596              		.loc 4 1104 13
 3597 02ae 0222     		movs	r2, #2
 3598 02b0 1340     		ands	r3, r2
 3599 02b2 DBB2     		uxtb	r3, r3
 3600              		.loc 4 1104 12
 3601 02b4 002B     		cmp	r3, #0
 3602 02b6 06D0     		beq	.L207
1105:../drivers/fsl_uart.c ****         {
1106:../drivers/fsl_uart.c ****             UART_DisableInterrupts(base, kUART_ParityErrorInterruptEnable);
 3603              		.loc 4 1106 13
 3604 02b8 8023     		movs	r3, #128
 3605 02ba 5A02     		lsls	r2, r3, #9
 3606 02bc 7B68     		ldr	r3, [r7, #4]
 3607 02be 1100     		movs	r1, r2
 3608 02c0 1800     		movs	r0, r3
 3609 02c2 FFF7FEFF 		bl	UART_DisableInterrupts
 3610              	.L207:
1107:../drivers/fsl_uart.c ****         }
1108:../drivers/fsl_uart.c ****     }
1109:../drivers/fsl_uart.c **** 
1110:../drivers/fsl_uart.c ****     /* Send data register empty and the interrupt is enabled. */
1111:../drivers/fsl_uart.c ****     if ((base->S1 & UART_S1_TDRE_MASK) && (base->C2 & UART_C2_TIE_MASK))
 3611              		.loc 4 1111 14
 3612 02c6 7B68     		ldr	r3, [r7, #4]
 3613 02c8 1B79     		ldrb	r3, [r3, #4]
 3614 02ca DBB2     		uxtb	r3, r3
 3615              		.loc 4 1111 9
 3616 02cc 5BB2     		sxtb	r3, r3
 3617              		.loc 4 1111 8
 3618 02ce 002B     		cmp	r3, #0
 3619 02d0 5ADA     		bge	.L211
 3620              		.loc 4 1111 48 discriminator 1
 3621 02d2 7B68     		ldr	r3, [r7, #4]
 3622 02d4 DB78     		ldrb	r3, [r3, #3]
 3623 02d6 DBB2     		uxtb	r3, r3
 3624              		.loc 4 1111 40 discriminator 1
 3625 02d8 5BB2     		sxtb	r3, r3
 3626 02da 002B     		cmp	r3, #0
 3627 02dc 54DA     		bge	.L211
1112:../drivers/fsl_uart.c ****     {
1113:../drivers/fsl_uart.c **** /* Get the bytes that available at this moment. */
1114:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
1115:../drivers/fsl_uart.c ****         count = FSL_FEATURE_UART_FIFO_SIZEn(base) - base->TCFIFO;
1116:../drivers/fsl_uart.c **** #else
1117:../drivers/fsl_uart.c ****         count = 1;
 3628              		.loc 4 1117 15
 3629 02de 0F23     		movs	r3, #15
 3630 02e0 FB18     		adds	r3, r7, r3
 3631 02e2 0122     		movs	r2, #1
 3632 02e4 1A70     		strb	r2, [r3]
1118:../drivers/fsl_uart.c **** #endif
1119:../drivers/fsl_uart.c **** 
1120:../drivers/fsl_uart.c ****         while ((count) && (handle->txDataSize))
 3633              		.loc 4 1120 15
 3634 02e6 46E0     		b	.L209
 3635              	.L213:
 3636              		.align	2
 3637              	.L212:
 3638 02e8 00000000 		.word	.LC63
 3639 02ec F3030000 		.word	1011
 3640 02f0 F1030000 		.word	1009
 3641 02f4 EB030000 		.word	1003
 3642              	.L210:
1121:../drivers/fsl_uart.c ****         {
1122:../drivers/fsl_uart.c **** #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
1123:../drivers/fsl_uart.c ****             tempCount = MIN(handle->txDataSize, count);
1124:../drivers/fsl_uart.c **** #else
1125:../drivers/fsl_uart.c ****             tempCount = 1;
 3643              		.loc 4 1125 23
 3644 02f8 0E24     		movs	r4, #14
 3645 02fa 3B19     		adds	r3, r7, r4
 3646 02fc 0122     		movs	r2, #1
 3647 02fe 1A70     		strb	r2, [r3]
1126:../drivers/fsl_uart.c **** #endif
1127:../drivers/fsl_uart.c **** 
1128:../drivers/fsl_uart.c ****             /* Using non block API to write the data to the registers. */
1129:../drivers/fsl_uart.c ****             UART_WriteNonBlocking(base, handle->txData, tempCount);
 3648              		.loc 4 1129 47
 3649 0300 3B68     		ldr	r3, [r7]
 3650 0302 1968     		ldr	r1, [r3]
 3651              		.loc 4 1129 13
 3652 0304 3B19     		adds	r3, r7, r4
 3653 0306 1A78     		ldrb	r2, [r3]
 3654 0308 7B68     		ldr	r3, [r7, #4]
 3655 030a 1800     		movs	r0, r3
 3656 030c FFF7FEFF 		bl	UART_WriteNonBlocking
1130:../drivers/fsl_uart.c ****             handle->txData += tempCount;
 3657              		.loc 4 1130 28
 3658 0310 3B68     		ldr	r3, [r7]
 3659 0312 1A68     		ldr	r2, [r3]
 3660 0314 2000     		movs	r0, r4
 3661 0316 3B18     		adds	r3, r7, r0
 3662 0318 1B78     		ldrb	r3, [r3]
 3663 031a D218     		adds	r2, r2, r3
 3664 031c 3B68     		ldr	r3, [r7]
 3665 031e 1A60     		str	r2, [r3]
1131:../drivers/fsl_uart.c ****             handle->txDataSize -= tempCount;
 3666              		.loc 4 1131 32
 3667 0320 3B68     		ldr	r3, [r7]
 3668 0322 5A68     		ldr	r2, [r3, #4]
 3669 0324 3B18     		adds	r3, r7, r0
 3670 0326 1B78     		ldrb	r3, [r3]
 3671 0328 D21A     		subs	r2, r2, r3
 3672 032a 3B68     		ldr	r3, [r7]
 3673 032c 5A60     		str	r2, [r3, #4]
1132:../drivers/fsl_uart.c ****             count -= tempCount;
 3674              		.loc 4 1132 19
 3675 032e 0F22     		movs	r2, #15
 3676 0330 BB18     		adds	r3, r7, r2
 3677 0332 B918     		adds	r1, r7, r2
 3678 0334 3A18     		adds	r2, r7, r0
 3679 0336 0978     		ldrb	r1, [r1]
 3680 0338 1278     		ldrb	r2, [r2]
 3681 033a 8A1A     		subs	r2, r1, r2
 3682 033c 1A70     		strb	r2, [r3]
1133:../drivers/fsl_uart.c **** 
1134:../drivers/fsl_uart.c ****             /* If all the data are written to data register, TX finished. */
1135:../drivers/fsl_uart.c ****             if (!handle->txDataSize)
 3683              		.loc 4 1135 24
 3684 033e 3B68     		ldr	r3, [r7]
 3685 0340 5B68     		ldr	r3, [r3, #4]
 3686              		.loc 4 1135 16
 3687 0342 002B     		cmp	r3, #0
 3688 0344 17D1     		bne	.L209
1136:../drivers/fsl_uart.c ****             {
1137:../drivers/fsl_uart.c ****                 handle->txState = kUART_TxIdle;
 3689              		.loc 4 1137 33
 3690 0346 3B68     		ldr	r3, [r7]
 3691 0348 2C22     		movs	r2, #44
 3692 034a 0021     		movs	r1, #0
 3693 034c 9954     		strb	r1, [r3, r2]
1138:../drivers/fsl_uart.c **** 
1139:../drivers/fsl_uart.c ****                 /* Disable TX register empty interrupt. */
1140:../drivers/fsl_uart.c ****                 base->C2 = (base->C2 & ~UART_C2_TIE_MASK);
 3694              		.loc 4 1140 33
 3695 034e 7B68     		ldr	r3, [r7, #4]
 3696 0350 DB78     		ldrb	r3, [r3, #3]
 3697 0352 DBB2     		uxtb	r3, r3
 3698              		.loc 4 1140 38
 3699 0354 7F22     		movs	r2, #127
 3700 0356 1340     		ands	r3, r2
 3701 0358 DAB2     		uxtb	r2, r3
 3702              		.loc 4 1140 26
 3703 035a 7B68     		ldr	r3, [r7, #4]
 3704 035c DA70     		strb	r2, [r3, #3]
1141:../drivers/fsl_uart.c **** 
1142:../drivers/fsl_uart.c ****                 /* Trigger callback. */
1143:../drivers/fsl_uart.c ****                 if (handle->callback)
 3705              		.loc 4 1143 27
 3706 035e 3B68     		ldr	r3, [r7]
 3707 0360 5B6A     		ldr	r3, [r3, #36]
 3708              		.loc 4 1143 20
 3709 0362 002B     		cmp	r3, #0
 3710 0364 07D0     		beq	.L209
1144:../drivers/fsl_uart.c ****                 {
1145:../drivers/fsl_uart.c ****                     handle->callback(base, handle, kStatus_UART_TxIdle, handle->userData);
 3711              		.loc 4 1145 27
 3712 0366 3B68     		ldr	r3, [r7]
 3713 0368 5C6A     		ldr	r4, [r3, #36]
 3714              		.loc 4 1145 21
 3715 036a 3B68     		ldr	r3, [r7]
 3716 036c 9B6A     		ldr	r3, [r3, #40]
 3717 036e 084A     		ldr	r2, .L214
 3718 0370 3968     		ldr	r1, [r7]
 3719 0372 7868     		ldr	r0, [r7, #4]
 3720 0374 A047     		blx	r4
 3721              	.LVL16:
 3722              	.L209:
1120:../drivers/fsl_uart.c ****         {
 3723              		.loc 4 1120 15
 3724 0376 0F23     		movs	r3, #15
 3725 0378 FB18     		adds	r3, r7, r3
 3726 037a 1B78     		ldrb	r3, [r3]
 3727 037c 002B     		cmp	r3, #0
 3728 037e 03D0     		beq	.L211
1120:../drivers/fsl_uart.c ****         {
 3729              		.loc 4 1120 34 discriminator 1
 3730 0380 3B68     		ldr	r3, [r7]
 3731 0382 5B68     		ldr	r3, [r3, #4]
1120:../drivers/fsl_uart.c ****         {
 3732              		.loc 4 1120 24 discriminator 1
 3733 0384 002B     		cmp	r3, #0
 3734 0386 B7D1     		bne	.L210
 3735              	.L211:
1146:../drivers/fsl_uart.c ****                 }
1147:../drivers/fsl_uart.c ****             }
1148:../drivers/fsl_uart.c ****         }
1149:../drivers/fsl_uart.c ****     }
1150:../drivers/fsl_uart.c **** }
 3736              		.loc 4 1150 1
 3737 0388 C046     		nop
 3738 038a BD46     		mov	sp, r7
 3739 038c 05B0     		add	sp, sp, #20
 3740              		@ sp needed
 3741 038e 90BD     		pop	{r4, r7, pc}
 3742              	.L215:
 3743              		.align	2
 3744              	.L214:
 3745 0390 EA030000 		.word	1002
 3746              		.cfi_endproc
 3747              	.LFE88:
 3749              		.section	.text.UART_TransferHandleErrorIRQ,"ax",%progbits
 3750              		.align	1
 3751              		.global	UART_TransferHandleErrorIRQ
 3752              		.syntax unified
 3753              		.code	16
 3754              		.thumb_func
 3755              		.fpu softvfp
 3757              	UART_TransferHandleErrorIRQ:
 3758              	.LFB89:
1151:../drivers/fsl_uart.c **** 
1152:../drivers/fsl_uart.c **** void UART_TransferHandleErrorIRQ(UART_Type *base, uart_handle_t *handle)
1153:../drivers/fsl_uart.c **** {
 3759              		.loc 4 1153 1
 3760              		.cfi_startproc
 3761              		@ args = 0, pretend = 0, frame = 8
 3762              		@ frame_needed = 1, uses_anonymous_args = 0
 3763 0000 80B5     		push	{r7, lr}
 3764              		.cfi_def_cfa_offset 8
 3765              		.cfi_offset 7, -8
 3766              		.cfi_offset 14, -4
 3767 0002 82B0     		sub	sp, sp, #8
 3768              		.cfi_def_cfa_offset 16
 3769 0004 00AF     		add	r7, sp, #0
 3770              		.cfi_def_cfa_register 7
 3771 0006 7860     		str	r0, [r7, #4]
 3772 0008 3960     		str	r1, [r7]
1154:../drivers/fsl_uart.c ****     /* To be implemented by User. */
1155:../drivers/fsl_uart.c **** }
 3773              		.loc 4 1155 1
 3774 000a C046     		nop
 3775 000c BD46     		mov	sp, r7
 3776 000e 02B0     		add	sp, sp, #8
 3777              		@ sp needed
 3778 0010 80BD     		pop	{r7, pc}
 3779              		.cfi_endproc
 3780              	.LFE89:
 3782              		.section	.text.UART1_DriverIRQHandler,"ax",%progbits
 3783              		.align	1
 3784              		.global	UART1_DriverIRQHandler
 3785              		.syntax unified
 3786              		.code	16
 3787              		.thumb_func
 3788              		.fpu softvfp
 3790              	UART1_DriverIRQHandler:
 3791              	.LFB90:
1156:../drivers/fsl_uart.c **** 
1157:../drivers/fsl_uart.c **** #if defined(UART0)
1158:../drivers/fsl_uart.c **** #if ((!(defined(FSL_FEATURE_SOC_LPSCI_COUNT))) || \
1159:../drivers/fsl_uart.c ****      ((defined(FSL_FEATURE_SOC_LPSCI_COUNT)) && (FSL_FEATURE_SOC_LPSCI_COUNT == 0)))
1160:../drivers/fsl_uart.c **** void UART0_DriverIRQHandler(void)
1161:../drivers/fsl_uart.c **** {
1162:../drivers/fsl_uart.c ****     s_uartIsr(UART0, s_uartHandle[0]);
1163:../drivers/fsl_uart.c **** }
1164:../drivers/fsl_uart.c **** 
1165:../drivers/fsl_uart.c **** void UART0_RX_TX_DriverIRQHandler(void)
1166:../drivers/fsl_uart.c **** {
1167:../drivers/fsl_uart.c ****     UART0_DriverIRQHandler();
1168:../drivers/fsl_uart.c **** }
1169:../drivers/fsl_uart.c **** #endif
1170:../drivers/fsl_uart.c **** #endif
1171:../drivers/fsl_uart.c **** 
1172:../drivers/fsl_uart.c **** #if defined(UART1)
1173:../drivers/fsl_uart.c **** void UART1_DriverIRQHandler(void)
1174:../drivers/fsl_uart.c **** {
 3792              		.loc 4 1174 1
 3793              		.cfi_startproc
 3794              		@ args = 0, pretend = 0, frame = 0
 3795              		@ frame_needed = 1, uses_anonymous_args = 0
 3796 0000 80B5     		push	{r7, lr}
 3797              		.cfi_def_cfa_offset 8
 3798              		.cfi_offset 7, -8
 3799              		.cfi_offset 14, -4
 3800 0002 00AF     		add	r7, sp, #0
 3801              		.cfi_def_cfa_register 7
1175:../drivers/fsl_uart.c ****     s_uartIsr(UART1, s_uartHandle[1]);
 3802              		.loc 4 1175 5
 3803 0004 044B     		ldr	r3, .L218
 3804 0006 1A68     		ldr	r2, [r3]
 3805 0008 044B     		ldr	r3, .L218+4
 3806 000a 5B68     		ldr	r3, [r3, #4]
 3807 000c 0448     		ldr	r0, .L218+8
 3808 000e 1900     		movs	r1, r3
 3809 0010 9047     		blx	r2
 3810              	.LVL17:
1176:../drivers/fsl_uart.c **** }
 3811              		.loc 4 1176 1
 3812 0012 C046     		nop
 3813 0014 BD46     		mov	sp, r7
 3814              		@ sp needed
 3815 0016 80BD     		pop	{r7, pc}
 3816              	.L219:
 3817              		.align	2
 3818              	.L218:
 3819 0018 00000000 		.word	s_uartIsr
 3820 001c 00000000 		.word	s_uartHandle
 3821 0020 00B00640 		.word	1074180096
 3822              		.cfi_endproc
 3823              	.LFE90:
 3825              		.section	.text.UART1_RX_TX_DriverIRQHandler,"ax",%progbits
 3826              		.align	1
 3827              		.global	UART1_RX_TX_DriverIRQHandler
 3828              		.syntax unified
 3829              		.code	16
 3830              		.thumb_func
 3831              		.fpu softvfp
 3833              	UART1_RX_TX_DriverIRQHandler:
 3834              	.LFB91:
1177:../drivers/fsl_uart.c **** 
1178:../drivers/fsl_uart.c **** void UART1_RX_TX_DriverIRQHandler(void)
1179:../drivers/fsl_uart.c **** {
 3835              		.loc 4 1179 1
 3836              		.cfi_startproc
 3837              		@ args = 0, pretend = 0, frame = 0
 3838              		@ frame_needed = 1, uses_anonymous_args = 0
 3839 0000 80B5     		push	{r7, lr}
 3840              		.cfi_def_cfa_offset 8
 3841              		.cfi_offset 7, -8
 3842              		.cfi_offset 14, -4
 3843 0002 00AF     		add	r7, sp, #0
 3844              		.cfi_def_cfa_register 7
1180:../drivers/fsl_uart.c ****     UART1_DriverIRQHandler();
 3845              		.loc 4 1180 5
 3846 0004 FFF7FEFF 		bl	UART1_DriverIRQHandler
1181:../drivers/fsl_uart.c **** }
 3847              		.loc 4 1181 1
 3848 0008 C046     		nop
 3849 000a BD46     		mov	sp, r7
 3850              		@ sp needed
 3851 000c 80BD     		pop	{r7, pc}
 3852              		.cfi_endproc
 3853              	.LFE91:
 3855              		.section	.text.UART2_DriverIRQHandler,"ax",%progbits
 3856              		.align	1
 3857              		.global	UART2_DriverIRQHandler
 3858              		.syntax unified
 3859              		.code	16
 3860              		.thumb_func
 3861              		.fpu softvfp
 3863              	UART2_DriverIRQHandler:
 3864              	.LFB92:
1182:../drivers/fsl_uart.c **** #endif
1183:../drivers/fsl_uart.c **** 
1184:../drivers/fsl_uart.c **** #if defined(UART2)
1185:../drivers/fsl_uart.c **** void UART2_DriverIRQHandler(void)
1186:../drivers/fsl_uart.c **** {
 3865              		.loc 4 1186 1
 3866              		.cfi_startproc
 3867              		@ args = 0, pretend = 0, frame = 0
 3868              		@ frame_needed = 1, uses_anonymous_args = 0
 3869 0000 80B5     		push	{r7, lr}
 3870              		.cfi_def_cfa_offset 8
 3871              		.cfi_offset 7, -8
 3872              		.cfi_offset 14, -4
 3873 0002 00AF     		add	r7, sp, #0
 3874              		.cfi_def_cfa_register 7
1187:../drivers/fsl_uart.c ****     s_uartIsr(UART2, s_uartHandle[2]);
 3875              		.loc 4 1187 5
 3876 0004 044B     		ldr	r3, .L222
 3877 0006 1A68     		ldr	r2, [r3]
 3878 0008 044B     		ldr	r3, .L222+4
 3879 000a 9B68     		ldr	r3, [r3, #8]
 3880 000c 0448     		ldr	r0, .L222+8
 3881 000e 1900     		movs	r1, r3
 3882 0010 9047     		blx	r2
 3883              	.LVL18:
1188:../drivers/fsl_uart.c **** }
 3884              		.loc 4 1188 1
 3885 0012 C046     		nop
 3886 0014 BD46     		mov	sp, r7
 3887              		@ sp needed
 3888 0016 80BD     		pop	{r7, pc}
 3889              	.L223:
 3890              		.align	2
 3891              	.L222:
 3892 0018 00000000 		.word	s_uartIsr
 3893 001c 00000000 		.word	s_uartHandle
 3894 0020 00C00640 		.word	1074184192
 3895              		.cfi_endproc
 3896              	.LFE92:
 3898              		.section	.text.UART2_RX_TX_DriverIRQHandler,"ax",%progbits
 3899              		.align	1
 3900              		.global	UART2_RX_TX_DriverIRQHandler
 3901              		.syntax unified
 3902              		.code	16
 3903              		.thumb_func
 3904              		.fpu softvfp
 3906              	UART2_RX_TX_DriverIRQHandler:
 3907              	.LFB93:
1189:../drivers/fsl_uart.c **** 
1190:../drivers/fsl_uart.c **** void UART2_RX_TX_DriverIRQHandler(void)
1191:../drivers/fsl_uart.c **** {
 3908              		.loc 4 1191 1
 3909              		.cfi_startproc
 3910              		@ args = 0, pretend = 0, frame = 0
 3911              		@ frame_needed = 1, uses_anonymous_args = 0
 3912 0000 80B5     		push	{r7, lr}
 3913              		.cfi_def_cfa_offset 8
 3914              		.cfi_offset 7, -8
 3915              		.cfi_offset 14, -4
 3916 0002 00AF     		add	r7, sp, #0
 3917              		.cfi_def_cfa_register 7
1192:../drivers/fsl_uart.c ****     UART2_DriverIRQHandler();
 3918              		.loc 4 1192 5
 3919 0004 FFF7FEFF 		bl	UART2_DriverIRQHandler
1193:../drivers/fsl_uart.c **** }
 3920              		.loc 4 1193 1
 3921 0008 C046     		nop
 3922 000a BD46     		mov	sp, r7
 3923              		@ sp needed
 3924 000c 80BD     		pop	{r7, pc}
 3925              		.cfi_endproc
 3926              	.LFE93:
 3928              		.text
 3929              	.Letext0:
 3930              		.file 5 "/usr/local/mcuxpressoide-11.2.0_4120/ide/plugins/com.nxp.mcuxpresso.tools.linux_11.2.0.20
 3931              		.file 6 "/usr/local/mcuxpressoide-11.2.0_4120/ide/plugins/com.nxp.mcuxpresso.tools.linux_11.2.0.20
 3932              		.file 7 "/home/arpit/studies/pes/Blinkenlights/CMSIS/MKL25Z4.h"
 3933              		.file 8 "/home/arpit/studies/pes/Blinkenlights/CMSIS/system_MKL25Z4.h"
 3934              		.file 9 "../drivers/fsl_uart.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 fsl_uart.c
     /tmp/ccEPGjFB.s:16     .text.NVIC_EnableIRQ:0000000000000000 $t
     /tmp/ccEPGjFB.s:23     .text.NVIC_EnableIRQ:0000000000000000 NVIC_EnableIRQ
     /tmp/ccEPGjFB.s:64     .text.NVIC_EnableIRQ:0000000000000028 $d
     /tmp/ccEPGjFB.s:69     .text.CLOCK_EnableClock:0000000000000000 $t
     /tmp/ccEPGjFB.s:75     .text.CLOCK_EnableClock:0000000000000000 CLOCK_EnableClock
     /tmp/ccEPGjFB.s:122    .text.CLOCK_EnableClock:0000000000000030 $d
     /tmp/ccEPGjFB.s:127    .text.CLOCK_DisableClock:0000000000000000 $t
     /tmp/ccEPGjFB.s:133    .text.CLOCK_DisableClock:0000000000000000 CLOCK_DisableClock
     /tmp/ccEPGjFB.s:182    .text.CLOCK_DisableClock:0000000000000034 $d
     /tmp/ccEPGjFB.s:187    .text.EnableIRQ:0000000000000000 $t
     /tmp/ccEPGjFB.s:193    .text.EnableIRQ:0000000000000000 EnableIRQ
     /tmp/ccEPGjFB.s:237    .bss.s_uartHandle:0000000000000000 $d
     /tmp/ccEPGjFB.s:240    .bss.s_uartHandle:0000000000000000 s_uartHandle
     /tmp/ccEPGjFB.s:243    .rodata.s_uartBases:0000000000000000 $d
     /tmp/ccEPGjFB.s:246    .rodata.s_uartBases:0000000000000000 s_uartBases
     /tmp/ccEPGjFB.s:251    .rodata.s_uartIRQ:0000000000000000 $d
     /tmp/ccEPGjFB.s:254    .rodata.s_uartIRQ:0000000000000000 s_uartIRQ
     /tmp/ccEPGjFB.s:259    .rodata.s_uartClock:0000000000000000 $d
     /tmp/ccEPGjFB.s:262    .rodata.s_uartClock:0000000000000000 s_uartClock
     /tmp/ccEPGjFB.s:267    .bss.s_uartIsr:0000000000000000 $d
     /tmp/ccEPGjFB.s:270    .bss.s_uartIsr:0000000000000000 s_uartIsr
     /tmp/ccEPGjFB.s:273    .rodata.UART_GetInstance.str1.4:0000000000000000 $d
     /tmp/ccEPGjFB.s:277    .text.UART_GetInstance:0000000000000000 $t
     /tmp/ccEPGjFB.s:284    .text.UART_GetInstance:0000000000000000 UART_GetInstance
     /tmp/ccEPGjFB.s:354    .text.UART_GetInstance:000000000000004c $d
     /tmp/ccEPGjFB.s:360    .rodata.UART_TransferGetRxRingBufferLength.str1.4:0000000000000000 $d
     /tmp/ccEPGjFB.s:364    .text.UART_TransferGetRxRingBufferLength:0000000000000000 $t
     /tmp/ccEPGjFB.s:370    .text.UART_TransferGetRxRingBufferLength:0000000000000000 UART_TransferGetRxRingBufferLength
     /tmp/ccEPGjFB.s:449    .text.UART_TransferGetRxRingBufferLength:000000000000005c $d
     /tmp/ccEPGjFB.s:454    .rodata.UART_TransferIsRxRingBufferFull.str1.4:0000000000000000 $d
     /tmp/ccEPGjFB.s:458    .text.UART_TransferIsRxRingBufferFull:0000000000000000 $t
     /tmp/ccEPGjFB.s:464    .text.UART_TransferIsRxRingBufferFull:0000000000000000 UART_TransferIsRxRingBufferFull
     /tmp/ccEPGjFB.s:527    .text.UART_TransferIsRxRingBufferFull:000000000000004c $d
     /tmp/ccEPGjFB.s:532    .rodata.UART_Init.str1.4:0000000000000000 $d
     /tmp/ccEPGjFB.s:540    .text.UART_Init:0000000000000000 $t
     /tmp/ccEPGjFB.s:547    .text.UART_Init:0000000000000000 UART_Init
     /tmp/ccEPGjFB.s:866    .text.UART_Init:00000000000001d0 $d
     /tmp/ccEPGjFB.s:874    .text.UART_Deinit:0000000000000000 $t
     /tmp/ccEPGjFB.s:881    .text.UART_Deinit:0000000000000000 UART_Deinit
     /tmp/ccEPGjFB.s:933    .text.UART_Deinit:000000000000003c $d
     /tmp/ccEPGjFB.s:938    .rodata.UART_GetDefaultConfig.str1.4:0000000000000000 $d
     /tmp/ccEPGjFB.s:942    .text.UART_GetDefaultConfig:0000000000000000 $t
     /tmp/ccEPGjFB.s:949    .text.UART_GetDefaultConfig:0000000000000000 UART_GetDefaultConfig
     /tmp/ccEPGjFB.s:1003   .text.UART_GetDefaultConfig:0000000000000040 $d
     /tmp/ccEPGjFB.s:1008   .rodata.UART_SetBaudRate.str1.4:0000000000000000 $d
     /tmp/ccEPGjFB.s:1012   .text.UART_SetBaudRate:0000000000000000 $t
     /tmp/ccEPGjFB.s:1019   .text.UART_SetBaudRate:0000000000000000 UART_SetBaudRate
     /tmp/ccEPGjFB.s:1217   .text.UART_SetBaudRate:0000000000000118 $d
     /tmp/ccEPGjFB.s:1223   .text.UART_EnableInterrupts:0000000000000000 $t
     /tmp/ccEPGjFB.s:1230   .text.UART_EnableInterrupts:0000000000000000 UART_EnableInterrupts
     /tmp/ccEPGjFB.s:1296   .text.UART_EnableInterrupts:0000000000000054 $d
     /tmp/ccEPGjFB.s:1301   .text.UART_DisableInterrupts:0000000000000000 $t
     /tmp/ccEPGjFB.s:1308   .text.UART_DisableInterrupts:0000000000000000 UART_DisableInterrupts
     /tmp/ccEPGjFB.s:1380   .text.UART_DisableInterrupts:0000000000000060 $d
     /tmp/ccEPGjFB.s:1385   .text.UART_GetEnabledInterrupts:0000000000000000 $t
     /tmp/ccEPGjFB.s:1392   .text.UART_GetEnabledInterrupts:0000000000000000 UART_GetEnabledInterrupts
     /tmp/ccEPGjFB.s:1442   .text.UART_GetEnabledInterrupts:0000000000000034 $d
     /tmp/ccEPGjFB.s:1447   .text.UART_GetStatusFlags:0000000000000000 $t
     /tmp/ccEPGjFB.s:1454   .text.UART_GetStatusFlags:0000000000000000 UART_GetStatusFlags
     /tmp/ccEPGjFB.s:1495   .text.UART_ClearStatusFlags:0000000000000000 $t
     /tmp/ccEPGjFB.s:1502   .text.UART_ClearStatusFlags:0000000000000000 UART_ClearStatusFlags
     /tmp/ccEPGjFB.s:1599   .text.UART_ClearStatusFlags:0000000000000078 $d
     /tmp/ccEPGjFB.s:1604   .text.UART_WriteBlocking:0000000000000000 $t
     /tmp/ccEPGjFB.s:1611   .text.UART_WriteBlocking:0000000000000000 UART_WriteBlocking
     /tmp/ccEPGjFB.s:1671   .rodata.UART_WriteNonBlocking.str1.4:0000000000000000 $d
     /tmp/ccEPGjFB.s:1675   .text.UART_WriteNonBlocking:0000000000000000 $t
     /tmp/ccEPGjFB.s:1681   .text.UART_WriteNonBlocking:0000000000000000 UART_WriteNonBlocking
     /tmp/ccEPGjFB.s:1741   .text.UART_WriteNonBlocking:0000000000000044 $d
     /tmp/ccEPGjFB.s:1746   .rodata.UART_ReadBlocking.str1.4:0000000000000000 $d
     /tmp/ccEPGjFB.s:1750   .text.UART_ReadBlocking:0000000000000000 $t
     /tmp/ccEPGjFB.s:1757   .text.UART_ReadBlocking:0000000000000000 UART_ReadBlocking
     /tmp/ccEPGjFB.s:1870   .text.UART_ReadBlocking:0000000000000088 $d
     /tmp/ccEPGjFB.s:1878   .rodata.UART_ReadNonBlocking.str1.4:0000000000000000 $d
     /tmp/ccEPGjFB.s:1882   .text.UART_ReadNonBlocking:0000000000000000 $t
     /tmp/ccEPGjFB.s:1888   .text.UART_ReadNonBlocking:0000000000000000 UART_ReadNonBlocking
     /tmp/ccEPGjFB.s:1950   .text.UART_ReadNonBlocking:0000000000000048 $d
     /tmp/ccEPGjFB.s:1955   .rodata.UART_TransferCreateHandle.str1.4:0000000000000000 $d
     /tmp/ccEPGjFB.s:1959   .text.UART_TransferCreateHandle:0000000000000000 $t
     /tmp/ccEPGjFB.s:1966   .text.UART_TransferCreateHandle:0000000000000000 UART_TransferCreateHandle
     /tmp/ccEPGjFB.s:2050   .text.UART_TransferCreateHandle:0000000000000078 $d
     /tmp/ccEPGjFB.s:3108   .text.UART_TransferHandleIRQ:0000000000000000 UART_TransferHandleIRQ
     /tmp/ccEPGjFB.s:2059   .rodata.UART_TransferStartRingBuffer.str1.4:0000000000000000 $d
     /tmp/ccEPGjFB.s:2066   .text.UART_TransferStartRingBuffer:0000000000000000 $t
     /tmp/ccEPGjFB.s:2073   .text.UART_TransferStartRingBuffer:0000000000000000 UART_TransferStartRingBuffer
     /tmp/ccEPGjFB.s:2160   .text.UART_TransferStartRingBuffer:0000000000000078 $d
     /tmp/ccEPGjFB.s:2166   .rodata.UART_TransferStopRingBuffer.str1.4:0000000000000000 $d
     /tmp/ccEPGjFB.s:2170   .text.UART_TransferStopRingBuffer:0000000000000000 $t
     /tmp/ccEPGjFB.s:2177   .text.UART_TransferStopRingBuffer:0000000000000000 UART_TransferStopRingBuffer
     /tmp/ccEPGjFB.s:2261   .text.UART_TransferStopRingBuffer:0000000000000070 $d
     /tmp/ccEPGjFB.s:2266   .rodata.UART_TransferSendNonBlocking.str1.4:0000000000000000 $d
     /tmp/ccEPGjFB.s:2279   .text.UART_TransferSendNonBlocking:0000000000000000 $t
     /tmp/ccEPGjFB.s:2286   .text.UART_TransferSendNonBlocking:0000000000000000 UART_TransferSendNonBlocking
     /tmp/ccEPGjFB.s:2400   .text.UART_TransferSendNonBlocking:0000000000000098 $d
     /tmp/ccEPGjFB.s:2408   .rodata.UART_TransferAbortSend.str1.4:0000000000000000 $d
     /tmp/ccEPGjFB.s:2412   .text.UART_TransferAbortSend:0000000000000000 $t
     /tmp/ccEPGjFB.s:2419   .text.UART_TransferAbortSend:0000000000000000 UART_TransferAbortSend
     /tmp/ccEPGjFB.s:2469   .text.UART_TransferAbortSend:000000000000003c $d
     /tmp/ccEPGjFB.s:2474   .rodata.UART_TransferGetSendCount.str1.4:0000000000000000 $d
     /tmp/ccEPGjFB.s:2481   .text.UART_TransferGetSendCount:0000000000000000 $t
     /tmp/ccEPGjFB.s:2488   .text.UART_TransferGetSendCount:0000000000000000 UART_TransferGetSendCount
     /tmp/ccEPGjFB.s:2558   .text.UART_TransferGetSendCount:0000000000000050 $d
     /tmp/ccEPGjFB.s:2564   .rodata.UART_TransferReceiveNonBlocking.str1.4:0000000000000000 $d
     /tmp/ccEPGjFB.s:2577   .text.UART_TransferReceiveNonBlocking:0000000000000000 $t
     /tmp/ccEPGjFB.s:2584   .text.UART_TransferReceiveNonBlocking:0000000000000000 UART_TransferReceiveNonBlocking
     /tmp/ccEPGjFB.s:2898   .text.UART_TransferReceiveNonBlocking:00000000000001b8 $d
     /tmp/ccEPGjFB.s:2908   .rodata.UART_TransferAbortReceive.str1.4:0000000000000000 $d
     /tmp/ccEPGjFB.s:2912   .text.UART_TransferAbortReceive:0000000000000000 $t
     /tmp/ccEPGjFB.s:2919   .text.UART_TransferAbortReceive:0000000000000000 UART_TransferAbortReceive
     /tmp/ccEPGjFB.s:2994   .text.UART_TransferAbortReceive:0000000000000064 $d
     /tmp/ccEPGjFB.s:2999   .rodata.UART_TransferGetReceiveCount.str1.4:0000000000000000 $d
     /tmp/ccEPGjFB.s:3006   .text.UART_TransferGetReceiveCount:0000000000000000 $t
     /tmp/ccEPGjFB.s:3013   .text.UART_TransferGetReceiveCount:0000000000000000 UART_TransferGetReceiveCount
     /tmp/ccEPGjFB.s:3091   .text.UART_TransferGetReceiveCount:000000000000005c $d
     /tmp/ccEPGjFB.s:3097   .rodata.UART_TransferHandleIRQ.str1.4:0000000000000000 $d
     /tmp/ccEPGjFB.s:3101   .text.UART_TransferHandleIRQ:0000000000000000 $t
     /tmp/ccEPGjFB.s:3638   .text.UART_TransferHandleIRQ:00000000000002e8 $d
     /tmp/ccEPGjFB.s:3644   .text.UART_TransferHandleIRQ:00000000000002f8 $t
     /tmp/ccEPGjFB.s:3745   .text.UART_TransferHandleIRQ:0000000000000390 $d
     /tmp/ccEPGjFB.s:3750   .text.UART_TransferHandleErrorIRQ:0000000000000000 $t
     /tmp/ccEPGjFB.s:3757   .text.UART_TransferHandleErrorIRQ:0000000000000000 UART_TransferHandleErrorIRQ
     /tmp/ccEPGjFB.s:3783   .text.UART1_DriverIRQHandler:0000000000000000 $t
     /tmp/ccEPGjFB.s:3790   .text.UART1_DriverIRQHandler:0000000000000000 UART1_DriverIRQHandler
     /tmp/ccEPGjFB.s:3819   .text.UART1_DriverIRQHandler:0000000000000018 $d
     /tmp/ccEPGjFB.s:3826   .text.UART1_RX_TX_DriverIRQHandler:0000000000000000 $t
     /tmp/ccEPGjFB.s:3833   .text.UART1_RX_TX_DriverIRQHandler:0000000000000000 UART1_RX_TX_DriverIRQHandler
     /tmp/ccEPGjFB.s:3856   .text.UART2_DriverIRQHandler:0000000000000000 $t
     /tmp/ccEPGjFB.s:3863   .text.UART2_DriverIRQHandler:0000000000000000 UART2_DriverIRQHandler
     /tmp/ccEPGjFB.s:3892   .text.UART2_DriverIRQHandler:0000000000000018 $d
     /tmp/ccEPGjFB.s:3899   .text.UART2_RX_TX_DriverIRQHandler:0000000000000000 $t
     /tmp/ccEPGjFB.s:3906   .text.UART2_RX_TX_DriverIRQHandler:0000000000000000 UART2_RX_TX_DriverIRQHandler
                           .group:0000000000000000 wm4.0.b17fa403cb9718989e7a4b461e73e1c9
                           .group:0000000000000000 wm4.redlib_version.h.16.f905717e4b3a91dcbdbb631865150df4
                           .group:0000000000000000 wm4.assert.h.25.5fa7b1099c5f353f7f0154f84a745cec
                           .group:0000000000000000 wm4.stdbool.h.15.fddf1cb2402fd739d8e2516677869231
                           .group:0000000000000000 wm4.libconfigarm.h.19.34723c94cbd19598192aa6b1e87fca41
                           .group:0000000000000000 wm4.stdint.h.31.58198de4ea930fb897655479091e17c7
                           .group:0000000000000000 wm4.fsl_device_registers.h.32.0bd0fc1949c4d5ee8778d13f693b6d67
                           .group:0000000000000000 wm4.MKL25Z4.h.103.6fa60f7365436a291410ac7ae38d8851
                           .group:0000000000000000 wm4.core_cm0plus.h.42.7e68c73109133db28e6113a0ee252d6f
                           .group:0000000000000000 wm4.cmsis_gcc.h.36.5bb14fd68ce7855540fcfe2d9305ae16
                           .group:0000000000000000 wm4.core_cm0plus.h.175.8e2cbb335a2ae70828db295817e11b6e
                           .group:0000000000000000 wm4.system_MKL25Z4.h.107.b43986f939b1bf0ee0f9aa04879788f4
                           .group:0000000000000000 wm4.MKL25Z4.h.379.376a3f36380a1b2f1e4cdc95287bb342
                           .group:0000000000000000 wm4.MKL25Z4_features.h.84.30fd6c6f11c9d2ffea2189829de10275
                           .group:0000000000000000 wm4.fsl_common.h.55.f0a989f874fed9062f996a5c92215a0e
                           .group:0000000000000000 wm4.fsl_clock.h.61.86ace3515ab77fa85db71e2d42e7d189
                           .group:0000000000000000 wm4.fsl_common.h.162.37daaf5dee6e1f72e10ac988afa1643d

UNDEFINED SYMBOLS
__assertion_failed
__aeabi_uidiv
memset
